//-------- js/zip.js --------
/*
Copyright (c) 2013 Gildas Lormeau. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in
the documentation and/or other materials provided with the distribution.
3. The names of the authors may not be used to endorse or promote products
derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function(obj) {
"use strict";
var ERR_BAD_FORMAT = "File format is not recognized.";
var ERR_CRC = "CRC failed.";
var ERR_ENCRYPTED = "File contains encrypted entry.";
var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
var ERR_READ = "Error while reading zip file.";
var ERR_WRITE = "Error while writing zip file.";
var ERR_WRITE_DATA = "Error while writing file data.";
var ERR_READ_DATA = "Error while reading file data.";
var ERR_DUPLICATED_NAME = "File already exists.";
var CHUNK_SIZE = 512 * 1024;
var TEXT_PLAIN = "text/plain";
var appendABViewSupported;
try {
appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
} catch (e) {
}
function Crc32() {
this.crc = -1;
}
Crc32.prototype.append = function append(data) {
var crc = this.crc | 0, table = this.table;
for (var offset = 0, len = data.length | 0; offset < len; offset++)
crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
this.crc = crc;
};
Crc32.prototype.get = function get() {
return ~this.crc;
};
Crc32.prototype.table = (function() {
var i, j, t, table = []; // Uint32Array is actually slower than []
for (i = 0; i < 256; i++) {
t = i;
for (j = 0; j < 8; j++)
if (t & 1)
t = (t >>> 1) ^ 0xEDB88320;
else
t = t >>> 1;
table[i] = t;
}
return table;
})();
// "no-op" codec
function NOOP() {}
NOOP.prototype.append = function append(bytes, onprogress) {
return bytes;
};
NOOP.prototype.flush = function flush() {};
function blobSlice(blob, index, length) {
if (index < 0 || length < 0 || index + length > blob.size)
throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
if (blob.slice)
return blob.slice(index, index + length);
else if (blob.webkitSlice)
return blob.webkitSlice(index, index + length);
else if (blob.mozSlice)
return blob.mozSlice(index, index + length);
else if (blob.msSlice)
return blob.msSlice(index, index + length);
}
function getDataHelper(byteLength, bytes) {
var dataBuffer, dataArray;
dataBuffer = new ArrayBuffer(byteLength);
dataArray = new Uint8Array(dataBuffer);
if (bytes)
dataArray.set(bytes, 0);
return {
buffer : dataBuffer,
array : dataArray,
view : new DataView(dataBuffer)
};
}
// Readers
function Reader() {
}
function TextReader(text) {
var that = this, blobReader;
function init(callback, onerror) {
var blob = new Blob([ text ], {
type : TEXT_PLAIN
});
blobReader = new BlobReader(blob);
blobReader.init(function() {
that.size = blobReader.size;
callback();
}, onerror);
}
function readUint8Array(index, length, callback, onerror) {
blobReader.readUint8Array(index, length, callback, onerror);
}
that.size = 0;
that.init = init;
that.readUint8Array = readUint8Array;
}
TextReader.prototype = new Reader();
TextReader.prototype.constructor = TextReader;
function Data64URIReader(dataURI) {
var that = this, dataStart;
function init(callback) {
var dataEnd = dataURI.length;
while (dataURI.charAt(dataEnd - 1) == "=")
dataEnd--;
dataStart = dataURI.indexOf(",") + 1;
that.size = Math.floor((dataEnd - dataStart) * 0.75);
callback();
}
function readUint8Array(index, length, callback) {
var i, data = getDataHelper(length);
var start = Math.floor(index / 3) * 4;
var end = Math.ceil((index + length) / 3) * 4;
var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
var delta = index - Math.floor(start / 4) * 3;
for (i = delta; i < delta + length; i++)
data.array[i - delta] = bytes.charCodeAt(i);
callback(data.array);
}
that.size = 0;
that.init = init;
that.readUint8Array = readUint8Array;
}
Data64URIReader.prototype = new Reader();
Data64URIReader.prototype.constructor = Data64URIReader;
function BlobReader(blob) {
var that = this;
function init(callback) {
that.size = blob.size;
callback();
}
function readUint8Array(index, length, callback, onerror) {
var reader = new FileReader();
reader.onload = function(e) {
callback(new Uint8Array(e.target.result));
};
reader.onerror = onerror;
try {
reader.readAsArrayBuffer(blobSlice(blob, index, length));
} catch (e) {
onerror(e);
}
}
that.size = 0;
that.init = init;
that.readUint8Array = readUint8Array;
}
BlobReader.prototype = new Reader();
BlobReader.prototype.constructor = BlobReader;
// Writers
function Writer() {
}
Writer.prototype.getData = function(callback) {
callback(this.data);
};
function TextWriter(encoding) {
var that = this, blob;
function init(callback) {
blob = new Blob([], {
type : TEXT_PLAIN
});
callback();
}
function writeUint8Array(array, callback) {
blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
type : TEXT_PLAIN
});
callback();
}
function getData(callback, onerror) {
var reader = new FileReader();
reader.onload = function(e) {
callback(e.target.result);
};
reader.onerror = onerror;
reader.readAsText(blob, encoding);
}
that.init = init;
that.writeUint8Array = writeUint8Array;
that.getData = getData;
}
TextWriter.prototype = new Writer();
TextWriter.prototype.constructor = TextWriter;
function Data64URIWriter(contentType) {
var that = this, data = "", pending = "";
function init(callback) {
data += "data:" + (contentType || "") + ";base64,";
callback();
}
function writeUint8Array(array, callback) {
var i, delta = pending.length, dataString = pending;
pending = "";
for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
dataString += String.fromCharCode(array[i]);
for (; i < array.length; i++)
pending += String.fromCharCode(array[i]);
if (dataString.length > 2)
data += obj.btoa(dataString);
else
pending = dataString;
callback();
}
function getData(callback) {
callback(data + obj.btoa(pending));
}
that.init = init;
that.writeUint8Array = writeUint8Array;
that.getData = getData;
}
Data64URIWriter.prototype = new Writer();
Data64URIWriter.prototype.constructor = Data64URIWriter;
function BlobWriter(contentType) {
var blob, that = this;
function init(callback) {
blob = new Blob([], {
type : contentType
});
callback();
}
function writeUint8Array(array, callback) {
blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
type : contentType
});
callback();
}
function getData(callback) {
callback(blob);
}
that.init = init;
that.writeUint8Array = writeUint8Array;
that.getData = getData;
}
BlobWriter.prototype = new Writer();
BlobWriter.prototype.constructor = BlobWriter;
/** 
* inflate/deflate core functions
* @param worker {Worker} web worker for the task.
* @param initialMessage {Object} initial message to be sent to the worker. should contain
*   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
*   This function may add more properties before sending.
*/
function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;
function onflush() {
worker.removeEventListener('message', onmessage, false);
onend(outputSize, crc);
}
function onmessage(event) {
var message = event.data, data = message.data, err = message.error;
if (err) {
err.toString = function () { return 'Error: ' + this.message; };
onreaderror(err);
return;
}
if (message.sn !== sn)
return;
if (typeof message.codecTime === 'number')
worker.codecTime += message.codecTime; // should be before onflush()
if (typeof message.crcTime === 'number')
worker.crcTime += message.crcTime;
switch (message.type) {
case 'append':
if (data) {
outputSize += data.length;
writer.writeUint8Array(data, function() {
step();
}, onwriteerror);
} else
step();
break;
case 'flush':
crc = message.crc;
if (data) {
outputSize += data.length;
writer.writeUint8Array(data, function() {
onflush();
}, onwriteerror);
} else
onflush();
break;
case 'progress':
if (onprogress)
onprogress(index + message.loaded, size);
break;
case 'importScripts': //no need to handle here
case 'newTask':
case 'echo':
break;
default:
console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
}
}
function step() {
index = chunkIndex * CHUNK_SIZE;
// use `<=` instead of `<`, because `size` may be 0.
if (index <= size) {
reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
if (onprogress)
onprogress(index, size);
var msg = index === 0 ? initialMessage : {sn : sn};
msg.type = 'append';
msg.data = array;
// posting a message with transferables will fail on IE10
try {
worker.postMessage(msg, [array.buffer]);
} catch(ex) {
worker.postMessage(msg); // retry without transferables
}
chunkIndex++;
}, onreaderror);
} else {
worker.postMessage({
sn: sn,
type: 'flush'
});
}
}
outputSize = 0;
worker.addEventListener('message', onmessage, false);
step();
}
function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
var chunkIndex = 0, index, outputSize = 0,
crcInput = crcType === 'input',
crcOutput = crcType === 'output',
crc = new Crc32();
function step() {
var outputData;
index = chunkIndex * CHUNK_SIZE;
if (index < size)
reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
var outputData;
try {
outputData = process.append(inputData, function(loaded) {
if (onprogress)
onprogress(index + loaded, size);
});
} catch (e) {
onreaderror(e);
return;
}
if (outputData) {
outputSize += outputData.length;
writer.writeUint8Array(outputData, function() {
chunkIndex++;
setTimeout(step, 1);
}, onwriteerror);
if (crcOutput)
crc.append(outputData);
} else {
chunkIndex++;
setTimeout(step, 1);
}
if (crcInput)
crc.append(inputData);
if (onprogress)
onprogress(index, size);
}, onreaderror);
else {
try {
outputData = process.flush();
} catch (e) {
onreaderror(e);
return;
}
if (outputData) {
if (crcOutput)
crc.append(outputData);
outputSize += outputData.length;
writer.writeUint8Array(outputData, function() {
onend(outputSize, crc.get());
}, onwriteerror);
} else
onend(outputSize, crc.get());
}
}
step();
}
function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
var crcType = computeCrc32 ? 'output' : 'none';
if (obj.zip.useWebWorkers) {
var initialMessage = {
sn: sn,
codecClass: 'Inflater',
crcType: crcType,
};
launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
} else
launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
}
function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
var crcType = 'input';
if (obj.zip.useWebWorkers) {
var initialMessage = {
sn: sn,
options: {level: level},
codecClass: 'Deflater',
crcType: crcType,
};
launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
} else
launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
}
function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
var crcType = 'input';
if (obj.zip.useWebWorkers && computeCrc32) {
var initialMessage = {
sn: sn,
codecClass: 'NOOP',
crcType: crcType,
};
launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
} else
launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
}
// ZipReader
function decodeASCII(str) {
var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
for (i = 0; i < str.length; i++) {
charCode = str.charCodeAt(i) & 0xFF;
if (charCode > 127)
out += extendedASCII[charCode - 128];
else
out += String.fromCharCode(charCode);
}
return out;
}
function decodeUTF8(string) {
return decodeURIComponent(escape(string));
}
function getString(bytes) {
var i, str = "";
for (i = 0; i < bytes.length; i++)
str += String.fromCharCode(bytes[i]);
return str;
}
function getDate(timeRaw) {
var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
try {
return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
(time & 0x001F) * 2, 0);
} catch (e) {
}
}
function readCommonHeader(entry, data, index, centralDirectory, onerror) {
entry.version = data.view.getUint16(index, true);
entry.bitFlag = data.view.getUint16(index + 2, true);
entry.compressionMethod = data.view.getUint16(index + 4, true);
entry.lastModDateRaw = data.view.getUint32(index + 6, true);
entry.lastModDate = getDate(entry.lastModDateRaw);
if ((entry.bitFlag & 0x01) === 0x01) {
onerror(ERR_ENCRYPTED);
return;
}
if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
entry.crc32 = data.view.getUint32(index + 10, true);
entry.compressedSize = data.view.getUint32(index + 14, true);
entry.uncompressedSize = data.view.getUint32(index + 18, true);
}
if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
onerror(ERR_ZIP64);
return;
}
entry.filenameLength = data.view.getUint16(index + 22, true);
entry.extraFieldLength = data.view.getUint16(index + 24, true);
}
function createZipReader(reader, callback, onerror) {
var inflateSN = 0;
function Entry() {
}
Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
var that = this;
function testCrc32(crc32) {
var dataCrc32 = getDataHelper(4);
dataCrc32.view.setUint32(0, crc32);
return that.crc32 == dataCrc32.view.getUint32(0);
}
function getWriterData(uncompressedSize, crc32) {
if (checkCrc32 && !testCrc32(crc32))
onerror(ERR_CRC);
else
writer.getData(function(data) {
onend(data);
});
}
function onreaderror(err) {
onerror(err || ERR_READ_DATA);
}
function onwriteerror(err) {
onerror(err || ERR_WRITE_DATA);
}
reader.readUint8Array(that.offset, 30, function(bytes) {
var data = getDataHelper(bytes.length, bytes), dataOffset;
if (data.view.getUint32(0) != 0x504b0304) {
onerror(ERR_BAD_FORMAT);
return;
}
readCommonHeader(that, data, 4, false, onerror);
dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
writer.init(function() {
if (that.compressionMethod === 0)
copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
else
inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
}, onwriteerror);
}, onreaderror);
};
function seekEOCDR(eocdrCallback) {
// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
// Zip file comment is the last part of EOCDR and has max length of 64KB,
// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
var EOCDR_MIN = 22;
if (reader.size < EOCDR_MIN) {
onerror(ERR_BAD_FORMAT);
return;
}
var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;
// In most cases, the EOCDR is EOCDR_MIN bytes long
doSeek(EOCDR_MIN, function() {
// If not found, try within EOCDR_MAX bytes
doSeek(Math.min(EOCDR_MAX, reader.size), function() {
onerror(ERR_BAD_FORMAT);
});
});
// seek last length bytes of file for EOCDR
function doSeek(length, eocdrNotFoundCallback) {
reader.readUint8Array(reader.size - length, length, function(bytes) {
for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
return;
}
}
eocdrNotFoundCallback();
}, function() {
onerror(ERR_READ);
});
}
}
var zipReader = {
getEntries : function(callback) {
var worker = this._worker;
// look for End of central directory record
seekEOCDR(function(dataView) {
var datalength, fileslength;
datalength = dataView.getUint32(16, true);
fileslength = dataView.getUint16(8, true);
if (datalength < 0 || datalength >= reader.size) {
onerror(ERR_BAD_FORMAT);
return;
}
reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
for (i = 0; i < fileslength; i++) {
entry = new Entry();
entry._worker = worker;
if (data.view.getUint32(index) != 0x504b0102) {
onerror(ERR_BAD_FORMAT);
return;
}
readCommonHeader(entry, data, index + 6, true, onerror);
entry.commentLength = data.view.getUint16(index + 32, true);
entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
entry.offset = data.view.getUint32(index + 42, true);
filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
entry.directory = true;
comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
entries.push(entry);
index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
}
callback(entries);
}, function() {
onerror(ERR_READ);
});
});
},
close : function(callback) {
if (this._worker) {
this._worker.terminate();
this._worker = null;
}
if (callback)
callback();
},
_worker: null
};
if (!obj.zip.useWebWorkers)
callback(zipReader);
else {
createWorker('inflater',
function(worker) {
zipReader._worker = worker;
callback(zipReader);
},
function(err) {
onerror(err);
}
);
}
}
// ZipWriter
function encodeUTF8(string) {
return unescape(encodeURIComponent(string));
}
function getBytes(str) {
var i, array = [];
for (i = 0; i < str.length; i++)
array.push(str.charCodeAt(i));
return array;
}
function createZipWriter(writer, callback, onerror, dontDeflate) {
var files = {}, filenames = [], datalength = 0;
var deflateSN = 0;
function onwriteerror(err) {
onerror(err || ERR_WRITE);
}
function onreaderror(err) {
onerror(err || ERR_READ_DATA);
}
var zipWriter = {
add : function(name, reader, onend, onprogress, options) {
var header, filename, date;
var worker = this._worker;
function writeHeader(callback) {
var data;
date = options.lastModDate || new Date();
header = getDataHelper(26);
files[name] = {
headerArray : header.array,
directory : options.directory,
filename : filename,
offset : datalength,
comment : getBytes(encodeUTF8(options.comment || ""))
};
header.view.setUint32(0, 0x14000808);
if (options.version)
header.view.setUint8(0, options.version);
if (!dontDeflate && options.level !== 0 && !options.directory)
header.view.setUint16(4, 0x0800);
header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
header.view.setUint16(22, filename.length, true);
data = getDataHelper(30 + filename.length);
data.view.setUint32(0, 0x504b0304);
data.array.set(header.array, 4);
data.array.set(filename, 30);
datalength += data.array.length;
writer.writeUint8Array(data.array, callback, onwriteerror);
}
function writeFooter(compressedLength, crc32) {
var footer = getDataHelper(16);
datalength += compressedLength || 0;
footer.view.setUint32(0, 0x504b0708);
if (typeof crc32 != "undefined") {
header.view.setUint32(10, crc32, true);
footer.view.setUint32(4, crc32, true);
}
if (reader) {
footer.view.setUint32(8, compressedLength, true);
header.view.setUint32(14, compressedLength, true);
footer.view.setUint32(12, reader.size, true);
header.view.setUint32(18, reader.size, true);
}
writer.writeUint8Array(footer.array, function() {
datalength += 16;
onend();
}, onwriteerror);
}
function writeFile() {
options = options || {};
name = name.trim();
if (options.directory && name.charAt(name.length - 1) != "/")
name += "/";
if (files.hasOwnProperty(name)) {
onerror(ERR_DUPLICATED_NAME);
return;
}
filename = getBytes(encodeUTF8(name));
filenames.push(name);
writeHeader(function() {
if (reader)
if (dontDeflate || options.level === 0)
copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
else
deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
else
writeFooter();
}, onwriteerror);
}
if (reader)
reader.init(writeFile, onreaderror);
else
writeFile();
},
close : function(callback) {
if (this._worker) {
this._worker.terminate();
this._worker = null;
}
var data, length = 0, index = 0, indexFilename, file;
for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
file = files[filenames[indexFilename]];
length += 46 + file.filename.length + file.comment.length;
}
data = getDataHelper(length + 22);
for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
file = files[filenames[indexFilename]];
data.view.setUint32(index, 0x504b0102);
data.view.setUint16(index + 4, 0x1400);
data.array.set(file.headerArray, index + 6);
data.view.setUint16(index + 32, file.comment.length, true);
if (file.directory)
data.view.setUint8(index + 38, 0x10);
data.view.setUint32(index + 42, file.offset, true);
data.array.set(file.filename, index + 46);
data.array.set(file.comment, index + 46 + file.filename.length);
index += 46 + file.filename.length + file.comment.length;
}
data.view.setUint32(index, 0x504b0506);
data.view.setUint16(index + 8, filenames.length, true);
data.view.setUint16(index + 10, filenames.length, true);
data.view.setUint32(index + 12, length, true);
data.view.setUint32(index + 16, datalength, true);
writer.writeUint8Array(data.array, function() {
writer.getData(callback);
}, onwriteerror);
},
_worker: null
};
if (!obj.zip.useWebWorkers)
callback(zipWriter);
else {
createWorker('deflater',
function(worker) {
zipWriter._worker = worker;
callback(zipWriter);
},
function(err) {
onerror(err);
}
);
}
}
function resolveURLs(urls) {
var a = document.createElement('a');
return urls.map(function(url) {
a.href = url;
return a.href;
});
}
var DEFAULT_WORKER_SCRIPTS = {
deflater: ['z-worker.js', 'deflate.js'],
inflater: ['z-worker.js', 'inflate.js']
};
function createWorker(type, callback, onerror) {
if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
return;
}
var scripts;
if (obj.zip.workerScripts) {
scripts = obj.zip.workerScripts[type];
if (!Array.isArray(scripts)) {
onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
return;
}
scripts = resolveURLs(scripts);
} else {
scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
}
var worker = new Worker(scripts[0]);
// record total consumed time by inflater/deflater/crc32 in this worker
worker.codecTime = worker.crcTime = 0;
worker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });
worker.addEventListener('message', onmessage);
function onmessage(ev) {
var msg = ev.data;
if (msg.error) {
worker.terminate(); // should before onerror(), because onerror() may throw.
onerror(msg.error);
return;
}
if (msg.type === 'importScripts') {
worker.removeEventListener('message', onmessage);
worker.removeEventListener('error', errorHandler);
callback(worker);
}
}
// catch entry script loading error and other unhandled errors
worker.addEventListener('error', errorHandler);
function errorHandler(err) {
worker.terminate();
onerror(err);
}
}
function onerror_default(error) {
console.error(error);
}
obj.zip = {
Reader : Reader,
Writer : Writer,
BlobReader : BlobReader,
Data64URIReader : Data64URIReader,
TextReader : TextReader,
BlobWriter : BlobWriter,
Data64URIWriter : Data64URIWriter,
TextWriter : TextWriter,
createReader : function(reader, callback, onerror) {
onerror = onerror || onerror_default;
reader.init(function() {
createZipReader(reader, callback, onerror);
}, onerror);
},
createWriter : function(writer, callback, onerror, dontDeflate) {
onerror = onerror || onerror_default;
dontDeflate = !!dontDeflate;
writer.init(function() {
createZipWriter(writer, callback, onerror, dontDeflate);
}, onerror);
},
useWebWorkers : true,
/**
* Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
* E.g.: zip.workerScripts = './';
*/
workerScriptsPath : null,
/**
* Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
* workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
* Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
* All urls are relative to current base url.
* E.g.:
* zip.workerScripts = {
*   deflater: ['z-worker.js', 'deflate.js'],
*   inflater: ['z-worker.js', 'inflate.js']
* };
*/
workerScripts : null,
};
})(this);
//-------- js/zip-ext.js --------
/*
Copyright (c) 2013 Gildas Lormeau. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in
the documentation and/or other materials provided with the distribution.
3. The names of the authors may not be used to endorse or promote products
derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function() {
"use strict";
var ERR_HTTP_RANGE = "HTTP Range not supported.";
var Reader = zip.Reader;
var Writer = zip.Writer;
var ZipDirectoryEntry;
var appendABViewSupported;
try {
appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
} catch (e) {
}
function HttpReader(url) {
var that = this;
function getData(callback, onerror) {
var request;
if (!that.data) {
request = new XMLHttpRequest();
request.addEventListener("load", function() {
if (!that.size)
that.size = Number(request.getResponseHeader("Content-Length")) || Number(request.response.byteLength);
that.data = new Uint8Array(request.response);
callback();
}, false);
request.addEventListener("error", onerror, false);
request.open("GET", url);
request.responseType = "arraybuffer";
request.send();
} else
callback();
}
function init(callback, onerror) {
var request = new XMLHttpRequest();
request.addEventListener("load", function() {
that.size = Number(request.getResponseHeader("Content-Length"));
// If response header doesn't return size then prefetch the content.
if (!that.size) {
getData(callback, onerror);
} else {
callback();
}
}, false);
request.addEventListener("error", onerror, false);
request.open("HEAD", url);
request.send();
}
function readUint8Array(index, length, callback, onerror) {
getData(function() {
callback(new Uint8Array(that.data.subarray(index, index + length)));
}, onerror);
}
that.size = 0;
that.init = init;
that.readUint8Array = readUint8Array;
}
HttpReader.prototype = new Reader();
HttpReader.prototype.constructor = HttpReader;
function HttpRangeReader(url) {
var that = this;
function init(callback, onerror) {
var request = new XMLHttpRequest();
request.addEventListener("load", function() {
that.size = Number(request.getResponseHeader("Content-Length"));
if (request.getResponseHeader("Accept-Ranges") == "bytes")
callback();
else
onerror(ERR_HTTP_RANGE);
}, false);
request.addEventListener("error", onerror, false);
request.open("HEAD", url);
request.send();
}
function readArrayBuffer(index, length, callback, onerror) {
var request = new XMLHttpRequest();
request.open("GET", url);
request.responseType = "arraybuffer";
request.setRequestHeader("Range", "bytes=" + index + "-" + (index + length - 1));
request.addEventListener("load", function() {
callback(request.response);
}, false);
request.addEventListener("error", onerror, false);
request.send();
}
function readUint8Array(index, length, callback, onerror) {
readArrayBuffer(index, length, function(arraybuffer) {
callback(new Uint8Array(arraybuffer));
}, onerror);
}
that.size = 0;
that.init = init;
that.readUint8Array = readUint8Array;
}
HttpRangeReader.prototype = new Reader();
HttpRangeReader.prototype.constructor = HttpRangeReader;
function ArrayBufferReader(arrayBuffer) {
var that = this;
function init(callback, onerror) {
that.size = arrayBuffer.byteLength;
callback();
}
function readUint8Array(index, length, callback, onerror) {
callback(new Uint8Array(arrayBuffer.slice(index, index + length)));
}
that.size = 0;
that.init = init;
that.readUint8Array = readUint8Array;
}
ArrayBufferReader.prototype = new Reader();
ArrayBufferReader.prototype.constructor = ArrayBufferReader;
function ArrayBufferWriter() {
var array, that = this;
function init(callback, onerror) {
array = new Uint8Array();
callback();
}
function writeUint8Array(arr, callback, onerror) {
var tmpArray = new Uint8Array(array.length + arr.length);
tmpArray.set(array);
tmpArray.set(arr, array.length);
array = tmpArray;
callback();
}
function getData(callback) {
callback(array.buffer);
}
that.init = init;
that.writeUint8Array = writeUint8Array;
that.getData = getData;
}
ArrayBufferWriter.prototype = new Writer();
ArrayBufferWriter.prototype.constructor = ArrayBufferWriter;
function FileWriter(fileEntry, contentType) {
var writer, that = this;
function init(callback, onerror) {
fileEntry.createWriter(function(fileWriter) {
writer = fileWriter;
callback();
}, onerror);
}
function writeUint8Array(array, callback, onerror) {
var blob = new Blob([ appendABViewSupported ? array : array.buffer ], {
type : contentType
});
writer.onwrite = function() {
writer.onwrite = null;
callback();
};
writer.onerror = onerror;
writer.write(blob);
}
function getData(callback) {
fileEntry.file(callback);
}
that.init = init;
that.writeUint8Array = writeUint8Array;
that.getData = getData;
}
FileWriter.prototype = new Writer();
FileWriter.prototype.constructor = FileWriter;
zip.FileWriter = FileWriter;
zip.HttpReader = HttpReader;
zip.HttpRangeReader = HttpRangeReader;
zip.ArrayBufferReader = ArrayBufferReader;
zip.ArrayBufferWriter = ArrayBufferWriter;
if (zip.fs) {
ZipDirectoryEntry = zip.fs.ZipDirectoryEntry;
ZipDirectoryEntry.prototype.addHttpContent = function(name, URL, useRangeHeader) {
function addChild(parent, name, params, directory) {
if (parent.directory)
return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new zip.fs.ZipFileEntry(parent.fs, name, params, parent);
else
throw "Parent entry is not a directory.";
}
return addChild(this, name, {
data : URL,
Reader : useRangeHeader ? HttpRangeReader : HttpReader
});
};
ZipDirectoryEntry.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {
this.importZip(useRangeHeader ? new HttpRangeReader(URL) : new HttpReader(URL), onend, onerror);
};
zip.fs.FS.prototype.importHttpContent = function(URL, useRangeHeader, onend, onerror) {
this.entries = [];
this.root = new ZipDirectoryEntry(this);
this.root.importHttpContent(URL, useRangeHeader, onend, onerror);
};
}
})();
//-------- js/zip-dv-ext.js --------
/*
Copyright (c) 2013 Gildas Lormeau. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in
the documentation and/or other materials provided with the distribution.
3. The names of the authors may not be used to endorse or promote products
derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function() {
"use strict";
// Repeated to avoid changing zip.js to expose it
function getDataHelper(byteLength, bytes) {
var dataBuffer, dataArray;
dataBuffer = new ArrayBuffer(byteLength);
dataArray = new Uint8Array(dataBuffer);
if (bytes)
dataArray.set(bytes, 0);
return {
buffer : dataBuffer,
array : dataArray,
view : new DataView(dataBuffer)
};
}
// Extension to the set of Writers -- DataViewWriter. Presumably by RE.
function DataViewWriter(byteLength) {
var data, offset, that = this;
function init(callback, onerror) {
data = getDataHelper(byteLength);
offset = 0;
callback();
}
function writeUint8Array(array, callback, onerror) {
//window.console.log("Adding byte range ["+offset+".."+(offset+array.byteLength)+")");
data.array.set(array, offset);
offset += array.byteLength;
callback();
}
function getData(callback) {
callback(data.view);
}
that.init = init;
that.writeUint8Array = writeUint8Array;
that.getData = getData;
}
DataViewWriter.prototype = new zip.Writer();
DataViewWriter.prototype.constructor = DataViewWriter;
zip.DataViewWriter = DataViewWriter;
})();
//-------- js/inflate.js --------
/*
Copyright (c) 2013 Gildas Lormeau. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright 
notice, this list of conditions and the following disclaimer in 
the documentation and/or other materials provided with the distribution.
3. The names of the authors may not be used to endorse or promote products
derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
* This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
* JZlib is based on zlib-1.1.3, so all credit should go authors
* Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
* and contributors of zlib.
*/
(function(global) {
"use strict";
// Global
var MAX_BITS = 15;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,
0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];
var MANY = 1440;
// JZlib version : "1.0.2"
var Z_NO_FLUSH = 0;
var Z_FINISH = 4;
// InfTree
var fixed_bl = 9;
var fixed_bd = 5;
var fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,
0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,
0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,
0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,
0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,
35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,
26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,
7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,
8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,
8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,
0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,
81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,
0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,
0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,
80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,
0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,
0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,
193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,
120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,
227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,
92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,
249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,
130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,
181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,
102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,
221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,
147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,
85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,
235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,
141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,
167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,
107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,
207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,
127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];
var fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,
8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,
24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];
// Tables for deflate from PKZIP's appnote.txt.
var cplens = [ // Copy lengths for literal codes 257..285
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
// see note #13 above about 258
var cplext = [ // Extra bits for literal codes 257..285
0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid
];
var cpdist = [ // Copy offsets for distance codes 0..29
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
var cpdext = [ // Extra bits for distance codes
0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
// If BMAX needs to be larger than 16, then h and x[] should be uLong.
var BMAX = 15; // maximum bit length of any code
function InfTree() {
var that = this;
var hn; // hufts used in space
var v; // work area for huft_build
var c; // bit length count table
var r; // table entry for structure assignment
var u; // table stack
var x; // bit offsets, then code stack
function huft_build(b, // code lengths in bits (all assumed <=
// BMAX)
bindex, n, // number of codes (assumed <= 288)
s, // number of simple-valued codes (0..s-1)
d, // list of base values for non-simple codes
e, // list of extra bits for non-simple codes
t, // result: starting table
m, // maximum lookup bits, returns actual
hp,// space for trees
hn,// hufts used in space
v // working area: values in order of bit length
) {
// Given a list of code lengths and a maximum table size, make a set of
// tables to decode that set of codes. Return Z_OK on success,
// Z_BUF_ERROR
// if the given code set is incomplete (the tables are still built in
// this
// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set
// of
// lengths), or Z_MEM_ERROR if not enough memory.
var a; // counter for codes of length k
var f; // i repeats in table every f entries
var g; // maximum code length
var h; // table level
var i; // counter, current code
var j; // counter
var k; // number of bits in current code
var l; // bits per table (returned in m)
var mask; // (1 << w) - 1, to avoid cc -O bug on HP
var p; // pointer into c[], b[], or v[]
var q; // points to current table
var w; // bits before this table == (l * h)
var xp; // pointer into x
var y; // number of dummy codes added
var z; // number of entries in current table
// Generate counts for each bit length
p = 0;
i = n;
do {
c[b[bindex + p]]++;
p++;
i--; // assume all entries <= BMAX
} while (i !== 0);
if (c[0] == n) { // null input--all zero length codes
t[0] = -1;
m[0] = 0;
return Z_OK;
}
// Find minimum and maximum length, bound *m by those
l = m[0];
for (j = 1; j <= BMAX; j++)
if (c[j] !== 0)
break;
k = j; // minimum code length
if (l < j) {
l = j;
}
for (i = BMAX; i !== 0; i--) {
if (c[i] !== 0)
break;
}
g = i; // maximum code length
if (l > i) {
l = i;
}
m[0] = l;
// Adjust last length count to fill out codes, if needed
for (y = 1 << j; j < i; j++, y <<= 1) {
if ((y -= c[j]) < 0) {
return Z_DATA_ERROR;
}
}
if ((y -= c[i]) < 0) {
return Z_DATA_ERROR;
}
c[i] += y;
// Generate starting offsets into the value table for each length
x[1] = j = 0;
p = 1;
xp = 2;
while (--i !== 0) { // note that i == g from above
x[xp] = (j += c[p]);
xp++;
p++;
}
// Make a table of values in order of bit lengths
i = 0;
p = 0;
do {
if ((j = b[bindex + p]) !== 0) {
v[x[j]++] = i;
}
p++;
} while (++i < n);
n = x[g]; // set n to length of v
// Generate the Huffman codes and for each, make the table entries
x[0] = i = 0; // first Huffman code is zero
p = 0; // grab values in bit order
h = -1; // no tables yet--level -1
w = -l; // bits decoded == (l * h)
u[0] = 0; // just to keep compilers happy
q = 0; // ditto
z = 0; // ditto
// go through the bit lengths (k already is bits in shortest code)
for (; k <= g; k++) {
a = c[k];
while (a-- !== 0) {
// here i is the Huffman code of length k bits for value *p
// make tables up to required level
while (k > w + l) {
h++;
w += l; // previous table always l bits
// compute minimum size table less than or equal to l bits
z = g - w;
z = (z > l) ? l : z; // table size upper limit
if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
// too few codes for
// k-w bit table
f -= a + 1; // deduct codes from patterns left
xp = k;
if (j < z) {
while (++j < z) { // try smaller tables up to z bits
if ((f <<= 1) <= c[++xp])
break; // enough codes to use up j bits
f -= c[xp]; // else deduct codes from patterns
}
}
}
z = 1 << j; // table entries for j-bit table
// allocate new table
if (hn[0] + z > MANY) { // (note: doesn't matter for fixed)
return Z_DATA_ERROR; // overflow of MANY
}
u[h] = q = /* hp+ */hn[0]; // DEBUG
hn[0] += z;
// connect to last table, if there is one
if (h !== 0) {
x[h] = i; // save pattern for backing up
r[0] = /* (byte) */j; // bits in this table
r[1] = /* (byte) */l; // bits to dump before this table
j = i >>> (w - l);
r[2] = /* (int) */(q - u[h - 1] - j); // offset to this table
hp.set(r, (u[h - 1] + j) * 3);
// to
// last
// table
} else {
t[0] = q; // first table is returned result
}
}
// set up table entry in r
r[1] = /* (byte) */(k - w);
if (p >= n) {
r[0] = 128 + 64; // out of values--invalid code
} else if (v[p] < s) {
r[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is
// end-of-block
r[2] = v[p++]; // simple code is just the value
} else {
r[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look
// up in lists
r[2] = d[v[p++] - s];
}
// fill code-like entries with r
f = 1 << (k - w);
for (j = i >>> w; j < z; j += f) {
hp.set(r, (q + j) * 3);
}
// backwards increment the k-bit code i
for (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {
i ^= j;
}
i ^= j;
// backup over finished tables
mask = (1 << w) - 1; // needed on HP, cc -O bug
while ((i & mask) != x[h]) {
h--; // don't need to update q
w -= l;
mask = (1 << w) - 1;
}
}
}
// Return Z_BUF_ERROR if we were given an incomplete table
return y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}
function initWorkArea(vsize) {
var i;
if (!hn) {
hn = []; // []; //new Array(1);
v = []; // new Array(vsize);
c = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
r = []; // new Array(3);
u = new Int32Array(BMAX); // new Array(BMAX);
x = new Int32Array(BMAX + 1); // new Array(BMAX + 1);
}
if (v.length < vsize) {
v = []; // new Array(vsize);
}
for (i = 0; i < vsize; i++) {
v[i] = 0;
}
for (i = 0; i < BMAX + 1; i++) {
c[i] = 0;
}
for (i = 0; i < 3; i++) {
r[i] = 0;
}
// for(int i=0; i<BMAX; i++){u[i]=0;}
u.set(c.subarray(0, BMAX), 0);
// for(int i=0; i<BMAX+1; i++){x[i]=0;}
x.set(c.subarray(0, BMAX + 1), 0);
}
that.inflate_trees_bits = function(c, // 19 code lengths
bb, // bits tree desired/actual depth
tb, // bits tree result
hp, // space for trees
z // for messages
) {
var result;
initWorkArea(19);
hn[0] = 0;
result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);
if (result == Z_DATA_ERROR) {
z.msg = "oversubscribed dynamic bit lengths tree";
} else if (result == Z_BUF_ERROR || bb[0] === 0) {
z.msg = "incomplete dynamic bit lengths tree";
result = Z_DATA_ERROR;
}
return result;
};
that.inflate_trees_dynamic = function(nl, // number of literal/length codes
nd, // number of distance codes
c, // that many (total) code lengths
bl, // literal desired/actual bit depth
bd, // distance desired/actual bit depth
tl, // literal/length tree result
td, // distance tree result
hp, // space for trees
z // for messages
) {
var result;
// build literal/length tree
initWorkArea(288);
hn[0] = 0;
result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
if (result != Z_OK || bl[0] === 0) {
if (result == Z_DATA_ERROR) {
z.msg = "oversubscribed literal/length tree";
} else if (result != Z_MEM_ERROR) {
z.msg = "incomplete literal/length tree";
result = Z_DATA_ERROR;
}
return result;
}
// build distance tree
initWorkArea(288);
result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
if (result != Z_OK || (bd[0] === 0 && nl > 257)) {
if (result == Z_DATA_ERROR) {
z.msg = "oversubscribed distance tree";
} else if (result == Z_BUF_ERROR) {
z.msg = "incomplete distance tree";
result = Z_DATA_ERROR;
} else if (result != Z_MEM_ERROR) {
z.msg = "empty distance tree with lengths";
result = Z_DATA_ERROR;
}
return result;
}
return Z_OK;
};
}
InfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth
bd, // distance desired/actual bit depth
tl,// literal/length tree result
td// distance tree result
) {
bl[0] = fixed_bl;
bd[0] = fixed_bd;
tl[0] = fixed_tl;
td[0] = fixed_td;
return Z_OK;
};
// InfCodes
// waiting for "i:"=input,
// "o:"=output,
// "x:"=nothing
var START = 0; // x: set up for LEN
var LEN = 1; // i: get length/literal/eob next
var LENEXT = 2; // i: getting length extra (have base)
var DIST = 3; // i: get distance next
var DISTEXT = 4;// i: getting distance extra
var COPY = 5; // o: copying bytes in window, waiting
// for space
var LIT = 6; // o: got literal, waiting for output
// space
var WASH = 7; // o: got eob, possibly still output
// waiting
var END = 8; // x: got eob and all data flushed
var BADCODE = 9;// x: got error
function InfCodes() {
var that = this;
var mode; // current inflate_codes mode
// mode dependent information
var len = 0;
var tree; // pointer into tree
var tree_index = 0;
var need = 0; // bits needed
var lit = 0;
// if EXT or COPY, where and how much
var get = 0; // bits to get for extra
var dist = 0; // distance back to copy from
var lbits = 0; // ltree bits decoded per branch
var dbits = 0; // dtree bits decoder per branch
var ltree; // literal/length/eob tree
var ltree_index = 0; // literal/length/eob tree
var dtree; // distance tree
var dtree_index = 0; // distance tree
// Called with number of bytes left to write in window at least 258
// (the maximum string length) and number of input bytes available
// at least ten. The ten bytes are six bytes for the longest length/
// distance pair plus four bytes for overloading the bit buffer.
function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
var t; // temporary pointer
var tp; // temporary pointer
var tp_index; // temporary pointer
var e; // extra bits or operation
var b; // bit buffer
var k; // bits in bit buffer
var p; // input data pointer
var n; // bytes available there
var q; // output window write pointer
var m; // bytes to end of window or read pointer
var ml; // mask for literal/length tree
var md; // mask for distance tree
var c; // bytes to copy
var d; // distance back to copy from
var r; // copy source pointer
var tp_index_t_3; // (tp_index+t)*3
// load input, output, bit values
p = z.next_in_index;
n = z.avail_in;
b = s.bitb;
k = s.bitk;
q = s.write;
m = q < s.read ? s.read - q - 1 : s.end - q;
// initialize masks
ml = inflate_mask[bl];
md = inflate_mask[bd];
// do until not enough input or output space for fast loop
do { // assume called with m >= 258 && n >= 10
// get literal/length code
while (k < (20)) { // max bits for literal/length code
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
t = b & ml;
tp = tl;
tp_index = tl_index;
tp_index_t_3 = (tp_index + t) * 3;
if ((e = tp[tp_index_t_3]) === 0) {
b >>= (tp[tp_index_t_3 + 1]);
k -= (tp[tp_index_t_3 + 1]);
s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];
m--;
continue;
}
do {
b >>= (tp[tp_index_t_3 + 1]);
k -= (tp[tp_index_t_3 + 1]);
if ((e & 16) !== 0) {
e &= 15;
c = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);
b >>= e;
k -= e;
// decode distance base of block to copy
while (k < (15)) { // max bits for distance code
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
t = b & md;
tp = td;
tp_index = td_index;
tp_index_t_3 = (tp_index + t) * 3;
e = tp[tp_index_t_3];
do {
b >>= (tp[tp_index_t_3 + 1]);
k -= (tp[tp_index_t_3 + 1]);
if ((e & 16) !== 0) {
// get extra bits to add to distance base
e &= 15;
while (k < (e)) { // get extra bits (up to 13)
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
b >>= (e);
k -= (e);
// do the copy
m -= c;
if (q >= d) { // offset before dest
// just copy
r = q - d;
if (q - r > 0 && 2 > (q - r)) {
s.window[q++] = s.window[r++]; // minimum
// count is
// three,
s.window[q++] = s.window[r++]; // so unroll
// loop a
// little
c -= 2;
} else {
s.window.set(s.window.subarray(r, r + 2), q);
q += 2;
r += 2;
c -= 2;
}
} else { // else offset after destination
r = q - d;
do {
r += s.end; // force pointer in window
} while (r < 0); // covers invalid distances
e = s.end - r;
if (c > e) { // if source crosses,
c -= e; // wrapped copy
if (q - r > 0 && e > (q - r)) {
do {
s.window[q++] = s.window[r++];
} while (--e !== 0);
} else {
s.window.set(s.window.subarray(r, r + e), q);
q += e;
r += e;
e = 0;
}
r = 0; // copy rest from start of window
}
}
// copy all or what's left
if (q - r > 0 && c > (q - r)) {
do {
s.window[q++] = s.window[r++];
} while (--c !== 0);
} else {
s.window.set(s.window.subarray(r, r + c), q);
q += c;
r += c;
c = 0;
}
break;
} else if ((e & 64) === 0) {
t += tp[tp_index_t_3 + 2];
t += (b & inflate_mask[e]);
tp_index_t_3 = (tp_index + t) * 3;
e = tp[tp_index_t_3];
} else {
z.msg = "invalid distance code";
c = z.avail_in - n;
c = (k >> 3) < c ? k >> 3 : c;
n += c;
p -= c;
k -= c << 3;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return Z_DATA_ERROR;
}
} while (true);
break;
}
if ((e & 64) === 0) {
t += tp[tp_index_t_3 + 2];
t += (b & inflate_mask[e]);
tp_index_t_3 = (tp_index + t) * 3;
if ((e = tp[tp_index_t_3]) === 0) {
b >>= (tp[tp_index_t_3 + 1]);
k -= (tp[tp_index_t_3 + 1]);
s.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];
m--;
break;
}
} else if ((e & 32) !== 0) {
c = z.avail_in - n;
c = (k >> 3) < c ? k >> 3 : c;
n += c;
p -= c;
k -= c << 3;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return Z_STREAM_END;
} else {
z.msg = "invalid literal/length code";
c = z.avail_in - n;
c = (k >> 3) < c ? k >> 3 : c;
n += c;
p -= c;
k -= c << 3;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return Z_DATA_ERROR;
}
} while (true);
} while (m >= 258 && n >= 10);
// not enough input or output--restore pointers and return
c = z.avail_in - n;
c = (k >> 3) < c ? k >> 3 : c;
n += c;
p -= c;
k -= c << 3;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return Z_OK;
}
that.init = function(bl, bd, tl, tl_index, td, td_index) {
mode = START;
lbits = /* (byte) */bl;
dbits = /* (byte) */bd;
ltree = tl;
ltree_index = tl_index;
dtree = td;
dtree_index = td_index;
tree = null;
};
that.proc = function(s, z, r) {
var j; // temporary storage
var tindex; // temporary pointer
var e; // extra bits or operation
var b = 0; // bit buffer
var k = 0; // bits in bit buffer
var p = 0; // input data pointer
var n; // bytes available there
var q; // output window write pointer
var m; // bytes to end of window or read pointer
var f; // pointer to copy strings from
// copy input/output information to locals (UPDATE macro restores)
p = z.next_in_index;
n = z.avail_in;
b = s.bitb;
k = s.bitk;
q = s.write;
m = q < s.read ? s.read - q - 1 : s.end - q;
// process input and output based on current state
while (true) {
switch (mode) {
// waiting for "i:"=input, "o:"=output, "x:"=nothing
case START: // x: set up for LEN
if (m >= 258 && n >= 10) {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
p = z.next_in_index;
n = z.avail_in;
b = s.bitb;
k = s.bitk;
q = s.write;
m = q < s.read ? s.read - q - 1 : s.end - q;
if (r != Z_OK) {
mode = r == Z_STREAM_END ? WASH : BADCODE;
break;
}
}
need = lbits;
tree = ltree;
tree_index = ltree_index;
mode = LEN;
/* falls through */
case LEN: // i: get length/literal/eob next
j = need;
while (k < (j)) {
if (n !== 0)
r = Z_OK;
else {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
tindex = (tree_index + (b & inflate_mask[j])) * 3;
b >>>= (tree[tindex + 1]);
k -= (tree[tindex + 1]);
e = tree[tindex];
if (e === 0) { // literal
lit = tree[tindex + 2];
mode = LIT;
break;
}
if ((e & 16) !== 0) { // length
get = e & 15;
len = tree[tindex + 2];
mode = LENEXT;
break;
}
if ((e & 64) === 0) { // next table
need = e;
tree_index = tindex / 3 + tree[tindex + 2];
break;
}
if ((e & 32) !== 0) { // end of block
mode = WASH;
break;
}
mode = BADCODE; // invalid code
z.msg = "invalid literal/length code";
r = Z_DATA_ERROR;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
case LENEXT: // i: getting length extra (have base)
j = get;
while (k < (j)) {
if (n !== 0)
r = Z_OK;
else {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
len += (b & inflate_mask[j]);
b >>= j;
k -= j;
need = dbits;
tree = dtree;
tree_index = dtree_index;
mode = DIST;
/* falls through */
case DIST: // i: get distance next
j = need;
while (k < (j)) {
if (n !== 0)
r = Z_OK;
else {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
tindex = (tree_index + (b & inflate_mask[j])) * 3;
b >>= tree[tindex + 1];
k -= tree[tindex + 1];
e = (tree[tindex]);
if ((e & 16) !== 0) { // distance
get = e & 15;
dist = tree[tindex + 2];
mode = DISTEXT;
break;
}
if ((e & 64) === 0) { // next table
need = e;
tree_index = tindex / 3 + tree[tindex + 2];
break;
}
mode = BADCODE; // invalid code
z.msg = "invalid distance code";
r = Z_DATA_ERROR;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
case DISTEXT: // i: getting distance extra
j = get;
while (k < (j)) {
if (n !== 0)
r = Z_OK;
else {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
dist += (b & inflate_mask[j]);
b >>= j;
k -= j;
mode = COPY;
/* falls through */
case COPY: // o: copying bytes in window, waiting for space
f = q - dist;
while (f < 0) { // modulo window size-"while" instead
f += s.end; // of "if" handles invalid distances
}
while (len !== 0) {
if (m === 0) {
if (q == s.end && s.read !== 0) {
q = 0;
m = q < s.read ? s.read - q - 1 : s.end - q;
}
if (m === 0) {
s.write = q;
r = s.inflate_flush(z, r);
q = s.write;
m = q < s.read ? s.read - q - 1 : s.end - q;
if (q == s.end && s.read !== 0) {
q = 0;
m = q < s.read ? s.read - q - 1 : s.end - q;
}
if (m === 0) {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
}
}
s.window[q++] = s.window[f++];
m--;
if (f == s.end)
f = 0;
len--;
}
mode = START;
break;
case LIT: // o: got literal, waiting for output space
if (m === 0) {
if (q == s.end && s.read !== 0) {
q = 0;
m = q < s.read ? s.read - q - 1 : s.end - q;
}
if (m === 0) {
s.write = q;
r = s.inflate_flush(z, r);
q = s.write;
m = q < s.read ? s.read - q - 1 : s.end - q;
if (q == s.end && s.read !== 0) {
q = 0;
m = q < s.read ? s.read - q - 1 : s.end - q;
}
if (m === 0) {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
}
}
r = Z_OK;
s.window[q++] = /* (byte) */lit;
m--;
mode = START;
break;
case WASH: // o: got eob, possibly more output
if (k > 7) { // return unused byte, if any
k -= 8;
n++;
p--; // can always return one
}
s.write = q;
r = s.inflate_flush(z, r);
q = s.write;
m = q < s.read ? s.read - q - 1 : s.end - q;
if (s.read != s.write) {
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
mode = END;
/* falls through */
case END:
r = Z_STREAM_END;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
case BADCODE: // x: got error
r = Z_DATA_ERROR;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
default:
r = Z_STREAM_ERROR;
s.bitb = b;
s.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
s.write = q;
return s.inflate_flush(z, r);
}
}
};
that.free = function() {
// ZFREE(z, c);
};
}
// InfBlocks
// Table for deflate from PKZIP's appnote.txt.
var border = [ // Order of the bit length code lengths
16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
var TYPE = 0; // get type bits (3, including end bit)
var LENS = 1; // get lengths for stored
var STORED = 2;// processing stored block
var TABLE = 3; // get table lengths
var BTREE = 4; // get bit lengths tree for a dynamic
// block
var DTREE = 5; // get length, distance trees for a
// dynamic block
var CODES = 6; // processing fixed or dynamic block
var DRY = 7; // output remaining window bytes
var DONELOCKS = 8; // finished last block, done
var BADBLOCKS = 9; // ot a data error--stuck here
function InfBlocks(z, w) {
var that = this;
var mode = TYPE; // current inflate_block mode
var left = 0; // if STORED, bytes left to copy
var table = 0; // table lengths (14 bits)
var index = 0; // index into blens (or border)
var blens; // bit lengths of codes
var bb = [ 0 ]; // bit length tree depth
var tb = [ 0 ]; // bit length decoding tree
var codes = new InfCodes(); // if CODES, current state
var last = 0; // true if this block is the last block
var hufts = new Int32Array(MANY * 3); // single malloc for tree space
var check = 0; // check on output
var inftree = new InfTree();
that.bitk = 0; // bits in bit buffer
that.bitb = 0; // bit buffer
that.window = new Uint8Array(w); // sliding window
that.end = w; // one byte after sliding window
that.read = 0; // window read pointer
that.write = 0; // window write pointer
that.reset = function(z, c) {
if (c)
c[0] = check;
// if (mode == BTREE || mode == DTREE) {
// }
if (mode == CODES) {
codes.free(z);
}
mode = TYPE;
that.bitk = 0;
that.bitb = 0;
that.read = that.write = 0;
};
that.reset(z, null);
// copy as much as possible from the sliding window to the output area
that.inflate_flush = function(z, r) {
var n;
var p;
var q;
// local copies of source and destination pointers
p = z.next_out_index;
q = that.read;
// compute number of bytes to copy as far as end of window
n = /* (int) */((q <= that.write ? that.write : that.end) - q);
if (n > z.avail_out)
n = z.avail_out;
if (n !== 0 && r == Z_BUF_ERROR)
r = Z_OK;
// update counters
z.avail_out -= n;
z.total_out += n;
// copy as far as end of window
z.next_out.set(that.window.subarray(q, q + n), p);
p += n;
q += n;
// see if more to copy at beginning of window
if (q == that.end) {
// wrap pointers
q = 0;
if (that.write == that.end)
that.write = 0;
// compute bytes to copy
n = that.write - q;
if (n > z.avail_out)
n = z.avail_out;
if (n !== 0 && r == Z_BUF_ERROR)
r = Z_OK;
// update counters
z.avail_out -= n;
z.total_out += n;
// copy
z.next_out.set(that.window.subarray(q, q + n), p);
p += n;
q += n;
}
// update pointers
z.next_out_index = p;
that.read = q;
// done
return r;
};
that.proc = function(z, r) {
var t; // temporary storage
var b; // bit buffer
var k; // bits in bit buffer
var p; // input data pointer
var n; // bytes available there
var q; // output window write pointer
var m; // bytes to end of window or read pointer
var i;
// copy input/output information to locals (UPDATE macro restores)
// {
p = z.next_in_index;
n = z.avail_in;
b = that.bitb;
k = that.bitk;
// }
// {
q = that.write;
m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
// }
// process input based on current state
// DEBUG dtree
while (true) {
switch (mode) {
case TYPE:
while (k < (3)) {
if (n !== 0) {
r = Z_OK;
} else {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
t = /* (int) */(b & 7);
last = t & 1;
switch (t >>> 1) {
case 0: // stored
// {
b >>>= (3);
k -= (3);
// }
t = k & 7; // go to byte boundary
// {
b >>>= (t);
k -= (t);
// }
mode = LENS; // get length of stored block
break;
case 1: // fixed
// {
var bl = []; // new Array(1);
var bd = []; // new Array(1);
var tl = [ [] ]; // new Array(1);
var td = [ [] ]; // new Array(1);
InfTree.inflate_trees_fixed(bl, bd, tl, td);
codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
// }
// {
b >>>= (3);
k -= (3);
// }
mode = CODES;
break;
case 2: // dynamic
// {
b >>>= (3);
k -= (3);
// }
mode = TABLE;
break;
case 3: // illegal
// {
b >>>= (3);
k -= (3);
// }
mode = BADBLOCKS;
z.msg = "invalid block type";
r = Z_DATA_ERROR;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
break;
case LENS:
while (k < (32)) {
if (n !== 0) {
r = Z_OK;
} else {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {
mode = BADBLOCKS;
z.msg = "invalid stored block lengths";
r = Z_DATA_ERROR;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
left = (b & 0xffff);
b = k = 0; // dump bits
mode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);
break;
case STORED:
if (n === 0) {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
if (m === 0) {
if (q == that.end && that.read !== 0) {
q = 0;
m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
}
if (m === 0) {
that.write = q;
r = that.inflate_flush(z, r);
q = that.write;
m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
if (q == that.end && that.read !== 0) {
q = 0;
m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
}
if (m === 0) {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
}
}
r = Z_OK;
t = left;
if (t > n)
t = n;
if (t > m)
t = m;
that.window.set(z.read_buf(p, t), q);
p += t;
n -= t;
q += t;
m -= t;
if ((left -= t) !== 0)
break;
mode = last !== 0 ? DRY : TYPE;
break;
case TABLE:
while (k < (14)) {
if (n !== 0) {
r = Z_OK;
} else {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
table = t = (b & 0x3fff);
if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {
mode = BADBLOCKS;
z.msg = "too many length or distance symbols";
r = Z_DATA_ERROR;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
if (!blens || blens.length < t) {
blens = []; // new Array(t);
} else {
for (i = 0; i < t; i++) {
blens[i] = 0;
}
}
// {
b >>>= (14);
k -= (14);
// }
index = 0;
mode = BTREE;
/* falls through */
case BTREE:
while (index < 4 + (table >>> 10)) {
while (k < (3)) {
if (n !== 0) {
r = Z_OK;
} else {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
blens[border[index++]] = b & 7;
// {
b >>>= (3);
k -= (3);
// }
}
while (index < 19) {
blens[border[index++]] = 0;
}
bb[0] = 7;
t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
if (t != Z_OK) {
r = t;
if (r == Z_DATA_ERROR) {
blens = null;
mode = BADBLOCKS;
}
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
index = 0;
mode = DTREE;
/* falls through */
case DTREE:
while (true) {
t = table;
if (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {
break;
}
var j, c;
t = bb[0];
while (k < (t)) {
if (n !== 0) {
r = Z_OK;
} else {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
// if (tb[0] == -1) {
// System.err.println("null...");
// }
t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];
if (c < 16) {
b >>>= (t);
k -= (t);
blens[index++] = c;
} else { // c == 16..18
i = c == 18 ? 7 : c - 14;
j = c == 18 ? 11 : 3;
while (k < (t + i)) {
if (n !== 0) {
r = Z_OK;
} else {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
n--;
b |= (z.read_byte(p++) & 0xff) << k;
k += 8;
}
b >>>= (t);
k -= (t);
j += (b & inflate_mask[i]);
b >>>= (i);
k -= (i);
i = index;
t = table;
if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {
blens = null;
mode = BADBLOCKS;
z.msg = "invalid bit length repeat";
r = Z_DATA_ERROR;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
c = c == 16 ? blens[i - 1] : 0;
do {
blens[i++] = c;
} while (--j !== 0);
index = i;
}
}
tb[0] = -1;
// {
var bl_ = []; // new Array(1);
var bd_ = []; // new Array(1);
var tl_ = []; // new Array(1);
var td_ = []; // new Array(1);
bl_[0] = 9; // must be <= 9 for lookahead assumptions
bd_[0] = 6; // must be <= 9 for lookahead assumptions
t = table;
t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);
if (t != Z_OK) {
if (t == Z_DATA_ERROR) {
blens = null;
mode = BADBLOCKS;
}
r = t;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
// }
mode = CODES;
/* falls through */
case CODES:
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
if ((r = codes.proc(that, z, r)) != Z_STREAM_END) {
return that.inflate_flush(z, r);
}
r = Z_OK;
codes.free(z);
p = z.next_in_index;
n = z.avail_in;
b = that.bitb;
k = that.bitk;
q = that.write;
m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
if (last === 0) {
mode = TYPE;
break;
}
mode = DRY;
/* falls through */
case DRY:
that.write = q;
r = that.inflate_flush(z, r);
q = that.write;
m = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);
if (that.read != that.write) {
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
mode = DONELOCKS;
/* falls through */
case DONELOCKS:
r = Z_STREAM_END;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
case BADBLOCKS:
r = Z_DATA_ERROR;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
default:
r = Z_STREAM_ERROR;
that.bitb = b;
that.bitk = k;
z.avail_in = n;
z.total_in += p - z.next_in_index;
z.next_in_index = p;
that.write = q;
return that.inflate_flush(z, r);
}
}
};
that.free = function(z) {
that.reset(z, null);
that.window = null;
hufts = null;
// ZFREE(z, s);
};
that.set_dictionary = function(d, start, n) {
that.window.set(d.subarray(start, start + n), 0);
that.read = that.write = n;
};
// Returns true if inflate is currently at the end of a block generated
// by Z_SYNC_FLUSH or Z_FULL_FLUSH.
that.sync_point = function() {
return mode == LENS ? 1 : 0;
};
}
// Inflate
// preset dictionary flag in zlib header
var PRESET_DICT = 0x20;
var Z_DEFLATED = 8;
var METHOD = 0; // waiting for method byte
var FLAG = 1; // waiting for flag byte
var DICT4 = 2; // four dictionary check bytes to go
var DICT3 = 3; // three dictionary check bytes to go
var DICT2 = 4; // two dictionary check bytes to go
var DICT1 = 5; // one dictionary check byte to go
var DICT0 = 6; // waiting for inflateSetDictionary
var BLOCKS = 7; // decompressing blocks
var DONE = 12; // finished check, done
var BAD = 13; // got an error--stay here
var mark = [ 0, 0, 0xff, 0xff ];
function Inflate() {
var that = this;
that.mode = 0; // current inflate mode
// mode dependent information
that.method = 0; // if FLAGS, method byte
// if CHECK, check values to compare
that.was = [ 0 ]; // new Array(1); // computed check value
that.need = 0; // stream check value
// if BAD, inflateSync's marker bytes count
that.marker = 0;
// mode independent information
that.wbits = 0; // log2(window size) (8..15, defaults to 15)
// this.blocks; // current inflate_blocks state
function inflateReset(z) {
if (!z || !z.istate)
return Z_STREAM_ERROR;
z.total_in = z.total_out = 0;
z.msg = null;
z.istate.mode = BLOCKS;
z.istate.blocks.reset(z, null);
return Z_OK;
}
that.inflateEnd = function(z) {
if (that.blocks)
that.blocks.free(z);
that.blocks = null;
// ZFREE(z, z->state);
return Z_OK;
};
that.inflateInit = function(z, w) {
z.msg = null;
that.blocks = null;
// set window size
if (w < 8 || w > 15) {
that.inflateEnd(z);
return Z_STREAM_ERROR;
}
that.wbits = w;
z.istate.blocks = new InfBlocks(z, 1 << w);
// reset state
inflateReset(z);
return Z_OK;
};
that.inflate = function(z, f) {
var r;
var b;
if (!z || !z.istate || !z.next_in)
return Z_STREAM_ERROR;
f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
r = Z_BUF_ERROR;
while (true) {
// System.out.println("mode: "+z.istate.mode);
switch (z.istate.mode) {
case METHOD:
if (z.avail_in === 0)
return r;
r = f;
z.avail_in--;
z.total_in++;
if (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {
z.istate.mode = BAD;
z.msg = "unknown compression method";
z.istate.marker = 5; // can't try inflateSync
break;
}
if ((z.istate.method >> 4) + 8 > z.istate.wbits) {
z.istate.mode = BAD;
z.msg = "invalid window size";
z.istate.marker = 5; // can't try inflateSync
break;
}
z.istate.mode = FLAG;
/* falls through */
case FLAG:
if (z.avail_in === 0)
return r;
r = f;
z.avail_in--;
z.total_in++;
b = (z.read_byte(z.next_in_index++)) & 0xff;
if ((((z.istate.method << 8) + b) % 31) !== 0) {
z.istate.mode = BAD;
z.msg = "incorrect header check";
z.istate.marker = 5; // can't try inflateSync
break;
}
if ((b & PRESET_DICT) === 0) {
z.istate.mode = BLOCKS;
break;
}
z.istate.mode = DICT4;
/* falls through */
case DICT4:
if (z.avail_in === 0)
return r;
r = f;
z.avail_in--;
z.total_in++;
z.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;
z.istate.mode = DICT3;
/* falls through */
case DICT3:
if (z.avail_in === 0)
return r;
r = f;
z.avail_in--;
z.total_in++;
z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;
z.istate.mode = DICT2;
/* falls through */
case DICT2:
if (z.avail_in === 0)
return r;
r = f;
z.avail_in--;
z.total_in++;
z.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;
z.istate.mode = DICT1;
/* falls through */
case DICT1:
if (z.avail_in === 0)
return r;
r = f;
z.avail_in--;
z.total_in++;
z.istate.need += (z.read_byte(z.next_in_index++) & 0xff);
z.istate.mode = DICT0;
return Z_NEED_DICT;
case DICT0:
z.istate.mode = BAD;
z.msg = "need dictionary";
z.istate.marker = 0; // can try inflateSync
return Z_STREAM_ERROR;
case BLOCKS:
r = z.istate.blocks.proc(z, r);
if (r == Z_DATA_ERROR) {
z.istate.mode = BAD;
z.istate.marker = 0; // can try inflateSync
break;
}
if (r == Z_OK) {
r = f;
}
if (r != Z_STREAM_END) {
return r;
}
r = f;
z.istate.blocks.reset(z, z.istate.was);
z.istate.mode = DONE;
/* falls through */
case DONE:
return Z_STREAM_END;
case BAD:
return Z_DATA_ERROR;
default:
return Z_STREAM_ERROR;
}
}
};
that.inflateSetDictionary = function(z, dictionary, dictLength) {
var index = 0;
var length = dictLength;
if (!z || !z.istate || z.istate.mode != DICT0)
return Z_STREAM_ERROR;
if (length >= (1 << z.istate.wbits)) {
length = (1 << z.istate.wbits) - 1;
index = dictLength - length;
}
z.istate.blocks.set_dictionary(dictionary, index, length);
z.istate.mode = BLOCKS;
return Z_OK;
};
that.inflateSync = function(z) {
var n; // number of bytes to look at
var p; // pointer to bytes
var m; // number of marker bytes found in a row
var r, w; // temporaries to save total_in and total_out
// set up
if (!z || !z.istate)
return Z_STREAM_ERROR;
if (z.istate.mode != BAD) {
z.istate.mode = BAD;
z.istate.marker = 0;
}
if ((n = z.avail_in) === 0)
return Z_BUF_ERROR;
p = z.next_in_index;
m = z.istate.marker;
// search
while (n !== 0 && m < 4) {
if (z.read_byte(p) == mark[m]) {
m++;
} else if (z.read_byte(p) !== 0) {
m = 0;
} else {
m = 4 - m;
}
p++;
n--;
}
// restore
z.total_in += p - z.next_in_index;
z.next_in_index = p;
z.avail_in = n;
z.istate.marker = m;
// return no joy or set up to restart on a new block
if (m != 4) {
return Z_DATA_ERROR;
}
r = z.total_in;
w = z.total_out;
inflateReset(z);
z.total_in = r;
z.total_out = w;
z.istate.mode = BLOCKS;
return Z_OK;
};
// Returns true if inflate is currently at the end of a block generated
// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
// implementation to provide an additional safety check. PPP uses
// Z_SYNC_FLUSH
// but removes the length bytes of the resulting empty stored block. When
// decompressing, PPP checks that at the end of input packet, inflate is
// waiting for these length bytes.
that.inflateSyncPoint = function(z) {
if (!z || !z.istate || !z.istate.blocks)
return Z_STREAM_ERROR;
return z.istate.blocks.sync_point();
};
}
// ZStream
function ZStream() {
}
ZStream.prototype = {
inflateInit : function(bits) {
var that = this;
that.istate = new Inflate();
if (!bits)
bits = MAX_BITS;
return that.istate.inflateInit(that, bits);
},
inflate : function(f) {
var that = this;
if (!that.istate)
return Z_STREAM_ERROR;
return that.istate.inflate(that, f);
},
inflateEnd : function() {
var that = this;
if (!that.istate)
return Z_STREAM_ERROR;
var ret = that.istate.inflateEnd(that);
that.istate = null;
return ret;
},
inflateSync : function() {
var that = this;
if (!that.istate)
return Z_STREAM_ERROR;
return that.istate.inflateSync(that);
},
inflateSetDictionary : function(dictionary, dictLength) {
var that = this;
if (!that.istate)
return Z_STREAM_ERROR;
return that.istate.inflateSetDictionary(that, dictionary, dictLength);
},
read_byte : function(start) {
var that = this;
return that.next_in.subarray(start, start + 1)[0];
},
read_buf : function(start, size) {
var that = this;
return that.next_in.subarray(start, start + size);
}
};
// Inflater
function Inflater() {
var that = this;
var z = new ZStream();
var bufsize = 512;
var flush = Z_NO_FLUSH;
var buf = new Uint8Array(bufsize);
var nomoreinput = false;
z.inflateInit();
z.next_out = buf;
that.append = function(data, onprogress) {
var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;
if (data.length === 0)
return;
z.next_in_index = 0;
z.next_in = data;
z.avail_in = data.length;
do {
z.next_out_index = 0;
z.avail_out = bufsize;
if ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it
z.next_in_index = 0;
nomoreinput = true;
}
err = z.inflate(flush);
if (nomoreinput && (err === Z_BUF_ERROR)) {
if (z.avail_in !== 0)
throw new Error("inflating: bad input");
} else if (err !== Z_OK && err !== Z_STREAM_END)
throw new Error("inflating: " + z.msg);
if ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))
throw new Error("inflating: bad input");
if (z.next_out_index)
if (z.next_out_index === bufsize)
buffers.push(new Uint8Array(buf));
else
buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));
bufferSize += z.next_out_index;
if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
onprogress(z.next_in_index);
lastIndex = z.next_in_index;
}
} while (z.avail_in > 0 || z.avail_out === 0);
array = new Uint8Array(bufferSize);
buffers.forEach(function(chunk) {
array.set(chunk, bufferIndex);
bufferIndex += chunk.length;
});
return array;
};
that.flush = function() {
z.inflateEnd();
};
}
// 'zip' may not be defined in z-worker and some tests
var env = global.zip || global;
env.Inflater = env._jzlib_Inflater = Inflater;
})(this);
//-------- js/CWAEnv.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CWAEnv;
CWAEnv = (function() {
function CWAEnv() {
throw "CWAEnv is not instantiatable.";
}
CWAEnv.add = function(cls, cname) {
return this[cname] = cls;
};
CWAEnv.get = function(cname) {
return this[cname];
};
CWAEnv.fixRef = function(aname, bname) {
return this[aname]["set" + bname](this[bname]);
};
return CWAEnv;
})();
this.getCWAEnv = function() {
return CWAEnv;
};
}).call(this);
//-------- js/SToCAObj.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var SToCAObj, alert, console, cwaenv, document, log, navigator, setTimeout, status, theSToCA,
bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
navigator = this.navigator;
status = this.status;
alert = this.alert;
log = console.log.bind(console);
SToCAObj = (function() {
function SToCAObj() {
this.stat = bind(this.stat, this);
this.RETURN_CHAR = 13;
this.sLimit = 0;
this.fLimit = 0;
this.sign = -1;
this.gloss = "";
this.signMsg = "";
this.curAvatar = "anna";
this.curFPS = "50";
this.osTag = null;
this.appTag = null;
this.hasJava = false;
this.stocCB = {};
this.stocApplet = null;
this.setEnvTags();
}
SToCAObj.prototype.onWin = function() {
return this.osTag === "win";
};
SToCAObj.prototype.onMac = function() {
return this.osTag === "mac";
};
SToCAObj.prototype.isInSafari = function() {
return this.appTag === "safari";
};
SToCAObj.prototype.isInFirefox = function() {
return this.appTag === "firefox";
};
SToCAObj.prototype.isInChrome = function() {
return this.appTag === "chrome";
};
SToCAObj.prototype.isInIE = function() {
return this.appTag === "ie";
};
SToCAObj.prototype.setEnvTags = function() {
var avlc, ref, ualc;
avlc = navigator.appVersion.toLowerCase();
ualc = navigator.userAgent.toLowerCase();
this.osTag = (avlc.indexOf("win")) !== -1 ? "win" : (avlc.indexOf("mac")) !== -1 ? "mac" : "UNSUPPORTED-OS " + avlc;
this.appTag = (ualc.indexOf("opr")) !== -1 ? "opera" : (ualc.indexOf("chrome")) !== -1 ? "chrome" : (ualc.indexOf("safari")) !== -1 ? "safari" : (ualc.indexOf("firefox")) !== -1 ? "firefox" : (ualc.indexOf("msie")) !== -1 ? "ie" : (ualc.indexOf("trident")) !== -1 ? "ie" : (ualc.indexOf("edge")) !== -1 ? "ie" : "UNRECOGNISED-BROWSER " + ualc;
this.hasJava = (this.onMac() && (((ref = navigator.mimeTypes) != null ? ref["application/x-java-applet"] : void 0) != null)) || (this.onWin() && (navigator != null ? navigator.javaEnabled() : void 0));
return log("Browser Environment:  OS=" + this.osTag + "  Browser=" + this.appTag + "  Java=" + this.hasJava);
};
SToCAObj.prototype.findSToCA = function() {
var ref;
return (ref = document.getElementsByClassName("stocApplet")) != null ? ref[0] : void 0;
};
SToCAObj.prototype.appletLoadIsStable = function() {
var appini, applet;
applet = this.findSToCA();
appini = applet != null ? applet.init : void 0;
log("appletLoadIsStable: applet=" + (typeof applet) + " applet.init=" + (typeof (applet != null ? applet.init : void 0)));
return (typeof applet) !== "undefined" && (((typeof applet.init) !== "undefined") || (this.onWin() && this.isInFirefox()));
};
SToCAObj.prototype.setSToCA = function(stoca, source) {
log("setSToCA() source: " + source);
return this.stocApplet = stoca;
};
SToCAObj.prototype.initialise = function() {
if (!this.osTag) {
this.setEnvTags();
}
this.synchronousInit();
if (this.hasJava && (!(this.isInChrome()) || !(this.onMac()))) {
this.initSToCApplet();
}
return void 0;
};
SToCAObj.prototype.synchronousInit = function() {
this.resetSToCAData();
return this.stat("SToCA: HTML synchronous initialisation done");
};
SToCAObj.prototype.initSToCApplet = function() {
if (this.appletLoadIsStable()) {
return this.setSToCA(this.findSToCA(), "initSToCApplet()");
} else {
return this.asynchGetSToCA();
}
};
SToCAObj.prototype.asynchGetSToCA = function() {
var done, stoca, tryFindSToCA;
stoca = void 0;
tryFindSToCA = (function(_this) {
return function() {
if (_this.appletLoadIsStable()) {
stoca = _this.findSToCA();
return _this.setSToCA(stoca, "asynchGetSToCA()");
}
};
})(this);
done = (function(_this) {
return function() {
return Boolean(stoca);
};
})(this);
return this.asynchRepeat(tryFindSToCA, done, "asynchGetSToCA(): ", 200, 30000);
};
SToCAObj.prototype.terminate = function() {
var ref;
if ((ref = this.getSToCA()) != null) {
ref.terminate();
}
return this.stat("SToCA: SiGML-to-CAS Applet terminated");
};
SToCAObj.prototype.getSToCA = function() {
if (this.stocApplet === null && this.hasJava) {
log("Late attempt to find SToCA ...");
if (this.appletLoadIsStable()) {
this.setSToCA(this.findSToCA(), "getSToCA()");
} else {
log("getSToCA(): catastrophe -- cannot get SToCA!.");
}
}
return this.stocApplet;
};
SToCAObj.prototype.asynchRepeat = function(body, ok, tag, delay, maxdelay) {
var closedARFun, n;
n = 0;
closedARFun = function() {
body();
if (ok()) {
if (tag) {
return log(tag + " completed delay=" + n);
}
} else {
n += delay;
if (n < maxdelay) {
return setTimeout(closedARFun, delay);
} else {
return log(tag + " abandoned delay=" + n);
}
}
};
return closedARFun();
};
SToCAObj.prototype.resetSignData = function() {
this.sLimit = this.fLimit = 0;
this.sign = -1;
this.gloss = "";
return this.signMsg = "";
};
SToCAObj.prototype.resetSToCAData = function() {
this.resetSignData();
this.curAvatar = "anna";
return this.curFPS = "50";
};
SToCAObj.prototype.htmlEls = function(elid) {
return document.getElementsByClassName(elid);
};
SToCAObj.prototype.stat = function(msg) {
var i, len, statels, stel;
log(msg);
statels = this.htmlEls("statusExtra");
for (i = 0, len = statels.length; i < len; i++) {
stel = statels[i];
stel.value = msg;
}
return status = msg;
};
SToCAObj.prototype.framesGenEH = function(ekind, nf, ns) {
var ekinds, msg, prevFLimit;
msg = "No frames generated from URL.";
ekinds = String(ekind);
prevFLimit = -1;
if (ekinds === "LOAD_FRAMES_START") {
this.resetSignData();
msg = "Loading of frames has started.";
} else if (ekinds === "LOADED_NEXT_SIGN") {
prevFLimit = this.fLimit;
this.fLimit = nf;
this.sLimit = ns;
if (prevFLimit === 0 && this.fLimit !== 0) {
this.setButtonsForPlaying();
msg = ns + " sign(s) now ready to play.";
}
} else if (ekinds === "LOAD_FRAMES_DONE_OK") {
prevFLimit = this.fLimit;
this.fLimit = nf;
this.sLimit = ns;
if (this.fLimit === 0) {
this.setButtonsForIdling();
} else if (prevFLimit === 0) {
msg = "Ready to play.";
} else {
msg = "All frames loaded: " + this.sLimit + " signs, " + this.fLimit + " frames.";
}
} else if (ekinds === "LOAD_FRAMES_DONE_BAD") {
} else {
msg = "unknown frames-gen event: " + ekind + ".";
alert(msg);
}
return this.stat(msg);
};
SToCAObj.prototype.setAvatar = function(av) {
return this.curAvatar = String(av);
};
SToCAObj.prototype.setFPS = function(fps) {
return this.curFPS = String(fps);
};
SToCAObj.prototype.doSiGMLURLToCAS = function(rqstid, surl, av, casfmt, cascb) {
var SToCA;
if (surl.length === 0) {
log("Ignoring zero-length SiGML URL.");
return setTimeout((function() {
return cascb(null);
}), 0);
} else {
if (SToCA = this.getSToCA()) {
this.stocCB[rqstid] = cascb;
return SToCA.doSiGMLURLToCAS(rqstid, surl, av, casfmt);
} else {
return this.stat("No SToCA for SiGML URL to CAS");
}
}
};
SToCAObj.prototype.doSiGMLTextToCAS = function(rqstid, stxt, av, casfmt, cascb) {
var SToCA;
if (SToCA = this.getSToCA()) {
this.stocCB[rqstid] = cascb;
return SToCA.doSiGMLTextToCAS(rqstid, stxt, av, casfmt);
} else {
return this.stat("No SToCA for SiGML Text to CAS");
}
};
SToCAObj.prototype.returnCAS = function(rqstid, cas) {
var cascb, err;
cascb = this.stocCB[rqstid];
if (!cascb) {
log("SToCA.returnCAS(), id=" + rqstid + ": call-back is missing.");
} else {
try {
cascb(cas);
} catch (error) {
err = error;
log(err.stack || err.stacktrace || err);
}
}
return void 0;
};
SToCAObj.prototype.setDoneSiGMLToCASRequest = function(rqstid) {
if (this.stocCB[rqstid]) {
return delete this.stocCB[rqstid];
} else {
return log("SToCA.setDoneSiGMLToCASRequest(), id " + rqstid + " is invalid.");
}
};
SToCAObj.prototype.setLogFlag = function(lstr) {
var logstr, ref;
logstr = lstr || "true";
return (ref = this.getSToCA()) != null ? ref.switchLogEnabled(logstr) : void 0;
};
return SToCAObj;
})();
theSToCA = new SToCAObj;
cwaenv.add(theSToCA, "theSToCA");
this.stocaFramesGenEvent = function(ekind, nf, ns) {
return theSToCA.framesGenEH(ekind, nf, ns);
};
this.stocaReturnCAS = function(rqstid, cas) {
return theSToCA.returnCAS(rqstid, cas);
};
this.spaSetSToCApplet = function(spa) {
return log("spaSetSToCApplet called with spa=" + spa);
};
}).call(this);
//-------- js/FourCC.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var FourCC, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = (function() {
var _i2s, _s2i;
function FourCC() {
throw "FourCC cannot be instantiated.";
}
FourCC.fourCCInt = function(str4) {
var cc0, cc1, cc2, cc3, has4, s;
has4 = 4 <= str4.length;
s = has4 ? str4 : str4 + String.fromCharCode(0, 0, 0, 0);
cc0 = s.charCodeAt(0) & 0xFF;
cc1 = s.charCodeAt(1) & 0xFF;
cc2 = s.charCodeAt(2) & 0xFF;
cc3 = s.charCodeAt(3) & 0xFF;
return (((((cc3 << 8) | cc2) << 8) | cc1) << 8) | cc0;
};
FourCC.fourCCStr = function(id4cc) {
var cc0, cc1, cc2, cc3, chs, chvec, i;
chs = id4cc;
cc0 = chs & 0xFF;
chs >>= 8;
cc1 = chs & 0xFF;
chs >>= 8;
cc2 = chs & 0xFF;
chs >>= 8;
cc3 = chs & 0xFF;
if (cc3 !== 0) {
return String.fromCharCode(cc0, cc1, cc2, cc3);
} else {
chvec = [cc0, cc1, cc2, cc3];
i = 0;
while (chvec[i]) {
++i;
}
return String.fromCharCode.apply(null, chvec.slice(0, i));
}
};
_s2i = function(fccs, ix, vec) {
return FourCC.fourCCInt(fccs);
};
_i2s = function(fcci, ix, vec) {
return FourCC.fourCCStr(fcci);
};
FourCC.fourCCStrsToInts = function(fccss) {
return fccss.map(_s2i);
};
FourCC.fourCCIntsToStrs = function(fccis) {
return fccis.map(_i2s);
};
FourCC.fourCCStrPadded = function(id4cc) {
var s;
s = this.fourCCStr(id4cc);
while (s.length !== 4) {
s += " ";
}
return s;
};
return FourCC;
})();
cwaenv.add(FourCC, "FourCC");
}).call(this);
//-------- js/pretty-data-fix.js --------
/**
* pretty-data - nodejs plugin to pretty-print or minify data in XML, JSON and CSS formats.
*  
* Version - 0.40.0
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/pretty-data/
* 
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
*	pd.xml(data ) - pretty print XML;
*	pd.json(data) - pretty print JSON;
*	pd.css(data ) - pretty print CSS;
*	pd.sql(data)  - pretty print SQL;
*
*	pd.xmlmin(data [, preserveComments] ) - minify XML; 
*	pd.jsonmin(data)                      - minify JSON; 
*	pd.cssmin(data [, preserveComments] ) - minify CSS; 
*	pd.sqlmin(data)                       - minify SQL; 
*
* PARAMETERS:
*
*	@data  			- String; XML, JSON, CSS or SQL text to beautify;
* 	@preserveComments	- Bool (optional, used in minxml and mincss only); 
*				  Set this flag to true to prevent removing comments from @text; 
*	@Return 		- String;
*	
* USAGE:
*	
*	var pd  = require('pretty-data').pd;
*
*	var xml_pp   = pd.xml(xml_text);
*	var xml_min  = pd.xmlmin(xml_text [,true]);
*	var json_pp  = pd.json(json_text);
*	var json_min = pd.jsonmin(json_text);
*	var css_pp   = pd.css(css_text);
*	var css_min  = pd.cssmin(css_text [, true]);
*	var sql_pp   = pd.sql(sql_text);
*	var sql_min  = pd.sqlmin(sql_text);
*
* TEST:
*	comp-name:pretty-data$ node ./test/test_xml
*	comp-name:pretty-data$ node ./test/test_json
*	comp-name:pretty-data$ node ./test/test_css
*	comp-name:pretty-data$ node ./test/test_sql
*/
function pp() {
this.shift = ['\n']; // array of shifts
this.step = '  '; // 2 spaces
var maxdeep = 100, // nesting level
ix = 0;
// initialize array with shifts //
for(ix=0;ix<maxdeep;ix++){
this.shift.push(this.shift[ix]+this.step); 
}
};	
// ----------------------- XML section ----------------------------------------------------
pp.prototype.xml = function(text, preserveComments) {
var strg = preserveComments ? text
: text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"");
var ar = strg.replace(/>\s{0,}</g,"><")
.replace(/</g,"~::~<")
.replace(/xmlns\:/g,"~::~xmlns:")
.replace(/xmlns\=/g,"~::~xmlns=")
.split('~::~'),
len = ar.length,
inComment = false,
deep = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
// start comment or <![CDATA[...]]> or <!DOCTYPE //
if(ar[ix].search(/<!/) > -1) { 
str += this.shift[deep]+ar[ix];
inComment = true; 
// end comment  or <![CDATA[...]]> //
if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) { 
inComment = false; 
}
} else 
// end comment  or <![CDATA[...]]> //    find --> or ]>
if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) { 
str += ar[ix];
inComment = false; 
} else 
// <elm></elm> //    find prev <tag and this <\tag    but now not prev \>
if( ar[ix-1] != null && ar[ix-1].search(/\/>/) == -1 && /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
/^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) { 
// Omits indentation
// str += ar[ix];
// No longer omits indentation: For compatibility with Java PP routine
str = !inComment ? str += this.shift[--deep]+ar[ix] : str += ar[ix];
// if(!inComment) deep--;
} else
// <elm> //
//    find <tag but not </ or />
if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
str = !inComment ? str += this.shift[deep++]+ar[ix] : str += ar[ix];
} else 
// <elm>...</elm> //    find <tag and </    not sure how both can be on one line
if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
str = !inComment ? str += this.shift[deep]+ar[ix] : str += ar[ix];
} else 
// </elm> //    find </
if(ar[ix].search(/<\//) > -1) { 
str = !inComment ? str += this.shift[--deep]+ar[ix] : str += ar[ix];
} else 
// <elm/> //    find />
if(ar[ix].search(/\/>/) > -1 ) { 
str = !inComment ? str += this.shift[deep]+ar[ix] : str += ar[ix];
} else 
// <? xml ... ?> //
if(ar[ix].search(/<\?/) > -1) { 
str += this.shift[deep]+ar[ix];
} else 
// xmlns //
if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) { 
str += this.shift[deep]+ar[ix];
} 
else {
str += ar[ix];
}
}
return  (str[0] == '\n') ? str.slice(1) : str;
}
// ----------------------- JSON section ----------------------------------------------------
pp.prototype.json = function(text) {
if ( typeof text === "string" ) {
return JSON.stringify(JSON.parse(text), null, this.step);
}
if ( typeof text === "object" ) {
return JSON.stringify(text, null, this.step);
}
return null;
}
// ----------------------- CSS section ----------------------------------------------------
pp.prototype.css = function(text) {
var ar = text.replace(/\s{1,}/g,' ')
.replace(/\{/g,"{~::~")
.replace(/\}/g,"~::~}~::~")
.replace(/\;/g,";~::~")
.replace(/\/\*/g,"~::~/*")
.replace(/\*\//g,"*/~::~")
.replace(/~::~\s{0,}~::~/g,"~::~")
.split('~::~'),
len = ar.length,
deep = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
if( /\{/.exec(ar[ix]))  { 
str += this.shift[deep++]+ar[ix];
} else 
if( /\}/.exec(ar[ix]))  { 
str += this.shift[--deep]+ar[ix];
} else
if( /\*\\/.exec(ar[ix]))  { 
str += this.shift[deep]+ar[ix];
}
else {
str += this.shift[deep]+ar[ix];
}
}
return str.replace(/^\n{1,}/,'');
}
// ----------------------- SQL section ----------------------------------------------------
function isSubquery(str, parenthesisLevel) {
return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
}
function split_sql(str, tab) {
return str.replace(/\s{1,}/g," ")
.replace(/ AND /ig,"~::~"+tab+tab+"AND ")
.replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
.replace(/ CASE /ig,"~::~"+tab+"CASE ")
.replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
.replace(/ END /ig,"~::~"+tab+"END ")
.replace(/ FROM /ig,"~::~FROM ")
.replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
.replace(/ HAVING /ig,"~::~HAVING ")
//.replace(/ IN /ig,"~::~"+tab+"IN ")
.replace(/ IN /ig," IN ")
.replace(/ JOIN /ig,"~::~JOIN ")
.replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
.replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
.replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
.replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")
.replace(/ ON /ig,"~::~"+tab+"ON ")
.replace(/ OR /ig,"~::~"+tab+tab+"OR ")
.replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
.replace(/ OVER /ig,"~::~"+tab+"OVER ")
.replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
.replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")
.replace(/ THEN /ig," THEN~::~"+tab+"")
.replace(/ UNION /ig,"~::~UNION~::~")
.replace(/ USING /ig,"~::~USING ")
.replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
.replace(/ WHERE /ig,"~::~WHERE ")
.replace(/ WITH /ig,"~::~WITH ")
//.replace(/\,\s{0,}\(/ig,",~::~( ")
//.replace(/\,/ig,",~::~"+tab+tab+"")
.replace(/ ALL /ig," ALL ")
.replace(/ AS /ig," AS ")
.replace(/ ASC /ig," ASC ") 
.replace(/ DESC /ig," DESC ") 
.replace(/ DISTINCT /ig," DISTINCT ")
.replace(/ EXISTS /ig," EXISTS ")
.replace(/ NOT /ig," NOT ")
.replace(/ NULL /ig," NULL ")
.replace(/ LIKE /ig," LIKE ")
.replace(/\s{0,}SELECT /ig,"SELECT ")
.replace(/~::~{1,}/g,"~::~")
.split('~::~');
}
pp.prototype.sql = function(text) {
var ar_by_quote = text.replace(/\s{1,}/g," ")
.replace(/\'/ig,"~::~\'")
.split('~::~'),
len = ar_by_quote.length,
ar = [],
deep = 0,
tab = this.step,//+this.step,
inComment = true,
inQuote = false,
parenthesisLevel = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
if(ix%2) {
ar = ar.concat(ar_by_quote[ix]);
} else {
ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
}
}
len = ar.length;
for(ix=0;ix<len;ix++) {
parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);
if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
} 
if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
deep++;
str += this.shift[deep]+ar[ix];
} else 
if( /\'/.exec(ar[ix]) )  { 
if(parenthesisLevel<1 && deep) {
deep--;
}
str += ar[ix];
}
else  { 
str += this.shift[deep]+ar[ix];
if(parenthesisLevel<1 && deep) {
deep--;
}
} 
}
str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
return str;
}
// ----------------------- min section ----------------------------------------------------
pp.prototype.xmlmin = function(text, preserveComments) {
var str = preserveComments ? text
: text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"");
return  str.replace(/>\s{0,}</g,"><"); 
}
pp.prototype.jsonmin = function(text) {
return  text.replace(/\s{0,}\{\s{0,}/g,"{")
.replace(/\s{0,}\[$/g,"[")
.replace(/\[\s{0,}/g,"[")
.replace(/:\s{0,}\[/g,':[')
.replace(/\s{0,}\}\s{0,}/g,"}")
.replace(/\s{0,}\]\s{0,}/g,"]")
.replace(/\"\s{0,}\,/g,'",')
.replace(/\,\s{0,}\"/g,',"')
.replace(/\"\s{0,}:/g,'":')
.replace(/:\s{0,}\"/g,':"')
.replace(/:\s{0,}\[/g,':[')
.replace(/\,\s{0,}\[/g,',[')
.replace(/\,\s{2,}/g,', ')
.replace(/\]\s{0,},\s{0,}\[/g,'],[');   
}
pp.prototype.cssmin = function(text, preserveComments) {
var str = preserveComments ? text
: text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;
return str.replace(/\s{1,}/g,' ')
.replace(/\{\s{1,}/g,"{")
.replace(/\}\s{1,}/g,"}")
.replace(/\;\s{1,}/g,";")
.replace(/\/\*\s{1,}/g,"/*")
.replace(/\*\/\s{1,}/g,"*/");
}	
pp.prototype.sqlmin = function(text) {
return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
}
// --------------------------------------------------------------------------------------------
// this.Pretty = new pp;	
this.getCWAEnv().add(new pp, "Pretty");
//-------- js/Access.XHR.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Access, DOMParse, Pretty, XMLSerialize, cwaenv, document, logLev, theSToCA;
cwaenv = this.getCWAEnv();
document = this.document;
XMLSerialize = new XMLSerializer;
DOMParse = new DOMParser;
theSToCA = cwaenv.get("theSToCA");
Pretty = cwaenv.get("Pretty");
logLev = 0;
Access = (function() {
function Access() {}
Access.setLogLevel = function(lev) {
return logLev = lev;
};
Access.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
Access.toDOM = function(theXML, errCB) {
var doc, errMsg, i, len, pErr, pErrs;
if (errCB == null) {
errCB = null;
}
doc = DOMParse.parseFromString(theXML, "text/xml");
pErrs = doc.getElementsByTagName("parsererror");
if (pErrs.length > 0) {
errMsg = "";
for (i = 0, len = pErrs.length; i < len; i++) {
pErr = pErrs[i];
errMsg += Access._justText(pErr);
}
Access.trace(errMsg);
if (errCB) {
errCB("error", errMsg);
}
return null;
} else {
return doc;
}
};
Access._justText = function(el) {
var i, len, nd, ref, res;
res = "";
ref = el.childNodes;
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (nd.nodeType === Node.ELEMENT_NODE) {
res += Access._justText(nd);
} else if (nd.nodeType === Node.TEXT_NODE) {
res += nd.nodeValue;
}
}
return res;
};
Access._isFileURL = function(url) {
return (url.substring(0, 5)) === "file:";
};
Access.fetchURI = function(theURI, theCB, form) {
var myXHR, rqstData, rqstType;
rqstType = form === "HEAD" ? "HEAD" : (form === null) || (form === "GET") ? "GET" : "POST";
rqstData = (form === "HEAD") || (form === "POST") || (form === "GET") ? null : form;
console.log("fetchURI fetching: " + theURI + " Type=" + rqstType);
if ((theSToCA.isInIE()) && (Access._isFileURL(theURI))) {
myXHR = new ActiveXObject("Microsoft.XMLHTTP");
myXHR.open(rqstType, theURI, true);
myXHR.onreadystatechange = (function(_this) {
return function() {
var msg;
if (myXHR.readyState === XMLHttpRequest.DONE) {
if ((myXHR.status === 0) || (myXHR.status === 200)) {
console.log("fetchURI using ActiveX fetched:  " + theURI + " Status=" + myXHR.status);
return theCB(myXHR.responseText, 0, null, myXHR.responseText);
} else {
msg = "fetchURI using ActiveX: Failed for " + theURI + " Status=" + myXHR.status;
console.log(msg);
return theCB(null, 1, msg, myXHR.responseText);
}
}
};
})(this);
} else {
myXHR = new XMLHttpRequest;
myXHR.open(rqstType, theURI, true);
myXHR.overrideMimeType("text/plain; charset=x-user-defined");
myXHR.onloadend = (function(_this) {
return function() {
var msg, xhrok;
xhrok = (myXHR.status === 0) || (myXHR.status === 200);
if (xhrok) {
console.log("fetchURI fetched:  " + theURI + " Status=" + myXHR.status);
return theCB(myXHR.responseText, 0, null, myXHR.responseText);
} else {
msg = "fetchURI: Failed for " + theURI + " Status=" + myXHR.status;
console.log(msg);
return theCB(null, 1, msg, myXHR.responseText);
}
};
})(this);
}
return myXHR.send(rqstData);
};
return Access;
})();
cwaenv.add(Access, "Access");
cwaenv.add(XMLSerialize, "XMLSerialize");
cwaenv.add(Node, "Node");
}).call(this);
//-------- js/Data.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Access, Data, Pretty, XMLSerialize, cwaenv, log;
cwaenv = this.getCWAEnv();
Access = cwaenv.get("Access");
Pretty = cwaenv.get("Pretty");
XMLSerialize = cwaenv.get("XMLSerialize");
log = console.log;
Data = (function() {
function Data() {}
Data.toDOM = Access.toDOM;
Data.result = function(val, errCount, errText, partVal) {
return {
value: val,
errCount: errCount,
errText: errText,
partVal: partVal
};
};
Data.parseJSON = function(jstr) {
if ((jstr != null) && jstr.length > 0) {
return JSON.parse(jstr);
} else {
console.log("JSON.parse failed for \"" + jstr + "\"");
return null;
}
};
Data.ppJSON = function(theJSON) {
return Pretty.json(theJSON);
};
Data.mnJSON = function(theJSON) {
if (typeof theJSON === "object") {
theJSON = JSON.stringify(theJSON);
}
return Pretty.jsonmin(theJSON);
};
Data.ppXML = function(theXML, pres) {
if (pres == null) {
pres = true;
}
return Pretty.xml(theXML, pres);
};
Data.mnXML = function(theXML, pres) {
if (pres == null) {
pres = false;
}
return Pretty.xmlmin(theXML, pres);
};
Data.ppDOM = function(theDOM, pres) {
if (pres == null) {
pres = true;
}
return Pretty.xml(XMLSerialize.serializeToString(theDOM), pres);
};
Data.mnDOM = function(theDOM, pres) {
if (pres == null) {
pres = false;
}
return Pretty.xmlmin(XMLSerialize.serializeToString(theDOM), pres);
};
Data.splitURI = function(uri) {
var matches, pattern;
if (uri == null) {
uri = Data.locBaseURI;
}
pattern = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
matches = uri.match(pattern);
return {
scheme: matches[2],
authority: matches[4],
path: matches[5],
query: matches[7],
fragment: matches[9]
};
};
Data.stringURI = function(uriobj) {
var res;
res = uriobj.scheme + "://" + uriobj.authority + uriobj.path;
if (uriobj.query != null) {
res += "?" + uriobj.query;
}
return res;
};
Data.stringURIPath = function(uriobj) {
var res;
res = uriobj.path;
if (uriobj.query != null) {
res += "?" + uriobj.query;
}
return res;
};
Data.absoluteSplitURI = function(uri, base) {
var basedir, baseobj, ref, uriobj;
uriobj = Data.splitURI(uri);
baseobj = Data.splitURI(base);
basedir = baseobj.path.substr(0, (baseobj.path.lastIndexOf("/")) + 1);
return {
scheme: uriobj.scheme || baseobj.scheme,
authority: uriobj.authority || baseobj.authority,
path: ((ref = uriobj.path) != null ? ref.charAt(0) : void 0) === "/" ? uriobj.path : basedir + uriobj.path,
query: uriobj.query || baseobj.query,
fragment: uriobj.fragment || baseobj.fragment
};
};
Data.absoluteURI = function(uri, base) {
return Data.stringURI(Data.absoluteSplitURI(uri, base));
};
Data.asDir = function(uri) {
if (uri.endsWith("/")) {
return uri;
} else {
return uri + "/";
}
};
Data.isDataURL = function(url) {
return (url.substring(0, 5)) === "data:";
};
Data.locBaseURI = Data.absoluteURI("", location.toString());
Data.locBaseSplit = Data.splitURI(Data.locBaseURI);
Data.fetchURI = Access.fetchURI;
Data.fetchRelURI = function(theURI, theCB, form) {
var thePre, theSplit;
theSplit = Data.splitURI(theURI);
thePre = theURI.substring(0, Data.locBaseURI.length);
if (thePre === Data.locBaseURI) {
theURI = theURI.substring(Data.locBaseURI.length);
} else if (theSplit.scheme === Data.locBaseSplit.scheme && theSplit.authority === Data.locBaseSplit.authority) {
theURI = Data.stringURIPath(theSplit);
}
return Access.fetchURI(theURI, theCB, form);
};
Data.fetchText = function(theURI, theCB, form) {
var textCB;
textCB = (function(_this) {
return function(val, errC, errT, part) {
if (errC === 0) {
val = (val.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
}
return theCB(val, errC, errT, part);
};
})(this);
return Data.fetchURI(theURI, textCB, form);
};
Data.fetchJSON = function(theURI, theCB, form) {
var JSONCB;
JSONCB = (function(_this) {
return function(val, errC, errT, part) {
var newJSON;
if (errC === 0) {
newJSON = Data.parseJSON(val);
}
if (newJSON != null) {
return theCB(newJSON, 0, null, newJSON);
} else {
return theCB(null, 1, "No JSON data found", val);
}
};
})(this);
return Data.fetchURI(theURI, JSONCB, form);
};
return Data;
})();
cwaenv.add(Data, "Data");
}).call(this);
//-------- js/Config.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Config, Data, console, cwaenv, document, location, log, setTimeout, zip;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
location = this.location;
zip = this.zip;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Data = cwaenv.get("Data");
Config = (function() {
function Config() {}
Config._INSTALL_CFG = "cwacfg.json";
Config.theConfig = {
clientBase: Data.absoluteURI("", location.toString())
};
Config.updateObj = function(theObj, defVals) {
var key, results, val;
results = [];
for (key in defVals) {
val = defVals[key];
if (!theObj.hasOwnProperty(key)) {
results.push(theObj[key] = val);
} else {
results.push(void 0);
}
}
return results;
};
Config.updateConfig = function(defVals) {
return this.updateObj(this.theConfig, defVals);
};
Config.load = function(CB, path, initCfg) {
var clientURI, cwaConfigLoad, loadDone;
loadDone = (function(_this) {
return function() {
var avs, base, defaultAv, defaults, i, j, key, len, len1, ref, ref1;
defaultAv = {
width: 384,
height: 320,
avList: "avs",
initAv: "anna",
background: null,
initCamera: [0, 0.23, 3.24, 5, 18, 30, -1, -1],
allowFrameSteps: true,
initSiGMLURL: "iTakeMug.sigml",
allowSiGMLText: true
};
defaults = {
jasVersionTag: "vhg2017",
animgenFPS: 50,
animgenServer: "http://vhg.cmp.uea.ac.uk/cgi-bin/animgen/animgenserver.pl",
sigmlBase: "sigml",
avJARBase: "avatars",
avJSONBase: "avjson",
useAvatarJARs: true,
avs: ["anna", "marc", "francoise"],
avSettings: [defaultAv]
};
_this.updateConfig(defaults);
if ((base = _this.theConfig).avBase == null) {
base.avBase = _this.theConfig.useAvatarJARs ? _this.theConfig.avJARBase : _this.theConfig.avJSONBase;
}
ref = ["sigmlBase", "avJARBase", "avJSONBase", "avBase"];
for (i = 0, len = ref.length; i < len; i++) {
key = ref[i];
_this.theConfig[key] = Data.absoluteURI(Data.asDir(_this.theConfig[key]), _this.theConfig.jasBase);
}
if (!(Array.isArray(_this.theConfig.avSettings))) {
_this.theConfig.avSettings = [_this.theConfig.avSettings];
}
ref1 = _this.theConfig.avSettings;
for (j = 0, len1 = ref1.length; j < len1; j++) {
avs = ref1[j];
_this.updateObj(avs, defaultAv);
}
_this._fixReferences();
zip.useWebWorkers = false;
return CB();
};
})(this);
cwaConfigLoad = (function(_this) {
return function() {
var cwaURI;
if (_this.theConfig.jasBase == null) {
log("Config: Installation base \"http://vhg.cmp.uea.ac.uk/tech/jas/vhg2017/\" used for jasBase");
}
_this.theConfig.jasBase = Data.asDir(_this.theConfig.jasBase || "http://vhg.cmp.uea.ac.uk/tech/jas/vhg2017/");
_this.theConfig.cwaBase = Data.absoluteURI(Data.asDir(_this.theConfig.cwaBase || "cwa"), _this.theConfig.jasBase);
_this.updateConfig({
useCwaConfig: true
});
if (_this.theConfig.useCwaConfig) {
cwaURI = Data.absoluteURI(Config._INSTALL_CFG, _this.theConfig.cwaBase);
return _this._loadJSON(loadDone, cwaURI);
} else {
return loadDone();
}
};
})(this);
this.updateConfig(initCfg);
this.updateConfig({
useClientConfig: initCfg == null
});
if (this.theConfig.useClientConfig) {
clientURI = Data.absoluteURI(path, this.theConfig.clientBase);
this._loadJSON(cwaConfigLoad, clientURI);
} else {
cwaConfigLoad();
}
return this.theConfig;
};
Config._loadJSON = function(CB, uri) {
var JSONCB;
JSONCB = (function(_this) {
return function(json, eCount, eMsg) {
if (eCount > 0) {
log("Config: " + eMsg + " for \"" + uri + "\"");
} else {
_this.updateConfig(json);
}
return CB();
};
})(this);
return Data.fetchJSON(uri, JSONCB);
};
Config._fixReferences = function() {
var allavs, i, len, newall, ref, stg;
allavs = this.theConfig.allavs || [];
ref = this.theConfig.avSettings;
for (i = 0, len = ref.length; i < len; i++) {
stg = ref[i];
if (!(typeof stg.avList === "string")) {
continue;
}
stg.avList = this.theConfig[stg.avList];
if ((stg.avList.indexOf(stg.initAv)) < 0) {
stg.avList.push(stg.initAv);
}
newall = allavs.concat(stg.avList.filter((function(itm) {
return (allavs.indexOf(itm)) < 0;
})));
allavs = newall;
}
return this.theConfig.allavs = allavs;
};
Config.getAvBase = function(av) {
var b;
b = Data.asDir(this.theConfig.avBase);
if (this.theConfig.useAvatarJARs) {
return this.theConfig.avBase;
} else {
return "" + this.theConfig.avBase + av + "/";
}
};
return Config;
})();
cwaenv.add(Config, "Config");
}).call(this);
//-------- js/Shader.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Shader, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Shader = (function() {
function Shader(gl, vsPath, fsPath, vsSource, fsSource, vsSubs, fsSubs) {
var a, i, j, k, ref, ref1, shprog, sz, u, vsfsStr;
this.gl = gl;
this.vsPath = vsPath;
this.fsPath = fsPath;
this.vsSource = vsSource;
this.fsSource = fsSource;
this.vsSubs = vsSubs;
this.fsSubs = fsSubs;
this._prog = null;
this._vs = null;
this._fs = null;
this._nUniforms = -1;
this._uniforms = {};
this._nAttributes = -1;
this._attributes = {};
this._vs = this._loadShader(this.vsPath, this.vsSource, this.vsSubs);
this._fs = this._loadShader(this.fsPath, this.fsSource, this.fsSubs);
shprog = this.gl.createProgram();
if (this._vs && this._fs) {
this.gl.attachShader(shprog, this._vs);
if (this._fs) {
this.gl.attachShader(shprog, this._fs);
}
this.gl.bindAttribLocation(shprog, 0, "BindPos");
this.gl.linkProgram(shprog);
}
vsfsStr = "VrtxS=" + this.vsPath + "  FragS=" + this.fsPath;
if (this.gl.getProgramParameter(shprog, this.gl.LINK_STATUS)) {
log("Shader program using: " + vsfsStr + " created ");
this._prog = shprog;
} else {
log("Shader program using: " + vsfsStr + " failed to link: " + (this.gl.getProgramInfoLog(shprog)));
this.gl.deleteProgram(shprog);
this._vs = this._fs = null;
}
if (this._prog) {
this._nUniforms = this.gl.getProgramParameter(this._prog, this.gl.ACTIVE_UNIFORMS);
sz = 0;
for (i = j = 0, ref = this._nUniforms; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
u = this.gl.getActiveUniform(this._prog, i);
this._uniforms[u.name] = this.gl.getUniformLocation(this._prog, u.name);
sz += (this.gl.getActiveUniform(this._prog, i)).size;
}
this._nAttributes = this.gl.getProgramParameter(this._prog, this.gl.ACTIVE_ATTRIBUTES);
for (i = k = 0, ref1 = this._nAttributes; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
a = this.gl.getActiveAttrib(this._prog, i);
this._attributes[a.name] = this.gl.getAttribLocation(this._prog, a.name);
}
}
this.DO_CHECK_LOC_NAME = false;
}
/*  Accessors */
Shader.prototype.isValid = function() {
return this._prog !== null;
};
Shader.prototype.getHandle = function() {
return this._prog;
};
Shader.prototype.getUniformLocation = function(uName) {
var ul;
ul = this._uniforms[uName];
if (ul === void 0 && this.DO_CHECK_LOC_NAME) {
log("ERROR: missing GL uniform '" + uName + "'");
}
return ul;
};
Shader.prototype.getAttributeLocation = function(aName) {
var al;
al = this._attributes[aName];
if (al === void 0 && this.DO_CHECK_LOC_NAME) {
"ERROR: missing GL attribute '" + aName + "'";
}
return al;
};
/*  Private helper methods. */
Shader.prototype._loadShader = function(spath, source, subs) {
var shader, ssource, strEndsWith;
strEndsWith = function(s, sfx) {
var dif;
dif = s.length - sfx.length;
return 0 <= dif && (String(sfx)) === s.substring(dif);
};
shader = strEndsWith(spath, ".vert") ? this.gl.createShader(this.gl.VERTEX_SHADER) : strEndsWith(spath, ".frag") ? this.gl.createShader(this.gl.FRAGMENT_SHADER) : (log("Unrecognised shader URL suffix: " + spath + "."), null);
if (shader != null) {
ssource = subs ? this._applySubs(source, subs) : source;
this.gl.shaderSource(shader, ssource);
this.gl.compileShader(shader);
if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
log("Shader failed: " + spath + ": " + (this.gl.getShaderInfoLog(shader)));
shader = null;
} else {
log("Shader loaded: " + spath);
}
}
return shader;
};
Shader.prototype._applySubs = function(txt, subs) {
var j, len, ref, repl, stxt, tag, tagpat;
stxt = txt;
for (j = 0, len = subs.length; j < len; j++) {
ref = subs[j], tag = ref[0], repl = ref[1];
tagpat = "___" + tag + "___";
stxt = stxt.replace(new RegExp(tagpat, "gm"), repl);
}
return stxt;
};
return Shader;
})();
cwaenv.add(Shader, "Shader");
}).call(this);
//-------- js/Texture.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, Texture, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Data = cwaenv.get("Data");
Texture = (function() {
function Texture(_gl, _tURLGen, _mustFlip) {
this._gl = _gl;
this._tURLGen = _tURLGen;
this._mustFlip = _mustFlip;
this._texture = this._gl.createTexture();
this._textureLoaded = false;
this._texture.image = new Image;
this._texture.image.onload = ((function(_this) {
return function() {
return _this._buildTexture();
};
})(this));
this._tURLGen(this._getTextureURLHandler());
}
Texture.prototype.isValid = function() {
return this._textureLoaded;
};
Texture.prototype.getHandle = function() {
return this._texture;
};
Texture.prototype._getTextureURLHandler = function() {
return (function(_this) {
return function(turl) {
if (turl) {
return _this._texture.image.src = turl;
} else {
return log("Texture: URL is null.");
}
};
})(this);
};
Texture.prototype._buildTexture = function() {
var ex, imgSrc, srcDesc;
this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, this._mustFlip);
try {
this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._texture.image);
} catch (error) {
ex = error;
log("Caught error building texture: " + ex);
}
this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR_MIPMAP_LINEAR);
this._gl.generateMipmap(this._gl.TEXTURE_2D);
this._gl.bindTexture(this._gl.TEXTURE_2D, null);
imgSrc = this._texture.image.src;
srcDesc = Data.isDataURL(imgSrc) ? "data URL" : imgSrc;
log("Texture: loaded from source " + srcDesc);
return this._textureLoaded = true;
};
return Texture;
})();
cwaenv.add(Texture, "Texture");
}).call(this);
//-------- js/VBO.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var VBO, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
VBO = (function() {
function VBO(GL, elSize1, data, mode1, attrLoc, itemType, glTarget, usage1) {
this.GL = GL;
this.elSize = elSize1;
this.mode = mode1;
this.attrLoc = attrLoc;
this.itemType = itemType;
this.glTarget = glTarget;
this.usage = usage1;
this._buffer = this.GL.createBuffer();
this._nVertices = data.length / this.elSize;
this.GL.bindBuffer(this.glTarget, this._buffer);
this.GL.bufferData(this.glTarget, data, this.usage);
this.GL.bindBuffer(this.glTarget, null);
}
VBO._make = function(gl, elSize, buf, mode, aLoc, iType, isEl, isDyn) {
var target, usage;
target = isEl ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
usage = isDyn ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
return new VBO(gl, elSize, buf, mode, aLoc, iType, target, usage);
};
VBO.makeStd = function(gl, elSize, buf, aLoc) {
return this._make(gl, elSize, buf, null, aLoc, gl.FLOAT, false, false);
};
VBO.makeDyn = function(gl, elSize, buf, aLoc) {
return this._make(gl, elSize, buf, null, aLoc, gl.FLOAT, false, true);
};
VBO.makeEls = function(gl, elSize, buf, mode, isByte) {
var iType;
iType = isByte ? gl.UNSIGNED_BYTE : gl.UNSIGNED_SHORT;
return this._make(gl, elSize, buf, mode, null, iType, true, false);
};
VBO.prototype._valueSize = function() {
var gl, type;
gl = this.GL;
type = this.itemType;
if (type === gl.FLOAT) {
return 4;
} else if (type === gl.UNSIGNED_BYTE) {
return 1;
} else if (type === gl.UNSIGNED_SHORT) {
return 2;
} else {
return -1;
}
};
VBO.prototype.getHandle = function() {
return this._buffer;
};
VBO.prototype.getElementSize = function() {
return this.elSize;
};
VBO.prototype.getNumVertices = function() {
return this._nVertices;
};
VBO.prototype.uploadPartialData = function(baseEl, data) {
var byteOffset;
byteOffset = baseEl * this.elSize * (this._valueSize());
this.GL.bindBuffer(this.glTarget, this._buffer);
this.GL.bufferSubData(this.glTarget, byteOffset, data);
return this.GL.bindBuffer(this.glTarget, null);
};
VBO.prototype.uploadNewData = function(data) {
return this.uploadPartialData(0, data);
};
VBO.prototype.enableAttrib = function() {
this.GL.enableVertexAttribArray(this.attrLoc);
this.GL.bindBuffer(this.glTarget, this._buffer);
this.GL.vertexAttribPointer(this.attrLoc, this.elSize, this.itemType, false, 0, 0);
return this.GL.bindBuffer(this.glTarget, null);
};
VBO.prototype.disableAttrib = function() {
return this.GL.disableVertexAttribArray(this.attrLoc);
};
VBO.prototype.drawElements = function() {
this.GL.bindBuffer(this.glTarget, this._buffer);
this.GL.drawElements(this.mode, this._nVertices, this.itemType, 0);
return this.GL.bindBuffer(this.glTarget, null);
};
return VBO;
})();
cwaenv.add(VBO, "VBO");
}).call(this);
//-------- js/E3Vec.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var E3Vec, RQ, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
RQ = void 0;
E3Vec = (function() {
function E3Vec(x, y, z) {
this.xyz = new Float32Array([x, y, z]);
}
E3Vec.setRotQuat = function(rq) {
return RQ = rq;
};
E3Vec.fStr = function(x, n) {
return x.toFixed(n);
};
E3Vec.fStr3 = function(x) {
return this.fStr(x, 3);
};
E3Vec.vStr = function(xyz, n) {
var ref, t, xs, ys, zs;
ref = (function() {
var i, len1, results;
results = [];
for (i = 0, len1 = xyz.length; i < len1; i++) {
t = xyz[i];
results.push(this.fStr(t, n));
}
return results;
}).call(this), xs = ref[0], ys = ref[1], zs = ref[2];
return "<" + xs + " " + ys + " " + zs + ">";
};
E3Vec.make3Vec = function() {
return new Float32Array(3);
};
E3Vec.make4Vec = function() {
return new Float32Array(4);
};
E3Vec.makeV3 = function(x, y, z) {
return new Float32Array([x, y, z]);
};
E3Vec.copyOfV3 = function(xyz) {
return new Float32Array(xyz);
};
E3Vec.setV3_xyz = function(xyz, x, y, z) {
xyz[0] = x;
xyz[1] = y;
xyz[2] = z;
return xyz;
};
E3Vec.setV3 = function(xyz, xyzb) {
var xb, yb, zb;
xb = xyzb[0], yb = xyzb[1], zb = xyzb[2];
xyz[0] = xb;
xyz[1] = yb;
xyz[2] = zb;
return xyz;
};
E3Vec.setAddV3 = function(xyz, xyzb) {
var xb, yb, zb;
xb = xyzb[0], yb = xyzb[1], zb = xyzb[2];
xyz[0] += xb;
xyz[1] += yb;
xyz[2] += zb;
return xyz;
};
E3Vec.addV3 = function(xyza, xyzb) {
return this.setAddV3(this.copyOfV3(xyza), xyzb);
};
E3Vec.setSubtractV3 = function(xyz, xyzb) {
var xb, yb, zb;
xb = xyzb[0], yb = xyzb[1], zb = xyzb[2];
xyz[0] -= xb;
xyz[1] -= yb;
xyz[2] -= zb;
return xyz;
};
E3Vec.subtractV3 = function(xyza, xyzb) {
return this.setSubtractV3(this.copyOfV3(xyza), xyzb);
};
E3Vec.dotProductV3 = function(xyza, xyzb) {
var xa, xb, ya, yb, za, zb;
xa = xyza[0], ya = xyza[1], za = xyza[2];
xb = xyzb[0], yb = xyzb[1], zb = xyzb[2];
return xa * xb + ya * yb + za * zb;
};
E3Vec.squaredLengthV3 = function(xyz) {
return this.dotProductV3(xyz, xyz);
};
E3Vec.lengthV3 = function(xyz) {
return Math.sqrt(this.squaredLengthV3(xyz));
};
E3Vec.projectionV3 = function(xyza, xyzb) {
return (this.dotProductV3(xyza, xyzb)) / (this.lengthV3(xyzb));
};
E3Vec.setScaleV3 = function(xyz, s) {
xyz[0] *= s;
xyz[1] *= s;
xyz[2] *= s;
return xyz;
};
E3Vec.setInverseScaleV3 = function(xyz, s) {
xyz[0] /= s;
xyz[1] /= s;
xyz[2] /= s;
return xyz;
};
E3Vec.setNegateV3 = function(xyz) {
var x, y, z;
x = xyz[0], y = xyz[1], z = xyz[2];
return this.setV3_xyz(xyz, -x, -y, -z);
};
E3Vec.setNormalizeV3 = function(xyz) {
var len;
len = this.lengthV3(xyz);
if (1e-5 <= len) {
return this.setInverseScaleV3(xyz, len);
} else {
return xyz;
}
};
E3Vec.normalizeV3 = function(xyza) {
return this.setNormalizeV3(this.copyOfV3(xyza));
};
E3Vec.setCrossProductV3 = function(xyz, xyzb) {
var xa, xb, ya, yb, za, zb;
xa = xyz[0], ya = xyz[1], za = xyz[2];
xb = xyzb[0], yb = xyzb[1], zb = xyzb[2];
return this.setV3_xyz(xyz, ya * zb - za * yb, za * xb - xa * zb, xa * yb - ya * xb);
};
E3Vec.crossProductV3 = function(xyza, xyzb) {
return this.setCrossProductV3(this.copyOfV3(xyza), xyzb);
};
E3Vec.setUnitCrossProductV3 = function(xyz, xyzb) {
return this.setNormalizeV3(this.setCrossProductV3(xyz, xyzb));
};
E3Vec.unitCrossProductV3 = function(xyza, xyzb) {
return this.setUnitCrossProductV3(this.copyOfV3(xyza), xyzb);
};
E3Vec.setRotateV3 = function(xyz, qv) {
return RQ.rotateV3(xyz, xyz, qv);
};
E3Vec.from_xyz = function(x, y, z) {
return new E3Vec(x, y, z);
};
E3Vec.fromV3 = function(xyz) {
var x, y, z;
x = xyz[0], y = xyz[1], z = xyz[2];
return new E3Vec(x, y, z);
};
E3Vec.fromE3V = function(e3v) {
return this.fromV3(e3v.xyz);
};
E3Vec.fromVec = function(xyz) {
return this.fromV3(xyz);
};
E3Vec.create = function() {
return new E3Vec(0, 0, 0);
};
E3Vec.ZERO = new E3Vec(0, 0, 0);
E3Vec.prototype.x = function() {
return this.xyz[0];
};
E3Vec.prototype.y = function() {
return this.xyz[1];
};
E3Vec.prototype.z = function() {
return this.xyz[2];
};
E3Vec.prototype.copyXYZ = function() {
return E3Vec.copyOfV3(this.xyz);
};
E3Vec.prototype.toXYZ = function(xyz) {
return E3Vec.setV3(xyz, this.xyz);
};
E3Vec.prototype.toV3 = function(xyz) {
return E3Vec.setV3(xyz, this.xyz);
};
E3Vec.prototype.toStr = function() {
return this.asString();
};
E3Vec.prototype.asString = function() {
var ref, x, y, z;
ref = this.xyz, x = ref[0], y = ref[1], z = ref[2];
return "<" + x + " " + y + " " + z + ">";
};
E3Vec.prototype.asString_n = function(n) {
return E3Vec.vStr(this.xyz, n);
};
E3Vec.prototype.asString4 = function() {
return this.asString_n(4);
};
E3Vec.prototype.set_xyz = function(x, y, z) {
E3Vec.setV3_xyz(this.xyz, x, y, z);
return this;
};
E3Vec.prototype.setVec = function(xyz) {
E3Vec.setV3(this.xyz, xyz);
return this;
};
E3Vec.prototype.setFromE3V = function(e3v) {
E3Vec.setV3(this.xyz, e3v.xyz);
return this;
};
E3Vec.prototype.addXYZ = function(xyz) {
return E3Vec.fromV3(E3Vec.setAddV3(E3Vec.copyOfV3(this.xyz), xyz));
};
E3Vec.prototype.add = function(e3v) {
return this.addXYZ(e3v.xyz);
};
E3Vec.prototype.dotProduct = function(e3v) {
return E3Vec.dotProductV3(this.xyz, e3v.xyz);
};
E3Vec.prototype.setNegate = function() {
E3Vec.setNegateV3(this.xyz);
return this;
};
E3Vec.prototype.setAdd = function(e3v) {
E3Vec.setAddV3(this.xyz, e3v.xyz);
return this;
};
E3Vec.prototype.setCrossProduct = function(e3v) {
E3Vec.setCrossProductV3(this.xyz, e3v.xyz);
return this;
};
E3Vec.prototype.setUnitCrossProduct = function(e3v) {
E3Vec.setUnitCrossProductV3(this.xyz, e3v.xyz);
return this;
};
E3Vec.prototype.setRotate = function(rq) {
E3Vec.setRotateV3(this.xyz, rq.xyzw);
return this;
};
E3Vec.prototype.projectionOn = function(e3v) {
return E3Vec.projectionV3(this.xyz, e3v.xyz);
};
E3Vec.prototype.xyzLength = function() {
return E3Vec.lengthV3(this.xyz);
};
E3Vec.prototype.squaredLength = function() {
return E3Vec.squaredLengthV3(this.xyz);
};
return E3Vec;
})();
cwaenv.add(E3Vec, "E3Vec");
}).call(this);
//-------- js/RotQuat.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var RotQuat, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
V3 = cwaenv.get("E3Vec");
RotQuat = (function() {
var RQ;
function RotQuat() {
this.xyzw = new Float32Array(4);
this.xyzw[3] = 1;
}
RQ = RotQuat;
RotQuat.fStr = function(x, n) {
return x.toFixed(n);
};
RotQuat.fStr3 = function(x) {
return this.fStr(x, 3);
};
RotQuat.qStr = function(qv, n) {
var ref, t, w, x, y, z;
ref = (function() {
var j, len, results;
results = [];
for (j = 0, len = qv.length; j < len; j++) {
t = qv[j];
results.push(this.fStr(t, n));
}
return results;
}).call(this), x = ref[0], y = ref[1], z = ref[2], w = ref[3];
return "<" + x + " " + y + " " + z + "; " + w + ">";
};
RotQuat.makeQV = function(x, y, z, w) {
return new Float32Array([x, y, z, w]);
};
RotQuat.copyOfQV = function(qv) {
return new Float32Array(qv);
};
RotQuat.setQV_xyzw = function(qv, x, y, z, w) {
qv[0] = x;
qv[1] = y;
qv[2] = z;
qv[3] = w;
return qv;
};
RotQuat.setQV = function(qv, qq) {
var w, x, y, z;
x = qq[0], y = qq[1], z = qq[2], w = qq[3];
qv[0] = x;
qv[1] = y;
qv[2] = z;
qv[3] = w;
return qv;
};
RotQuat.setAxisAngleQV = function(qv, xyz, angle) {
var halfA, sinHA, ux, uy, uz;
ux = xyz[0], uy = xyz[1], uz = xyz[2];
halfA = 0.5 * angle;
sinHA = Math.sin(halfA);
return this.setQV_xyzw(qv, sinHA * ux, sinHA * uy, sinHA * uz, Math.cos(halfA));
};
RotQuat.setScaleQV = function(qv, s) {
qv[0] *= s;
qv[1] *= s;
qv[2] *= s;
qv[3] *= s;
return qv;
};
RotQuat.scaleQV = function(q, s) {
var qv;
qv = this.copyOfQV(q);
return this.setScaleQV(qv, s);
};
RotQuat.setNegateQV = function(qv) {
qv[0] = -qv[0];
qv[1] = -qv[1];
qv[2] = -qv[2];
qv[3] = -qv[3];
return qv;
};
RotQuat.negateQV = function(q) {
var qv;
qv = this.copyOfQV(q);
return this.setNegateQV(qv);
};
RotQuat.setAddQV = function(qv, qq) {
qv[0] += qq[0];
qv[1] += qq[1];
qv[2] += qq[2];
qv[3] += qq[3];
return qv;
};
RotQuat.addQV = function(qa, qb) {
var qv;
qv = this.copyOfQV(qa);
return this.setAddQV(qv, qb);
};
RotQuat.setSubtractQV = function(qv, qq) {
qv[0] -= qq[0];
qv[1] -= qq[1];
qv[2] -= qq[2];
qv[3] -= qq[3];
return qv;
};
RotQuat.subtractQV = function(qa, qb) {
var qv;
qv = this.copyOfQV(qa);
return this.setSubtractQV(qv, qb);
};
RotQuat.setConjugateQV = function(qv) {
V3.setNegateV3(qv);
return qv;
};
RotQuat.conjugateQV = function(qa) {
var qv;
qv = this.copyOfQV(qa);
return this.setConjugateQV(qv);
};
RotQuat.innerProductQV = function(qa, qb) {
return qa[0] * qb[0] + qa[1] * qb[1] + qa[2] * qb[2] + qa[3] * qb[3];
};
RotQuat.setProductQV = function(qv, qa, qb) {
var aw, ax, ay, az, bw_, bx_, by_, bz_;
ax = qa[0];
ay = qa[1];
az = qa[2];
aw = qa[3];
bx_ = qb[0];
by_ = qb[1];
bz_ = qb[2];
bw_ = qb[3];
return this.setQV_xyzw(qv, aw * bx_ + ax * bw_ + ay * bz_ - az * by_, aw * by_ + ay * bw_ + az * bx_ - ax * bz_, aw * bz_ + az * bw_ + ax * by_ - ay * bx_, aw * bw_ - ax * bx_ - ay * by_ - az * bz_);
};
RotQuat.lengthQV = function(qv) {
return Math.sqrt(this.innerProductQV(qv, qv));
};
RotQuat.setNormalizeQV = function(qv) {
var lensq;
lensq = this.innerProductQV(qv, qv);
if (1e-12 < lensq) {
return setScaleQV(qv, 1 / Math.sqrt(lensq));
} else {
return qv;
}
};
RotQuat.slerpQV = function(qv, qa, qb, T) {
var ONE, T_COMP, cosOmega, doLinear, omega, qb_, sA, sB, sinOmega, sinSqOmega;
ONE = 1;
T_COMP = ONE - T;
cosOmega = this.innerProductQV(qa, qb);
qb_ = qb;
if (cosOmega < 0) {
cosOmega = -cosOmega;
qb_ = this.negateQV(qb);
}
doLinear = ONE - cosOmega < 1e-5;
if (doLinear) {
sA = T_COMP;
sB = T;
} else {
sinSqOmega = 1 - cosOmega * cosOmega;
sinOmega = sinSqOmega / Math.sqrt(sinSqOmega);
omega = Math.atan2(sinOmega, cosOmega);
sA = (Math.sin(omega * T_COMP)) / sinOmega;
sB = (Math.sin(omega * T)) / sinOmega;
}
this.setQV_xyzw(qv, qa[0] * sA + qb_[0] * sB, qa[1] * sA + qb_[1] * sB, qa[2] * sA + qb_[2] * sB, qa[3] * sA + qb_[3] * sB);
if (doLinear) {
return RotQuat.setNormaliseQV(qv);
}
};
RotQuat.rotateV3 = function(v3r, v3, qv) {
var _u, _uX_uXv, _uXv, _v, udotv, w;
_v = V3.copyOfV3(v3);
_u = qv;
w = qv[3];
udotv = V3.dotProductV3(_u, _v);
_uXv = V3.setCrossProductV3(V3.copyOfV3(_u), _v);
_uX_uXv = V3.setCrossProductV3(V3.copyOfV3(_u), _uXv);
V3.setV3(v3r, _u);
V3.setScaleV3(v3r, udotv);
V3.setScaleV3(_v, w * w);
V3.setAddV3(v3r, _v);
V3.setScaleV3(_uXv, 2 * w);
V3.setAddV3(v3r, _uXv);
return V3.setAddV3(v3r, _uX_uXv);
};
RotQuat.rotateV3_ = function(vr, v, q) {
var ab, c, cx, cy, cz, d, i, j, ref, results, ux, uy, uz, vx, vy, vz, w, w2, ww;
vx = v[0], vy = v[1], vz = v[2];
ux = q[0], uy = q[1], uz = q[2], w = q[3];
ww = w * w;
w2 = w + w;
ab = ab = [(ux * ux + ww) * vx, (uy * uy + ww) * vy, (uz * uz + ww) * vz];
ref = c = [uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx], cx = ref[0], cy = ref[1], cz = ref[2];
c[0] *= w2;
c[1] *= w2;
c[2] *= w2;
d = [uy * cz - uz * cy, uz * cx - ux * cz, ux * cy - uy * cx];
results = [];
for (i = j = 0; j < 3; i = ++j) {
results.push(vr[i] = ab[i] + c[i] + d[i]);
}
return results;
};
RotQuat.setTRMat4x4FromQV = function(m, qv) {
return this._setTRMatFromQV(m, qv, true, false, true);
};
RotQuat.setRotMat4x4FromQV = function(m, qv) {
return this._setTRMatFromQV(m, qv, true, false, false);
};
RotQuat.setRotMat3x3FromQV = function(m, qv) {
return this._setTRMatFromQV(m, qv, true, true);
};
RotQuat.setRotMatRows3x4FromQV = function(m, qv) {
return this._setTRMatFromQV(m, qv, false, false, false);
};
RotQuat.setRotMat4x4TransposeFromQV = function(m, qv) {
this._setTRMatFromQV(m, qv, false, false, true);
m[12] = m[13] = m[14] = 0;
return m;
};
RotQuat._setTRMatFromQV = function(m, qv, m_is_col_maj, m_is_3x3, do_t_4x4) {
var WX_2, WY_2, WZ_2, XX_2, XY_2, XZ_2, X_2, YY_2, YZ_2, Y_2, ZZ_2, Z_2, m00, m01, m02, m10, m11, m12, m20, m21, m22, ww, xx, yy, zz;
xx = qv[0], yy = qv[1], zz = qv[2], ww = qv[3];
X_2 = xx + xx;
Y_2 = yy + yy;
Z_2 = zz + zz;
WX_2 = ww * X_2;
WY_2 = ww * Y_2;
WZ_2 = ww * Z_2;
XX_2 = xx * X_2;
XY_2 = xx * Y_2;
XZ_2 = xx * Z_2;
YY_2 = yy * Y_2;
YZ_2 = yy * Z_2;
ZZ_2 = zz * Z_2;
m00 = 1 - YY_2 - ZZ_2;
m01 = XY_2 - WZ_2;
m02 = XZ_2 + WY_2;
m10 = XY_2 + WZ_2;
m11 = 1 - XX_2 - ZZ_2;
m12 = YZ_2 - WX_2;
m20 = XZ_2 - WY_2;
m21 = YZ_2 + WX_2;
m22 = 1 - XX_2 - YY_2;
if (m_is_col_maj) {
if (m_is_3x3) {
m[0] = m00;
m[1] = m10;
m[2] = m20;
m[3] = m01;
m[4] = m11;
m[5] = m21;
m[6] = m02;
m[7] = m12;
m[8] = m22;
} else {
m[0] = m00;
m[1] = m10;
m[2] = m20;
m[4] = m01;
m[5] = m11;
m[6] = m21;
m[8] = m02;
m[9] = m12;
m[10] = m22;
if (do_t_4x4) {
m[12] = m[13] = m[14] = 0;
m[15] = 1;
}
}
} else {
m[0] = m00;
m[1] = m01;
m[2] = m02;
m[4] = m10;
m[5] = m11;
m[6] = m12;
m[8] = m20;
m[9] = m21;
m[10] = m22;
if (do_t_4x4) {
m[3] = m[7] = m[11] = 0;
m[15] = 1;
}
}
return m;
};
RotQuat.from_xyzw = function(x, y, z, w) {
var q;
q = new RQ;
this.setQV_xyzw(q.xyzw, x, y, z, w);
return q;
};
RotQuat.fromQV = function(qv) {
var q;
q = new RQ;
this.setQV(q.xyzw, qv);
return q;
};
RotQuat.fromRQ = function(q) {
return this.fromQV(q.xyzw);
};
RotQuat.fromRot = function(axis, angle) {
var q;
q = new RQ;
q.setFromAxisAngle(axis, angle);
return q;
};
RotQuat.create = function() {
return this.from_xyzw(0, 0, 0, 1);
};
RotQuat.fromRPY = function(roll, pitch, yaw) {
var q;
q = new RQ;
q.setFromAxisRotations(roll, pitch, yaw);
return q;
};
RotQuat.slerp = function(q, qa, qb, T) {
return this.slerpQV(q.xyzw, qa.xyzw, qb.xyzw, T);
};
RotQuat.DEGS_TO_RADS = Math.PI / 180;
RotQuat.RADS_TO_DEGS = 180 / Math.PI;
RotQuat.ZERO = RotQuat.from_xyzw(0, 0, 0, 0);
RotQuat.IDENTITY = new RQ;
RotQuat.ROT_NEG_PI_BY_2_ON_Z = RotQuat.from_xyzw(0, 0, -Math.SQRT1_2, Math.SQRT1_2);
RotQuat.prototype.copyXYZW = function() {
return RQ.copyOfQV(this.xyzw);
};
RotQuat.prototype.toQV = function(xyzw) {
return RQ.setQV(xyzw, this.xyzw);
};
RotQuat.prototype.asString = function() {
var ref, w, x, y, z;
ref = this.xyzw, x = ref[0], y = ref[1], z = ref[2], w = ref[3];
return "<" + x + " " + y + " " + z + "; " + w + ">";
};
RotQuat.prototype.asString_n = function(n) {
return RQ.qStr(this.xyzw, n);
};
RotQuat.prototype.asString4 = function() {
return this.asString_n(4);
};
RotQuat.prototype.set_xyzw = function(x, y, z, w) {
RQ.setQV_xyzw(this.xyzw, x, y, z, w);
return this;
};
RotQuat.prototype.setVec = function(qv) {
RQ.setQV(this.xyzw, qv);
return this;
};
RotQuat.prototype.setFromRQ = function(q) {
RQ.setQV(this.xyzw, q.xyzw);
return this;
};
RotQuat.prototype.setFromAxisAngle = function(xyz, angle) {
RQ.setAxisAngleQV(this.xyzw, xyz, angle);
return this;
};
RotQuat.prototype.rotate = function(e3v) {
RQ.rotateV3(e3v.xyz, e3v.xyz, this.xyzw);
return e3v;
};
RotQuat.prototype.rotate_ = function(e3v) {
RQ.rotateV3_(e3v.xyz, e3v.xyz, this.xyzw);
return e3v;
};
/*  [UNUSED]
*   Returns the sum of this quaternion and the given one.
add: (q) -> RQ.addQV @xyzw, q.xyzw
#--
*   Returns the result of subtracting the given quaternion from this one.
subtract: (q) -> RQ.subtractQV @xyzw, q.xyzw
#-------
*   Returns the inner product of this rotation quaternion with the
*   given one.
innerProduct: (q) -> innerProductQV @xyzw, q.xyzw
#-----------
*/
RotQuat.prototype.postMultiply = function(q) {
var qp;
qp = new RQ;
RQ.setProductQV(qp.xyzw, this.xyzw, q.xyzw);
return qp;
};
RotQuat.prototype.preMultiply = function(q) {
var qp;
qp = new RQ;
RQ.setProductQV(qp.xyzw, q.xyzw, this.xyzw);
return qp;
};
RotQuat.prototype.setNegate = function() {
RQ.setNegateQV(this.xyzw);
return this;
};
RotQuat.prototype.setInvert = function() {
RQ.setConjugateQV(this.xyzw);
return this;
};
RotQuat.prototype.setPostMultiply = function(q) {
RQ.setProductQV(this.xyzw, this.xyzw, q.xyzw);
return this;
};
RotQuat.prototype.setPreMultiply = function(q) {
RQ.setProductQV(this.xyzw, q.xyzw, this.xyzw);
return this;
};
RotQuat.prototype.setScaleRot = function(T) {
var RQID;
RQID = RQ.IDENTITY;
if (T === 0) {
this.setFromRQ(RQID);
} else if (T !== 1) {
RQ.slerp(this, RQID, this, T);
} else {
}
return this;
};
RotQuat.prototype.setExtractRotX = function() {
var c, d, s;
s = this.xyzw[0];
c = this.xyzw[3];
d = Math.sqrt(s * s + c * c);
return this.set_xyzw(s / d, 0, 0, c / d);
};
RotQuat.prototype.setScaleXRotationAngle = function(scale) {
var scA;
scA = scale * (Math.atan2(this.xyzw[0], this.xyzw[3]));
this.xyzw[0] = Math.sin(scA);
return this.xyzw[3] = Math.cos(scA);
};
RotQuat.prototype.setInvertX = function() {
return this.xyzw[0] = -this.xyzw[0];
};
RotQuat.prototype.setFromRotMat3x3 = function(m) {
var DIV_4W, EPS, SQRT_T, T, dorotx, doroty, dorotz, ref, tx, ty, tz;
EPS = 1e-4;
ref = [m[0], m[4], m[8]], tx = ref[0], ty = ref[1], tz = ref[2];
T = tx + ty + tz + 1;
if (1 <= T + EPS) {
SQRT_T = Math.sqrt(T);
DIV_4W = 0.5 / SQRT_T;
this.set_xyzw((m[5] - m[7]) * DIV_4W, (m[6] - m[2]) * DIV_4W, (m[1] - m[3]) * DIV_4W, 0.5 * SQRT_T);
} else {
dorotx = doroty = dorotz = false;
if (tz <= ty) {
if (ty <= tx) {
dorotx = true;
} else {
doroty = true;
}
} else {
if (tz <= tx) {
dorotx = true;
} else {
dorotz = true;
}
}
if (dorotx) {
this._setFromMatWithXRot(m);
} else if (doroty) {
this._setFromMatWithYRot(m);
} else if (dorotz) {
this._setFromMatWithZRot(m);
}
}
return this;
};
RotQuat.prototype._setFromMatWithXRot = function(m) {
var DIV_4Wx, SQRT_Tx, Tx, ref, tx, ty, tz;
ref = [m[0], m[4], m[8]], tx = ref[0], ty = ref[1], tz = ref[2];
Tx = tx - ty - tz + 1;
SQRT_Tx = Math.sqrt(Tx);
DIV_4Wx = 0.5 / SQRT_Tx;
return this.set_xyzw(0.5 * SQRT_Tx, (m[1] + m[3]) * DIV_4Wx, (m[6] + m[2]) * DIV_4Wx, (m[5] - m[7]) * DIV_4Wx);
};
RotQuat.prototype._setFromMatWithYRot = function(m) {
var DIV_4Wy, SQRT_Ty, Ty, ref, tx, ty, tz;
ref = [m[0], m[4], m[8]], tx = ref[0], ty = ref[1], tz = ref[2];
Ty = -tx + ty - tz + 1;
SQRT_Ty = Math.sqrt(Ty);
DIV_4Wy = 0.5 / SQRT_Ty;
return this.set_xyzw((m[1] + m[3]) * DIV_4Wy, 0.5 * SQRT_Ty, (m[5] + m[7]) * DIV_4Wy, (m[6] - m[2]) * DIV_4Wy);
};
RotQuat.prototype._setFromMatWithZRot = function(m) {
var DIV_4Wz, SQRT_Tz, Tz, ref, tx, ty, tz;
ref = [m[0], m[4], m[8]], tx = ref[0], ty = ref[1], tz = ref[2];
Tz = -tx - ty + tz + 1;
SQRT_Tz = Math.sqrt(Tz);
DIV_4Wz = 0.5 / SQRT_Tz;
return this.set_xyzw((m[6] + m[2]) * DIV_4Wz, (m[5] + m[7]) * DIV_4Wz, 0.5 * SQRT_Tz, (m[1] - m[3]) * DIV_4Wz);
};
RotQuat.prototype.toTRMat4x4 = function(m) {
return RQ.setTRMat4x4FromQV(m, this.xyzw, true, false, true);
};
RotQuat.prototype.toRotMat4x4 = function(m) {
return RQ.setRotMat4x4FromQV(m, this.xyzw, true, false, false);
};
RotQuat.prototype.toRotMat3x3 = function(m) {
return RQ.setRotMat3x3FromQV(m, this.xyzw, true, true);
};
RotQuat.prototype.toRotMatRows3x4 = function(m) {
return RQ.setRotMatRows3x4FromQV(m, this.xyzw, false, false, false);
};
RotQuat.prototype.setFromAxisRotations = function(roll, pitch, yaw) {
var D2R_BY2, RPY_by2, cp, cr, cy, cycp, cysp, ref, ref1, ref2, rpy, rpyb2, sp, sr, sy, sycp, sysp;
D2R_BY2 = RQ.DEGS_TO_RADS / 2;
RPY_by2 = (function() {
var j, len, ref, results;
ref = [roll, pitch, yaw];
results = [];
for (j = 0, len = ref.length; j < len; j++) {
rpy = ref[j];
results.push(rpy * D2R_BY2);
}
return results;
})();
ref = (function() {
var j, len, results;
results = [];
for (j = 0, len = RPY_by2.length; j < len; j++) {
rpyb2 = RPY_by2[j];
results.push(Math.cos(rpyb2));
}
return results;
})(), cr = ref[0], cp = ref[1], cy = ref[2];
ref1 = (function() {
var j, len, results;
results = [];
for (j = 0, len = RPY_by2.length; j < len; j++) {
rpyb2 = RPY_by2[j];
results.push(Math.sin(rpyb2));
}
return results;
})(), sr = ref1[0], sp = ref1[1], sy = ref1[2];
ref2 = [cy * cp, sy * sp, sy * cp, cy * sp], cycp = ref2[0], sysp = ref2[1], sycp = ref2[2], cysp = ref2[3];
return this.set_xyzw(cycp * sr - sysp * cr, cysp * cr + sycp * sr, sycp * cr - cysp * sr, cycp * cr + sysp * sr);
};
RotQuat.prototype.toAxisRotations = function(rpyVec) {
var CP_CR, CP_SQ, CP_SR, CY, CY_CP, R2D, SP_NEG, SY_CP, SY_NEG, WW, W_SQ, XX, X_SQ, YY, Y_SQ, ZZ, Z_SQ, i, j, qv, ref, rpy;
qv = this.xyzw;
XX = qv[0];
YY = qv[1];
ZZ = qv[2];
WW = qv[3];
ref = [XX * XX, YY * YY, ZZ * ZZ, WW * WW], X_SQ = ref[0], Y_SQ = ref[1], Z_SQ = ref[2], W_SQ = ref[3];
CY_CP = W_SQ + X_SQ - Y_SQ - Z_SQ;
SY_CP = 2 * (XX * YY + WW * ZZ);
SP_NEG = 2 * (XX * ZZ - WW * YY);
CP_SQ = CY_CP * CY_CP + SY_CP * SY_CP;
R2D = RQ.RADS_TO_DEGS;
rpy = [0, R2D * (Math.asin(-SP_NEG)), 0];
for (i = j = 0; j < 3; i = ++j) {
rpyVec[i] = rpy[i];
}
if ((-1e-10 <= CP_SQ && CP_SQ <= 1e-10)) {
SY_NEG = 2 * (XX * YY - WW * ZZ);
CY = W_SQ - X_SQ + Y_SQ - Z_SQ;
return rpyVec[2] = R2D * Math.atan2(-SY_NEG, CY);
} else {
CP_CR = W_SQ - X_SQ - Y_SQ + Z_SQ;
CP_SR = 2 * (YY * ZZ + WW * XX);
rpyVec[0] = R2D * Math.atan2(CP_SR, CP_CR);
return rpyVec[2] = R2D * Math.atan2(SY_CP, CY_CP);
}
};
return RotQuat;
})();
cwaenv.add(RotQuat, "RotQuat");
cwaenv.fixRef("E3Vec", "RotQuat");
}).call(this);
//-------- js/Mat4.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Mat4, RQ, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
Mat4 = (function() {
function Mat4() {
throw "Mat4: cannot be instantiated.";
}
Mat4._nchk = 0;
Mat4.makeMat4 = function() {
return new Float32Array(16);
};
Mat4.makeIdMat4 = function() {
var m;
m = new Float32Array(16);
m[0] = m[5] = m[10] = m[15] = 1;
return m;
};
Mat4.setTrans = function(m, xyz) {
m[0] = m[5] = m[10] = m[15] = 1;
m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = 0;
m[12] = xyz[0], m[13] = xyz[1], m[14] = xyz[2];
return m;
};
Mat4.setTRComposeT = function(m, mtr, tx, ty, tz) {
var r00, r01, r02, r10, r11, r12, r20, r21, r22;
m[0] = r00 = mtr[0];
m[1] = r10 = mtr[1];
m[2] = r20 = mtr[2];
m[4] = r01 = mtr[4];
m[5] = r11 = mtr[5];
m[6] = r21 = mtr[6];
m[8] = r02 = mtr[8];
m[9] = r12 = mtr[9];
m[10] = r22 = mtr[10];
m[12] = mtr[12] + r00 * tx + r01 * ty + r02 * tz;
m[13] = mtr[13] + r10 * tx + r11 * ty + r12 * tz;
m[14] = mtr[14] + r20 * tx + r21 * ty + r22 * tz;
m[3] = m[7] = m[11] = 0;
m[15] = 1;
return m;
};
Mat4.setProduct = function(m, ma, mb) {
var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23, b30, b31, b32, b33;
a00 = ma[0];
a10 = ma[1];
a20 = ma[2];
a30 = ma[3];
a01 = ma[4];
a11 = ma[5];
a21 = ma[6];
a31 = ma[7];
a02 = ma[8];
a12 = ma[9];
a22 = ma[10];
a32 = ma[11];
a03 = ma[12];
a13 = ma[13];
a23 = ma[14];
a33 = ma[15];
b00 = mb[0];
b10 = mb[1];
b20 = mb[2];
b30 = mb[3];
b01 = mb[4];
b11 = mb[5];
b21 = mb[6];
b31 = mb[7];
b02 = mb[8];
b12 = mb[9];
b22 = mb[10];
b32 = mb[11];
b03 = mb[12];
b13 = mb[13];
b23 = mb[14];
b33 = mb[15];
m[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
m[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
m[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
m[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;
m[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
m[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
m[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
m[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;
m[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
m[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
m[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
m[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;
m[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;
m[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;
m[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;
m[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;
return m;
};
Mat4.setFrustum = function(m, xlo, xhi, ylo, yhi, near, far) {
var xlen, ylen, zlen;
xlen = xhi - xlo;
ylen = yhi - ylo;
zlen = far - near;
m[0] = 2 * near / xlen;
m[1] = m[2] = m[3] = 0;
m[5] = 2 * near / ylen;
m[4] = m[6] = m[7] = 0;
m[8] = (xhi + xlo) / xlen;
m[9] = (yhi + ylo) / ylen;
m[10] = -(far + near) / zlen;
m[11] = -1;
m[14] = -2 * far * near / zlen;
m[12] = m[13] = m[15] = 0;
return m;
};
Mat4.setPerspective = function(m, fovy, aspect, near, far) {
var xhi, yhi;
yhi = near * (Math.tan(0.5 * fovy * RQ.DEGS_TO_RADS));
xhi = aspect * yhi;
return this.setFrustum(m, -xhi, xhi, -yhi, yhi, near, far);
};
Mat4.setLookAt = function(m, eye, cor, upu) {
var ce, laxu, layu, lazu;
ce = V3.subtractV3(eye, cor);
lazu = V3.normalizeV3(ce);
laxu = V3.unitCrossProductV3(upu, lazu);
layu = V3.crossProductV3(lazu, laxu);
m[0] = laxu[0], m[4] = laxu[1], m[8] = laxu[2];
m[12] = -(V3.dotProductV3(laxu, eye));
m[1] = layu[0], m[5] = layu[1], m[9] = layu[2];
m[13] = -(V3.dotProductV3(layu, eye));
m[2] = lazu[0], m[6] = lazu[1], m[10] = lazu[2];
m[14] = -(V3.dotProductV3(lazu, eye));
m[3] = m[7] = m[11] = 0;
m[15] = 1;
return m;
};
return Mat4;
})();
cwaenv.add(Mat4, "Mat4");
}).call(this);
//-------- js/TRXform.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var RQ, TRXform, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
TRXform = (function() {
var TRX;
function TRXform(_t, _r) {
this._t = _t;
this._r = _r;
}
TRX = TRXform;
TRXform.fromTRX = function(trx) {
return this.fromTR(trx._t, trx._r);
};
TRXform.fromTR = function(t, r) {
return this.fromTRV(t.xyz, r.xyzw);
};
TRXform.fromTRV = function(tv, rv) {
var r, ref, t;
ref = [V3.fromV3(tv), RQ.fromQV(rv)], t = ref[0], r = ref[1];
return new TRX(t, r);
};
TRXform.create = function() {
return new TRX(V3.create(), new RQ);
};
TRXform.setMat4x4Rot = function(m, r) {
return r.toRotMat4x4(m);
};
TRXform.setMat4x4Trans = function(m, t) {
var ref, x, y, z;
ref = t.xyz, x = ref[0], y = ref[1], z = ref[2];
m[12] = x;
m[13] = y;
m[14] = z;
m[15] = 1;
return m;
};
TRXform.setRowsMat3x4Rot = function(m, r) {
return r.toRotMatRows3x4(m);
};
TRXform.setRowsMat3x4Trans = function(m, t) {
var ref, x, y, z;
ref = t.xyz, x = ref[0], y = ref[1], z = ref[2];
m[3] = x;
m[7] = y;
m[11] = z;
return m;
};
TRXform.prototype.trans = function() {
return this._t;
};
TRXform.prototype.rot = function() {
return this._r;
};
TRXform.prototype.toStr = function() {
return "trans=" + (this._t.asString4()) + "  rot=" + (this._r.asString4());
};
TRXform.prototype.asStr = function() {
return this.toStr();
};
TRXform.prototype.setTR = function(t, r) {
this._t = t;
this._r = r;
return this;
};
TRXform.prototype.setT = function(t) {
this._t = t;
return this;
};
TRXform.prototype.setR = function(r) {
this._r = r;
return this;
};
TRXform.prototype.copyTRX = function(trx) {
return this.copyTR(trx._t, trx._r);
};
TRXform.prototype.copyTR = function(t, r) {
this._t.setFromE3V(t);
this._r.setFromRQ(r);
return this;
};
TRXform.prototype.copyT = function(t) {
this._t.setFromE3V(t);
return this;
};
TRXform.prototype.copyR = function(rv) {
this._r.setFromRQ(r);
return this;
};
TRXform.prototype.copyTRV = function(tv, rv) {
V3.setV3(this._t.xyz, tv);
RQ.setQV(this._r.xyzw, rv);
return this;
};
TRXform.prototype.copyTV = function(tv) {
V3.setV3(this._t.xyz, tv);
return this;
};
TRXform.prototype.copyRV = function(rv) {
RQ.setQV(this._r.xyzw, rv);
return this;
};
TRXform.prototype.setPostStar = function(trx) {
this._t.setAdd(this._r.rotate(V3.fromE3V(trx._t)));
this._r.setPostMultiply(trx._r);
return this;
};
TRXform.prototype.setPreStar = function(trx) {
(this._t.setRotate(trx._r)).setAdd(trx._t);
this._r.setPreMultiply(trx._r);
return this;
};
TRXform.prototype.setPostStarRot = function(rq) {
this._r.setPostMultiply(rq);
return this;
};
TRXform.prototype.setPreStarRot = function(rq) {
this._t.setRotate(rq);
this._r.setPreMultiply(rq);
return this;
};
TRXform.prototype.setInvert = function() {
this._r.setInvert();
(this._t.setNegate()).setRotate(this._r);
return this;
};
TRXform.prototype.inverse = function() {
return (TRX.fromTRX(this)).setInvert();
};
TRXform.prototype.transform = function(e3v) {
return (this._r.rotate(e3v)).setAdd(this._t);
};
TRXform.prototype.convertToMat4x4 = function(m) {
m[3] = m[7] = m[11] = 0;
TRX.setMat4x4Trans(m, this._t);
return TRX.setMat4x4Rot(m, this._r);
};
TRXform.prototype.convertToRowsMat3x4 = function(m) {
TRX.setRowsMat3x4Trans(m, this._t);
return TRX.setRowsMat3x4Rot(m, this._r);
};
TRXform.prototype.makeMat4x4 = function() {
var m;
m = new Float32Array(16);
return this.convertToMat4x4(m);
};
return TRXform;
})();
cwaenv.add(TRXform, "TRXform");
}).call(this);
//-------- js/AvDataAccess.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AvDataAccess, console, cwaenv, document, log, setTimeout, zip;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
zip = this.zip;
log = console.log.bind(console);
AvDataAccess = (function() {
function AvDataAccess(getAvURL, avName, avDefHandler) {
this.getAvURL = getAvURL;
this.avName = avName;
this.avDefHandler = avDefHandler;
this.avDataView = false;
this.avItemsReady = false;
this.initAvItemData();
this.AsynchAvJARScan();
}
AvDataAccess.STD_JARP_ITEM_TAG_MAP = {
"asd.xml": "asd",
"avatardef.jarp": "avDef",
"avatardef.arp": "avDef",
"config.xml": "config",
"nonmanuals.xml": "nonManuals"
};
AvDataAccess.IS_PNG = function(ename) {
return /.+\.png$/.test(ename);
};
AvDataAccess.prototype.initAvItemData = function() {
var aitmap, ename, ref, tag;
aitmap = {};
ref = AvDataAccess.STD_JARP_ITEM_TAG_MAP;
for (ename in ref) {
tag = ref[ename];
aitmap[ename] = tag;
}
this.avItemTagMap = aitmap;
this.pngEntries = {};
return void 0;
};
/*
zip.js
------
Readers:
zip.TextReader( txt )
zip.BlobReader( blob )
zip.Data64URIReader( dataURI )
zip.HttpReader( url )
zip.HttpRangeReader( url )
Writers:
zip.TextWriter()
zip.BlobWriter()
zip.FileWriter( fileEntry )
zip.Data64URIWriter( [mimeString] )
* Added to the standard repertoire:
zip.DataViewWriter( bytelength )
*/
AvDataAccess.prototype._checksumdv = function(dv, prev) {
var c, i, j, ref;
if (prev == null) {
prev = 0;
}
c = prev;
for (i = j = 0, ref = dv.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
c = (((((c >>> 1) + ((c & 1) << 15)) | 0) + ((dv.getUint8(i)) & 0xff)) & 0xffff) | 0;
}
return c;
};
AvDataAccess.prototype.startZIPScan = function(zURL, entryFun, doneFun) {
var entriesFun, errorFun;
entriesFun = function(entries) {
var N, entry, i;
N = entries.length;
for (i in entries) {
entry = entries[i];
entryFun(i, entry);
}
return doneFun(N);
};
errorFun = function(error) {
log("Read error for " + zURL + ": " + error);
return doneFun();
};
return zip.createReader(new zip.HttpReader(zURL), (function(zrdr) {
return zrdr.getEntries(entriesFun);
}), errorFun);
};
AvDataAccess.prototype.AsynchAvJARScan = function() {
var N_ap, avPfx, doneAllHandler, entryHandler, jarURL;
jarURL = this.getAvURL();
avPfx = this.avName + "/";
N_ap = avPfx.length;
doneAllHandler = (function(_this) {
return function(N) {
log("AsynchAvJARScan() ended url=" + jarURL + " entries=" + N + " at " + ((new Date).toISOString()));
if (N && _this.avDefHandler) {
_this.extractAvDef();
}
return _this.avItemsReady = true;
};
})(this);
entryHandler = (function(_this) {
return function(i, entry) {
var aitag, efname, ename, szc, szu;
efname = entry.filename;
if ((efname.substring(0, N_ap)) === avPfx) {
ename = efname.substring(N_ap);
aitag = _this.avItemTagMap[ename];
if (aitag) {
_this[aitag] = entry;
} else if (AvDataAccess.IS_PNG(ename)) {
_this.pngEntries[ename] = entry;
}
szc = entry.compressedSize;
return szu = entry.uncompressedSize;
}
};
})(this);
log("AsynchAvJARScan() stated url=" + jarURL + " at " + ((new Date).toISOString()));
return this.startZIPScan(jarURL, entryHandler, doneAllHandler);
};
AvDataAccess.prototype.extractAvDef = function() {
var avEntry, dvSize;
avEntry = this.avDef;
if (this.avDef != null) {
dvSize = avEntry.uncompressedSize;
return avEntry.getData(new zip.DataViewWriter(dvSize), (function(_this) {
return function(dv) {
log("Got DataView for " + _this.avName + ": len=" + dv.byteLength + " chk=" + (_this._checksumdv(dv)) + " at " + ((new Date).toISOString()));
_this.avDataView = dv;
return typeof _this.avDefHandler === "function" ? _this.avDefHandler(_this.avName, _this.avDataView, _this.getPNGURIGenerator()) : void 0;
};
})(this));
} else {
return log("Missing definition for " + this.avName + ".");
}
};
AvDataAccess.prototype.getPNGURIGenerator = function() {
return (function(_this) {
return function(pngName) {
var pngEntry;
pngEntry = _this.pngEntries[pngName];
return function(pngHandler) {
if (pngEntry) {
pngEntry.getData(new zip.Data64URIWriter("image/png"), (function(pngURI) {
return pngHandler(pngURI);
}));
} else {
setTimeout((function() {
return pngHandler(null);
}), 0);
}
return void 0;
};
};
})(this);
};
return AvDataAccess;
})();
cwaenv.add(AvDataAccess, "AvDataAccess");
}).call(this);
//-------- js/AvDefView.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AvDefView, FourCC, RQ, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
AvDefView = (function() {
function AvDefView(av, data, pngURIGen) {
var fpsc, ref;
this.av = av;
this.data = data;
this.pngURIGen = pngURIGen;
this.i = 0;
ref = [0, 0, 25], this.ic = ref[0], this.tc = ref[1], fpsc = ref[2];
}
AvDefView.prototype.nextUbyte = function() {
var ii;
ii = this.i;
this.i += 1;
return this.data.getUint8(ii);
};
AvDefView.prototype.nextUshort = function() {
var ii;
ii = this.i;
this.i += 2;
return this.data.getUint16(ii, true);
};
AvDefView.prototype.nextUint = function() {
var ii;
ii = this.i;
this.i += 4;
return this.data.getUint32(ii, true);
};
AvDefView.prototype.nextFloat = function() {
var ii;
ii = this.i;
this.i += 4;
return this.data.getFloat32(ii, true);
};
AvDefView.prototype.nextBool = function() {
return this.nextUbyte() !== 0;
};
AvDefView.prototype.nextStr = function() {
var i, j, len, ref, ref1, str;
ref = [this.nextUint(), ""], len = ref[0], str = ref[1];
for (j = i = 0, ref1 = len; 0 <= ref1 ? i < ref1 : i > ref1; j = 0 <= ref1 ? ++i : --i) {
str += String.fromCharCode(this.nextUbyte());
}
return str;
};
AvDefView.prototype.nextStr4cc = function() {
return FourCC.fourCCInt(this.nextStr());
};
AvDefView.prototype.nextVec2 = function() {
var i, j, results;
results = [];
for (j = i = 0; i < 2; j = ++i) {
results.push(this.nextFloat());
}
return results;
};
AvDefView.prototype.nextVec3 = function() {
var j;
return V3.copyOfV3((function() {
var i, results;
results = [];
for (j = i = 0; i < 3; j = ++i) {
results.push(this.nextFloat());
}
return results;
}).call(this));
};
AvDefView.prototype.nextQuat = function() {
var j;
return RQ.copyOfQV((function() {
var i, results;
results = [];
for (j = i = 0; i < 4; j = ++i) {
results.push(this.nextFloat());
}
return results;
}).call(this));
};
AvDefView.prototype.nextMorphSet = function() {
var ms, nml, ost, vtx, wgt;
vtx = this.nextUint();
wgt = this.nextFloat();
ost = this.nextVec3();
nml = this.nextVec3();
return ms = {
vertex: vtx,
weight: wgt,
offset: ost,
normal: nml
};
};
AvDefView.prototype.nextCASMorph = function() {
var amt, id4, morph;
id4 = this.nextUint();
amt = this.nextFloat();
return morph = {
id4cc: id4,
amount: amt
};
};
AvDefView.prototype.nextCASTRSet = function() {
var id4, rtn, trn, trset;
id4 = this.nextUint();
trn = this.nextVec3();
rtn = this.nextQuat();
return trset = {
id4cc: id4,
trans: trn,
rot: rtn
};
};
AvDefView.prototype.resetCASTiming = function(fps) {
var ref;
return ref = [0, 0, fps], this.ic = ref[0], this.tc = ref[1], this.fpsc = ref[2], ref;
};
AvDefView.prototype.nextCASFrame = function() {
var bns, dur, frame, icur, inxt, m, mphs, nm, nt, ref, s, tcur, tnxt;
inxt = this.ic + 1;
tnxt = inxt * (1000 / this.fpsc);
ref = [this.ic, this.tc, tnxt - this.tc, inxt, tnxt], icur = ref[0], tcur = ref[1], dur = ref[2], this.ic = ref[3], this.tc = ref[4];
nm = this.nextUint();
mphs = (function() {
var i, ref1, results;
results = [];
for (m = i = 0, ref1 = nm; 0 <= ref1 ? i < ref1 : i > ref1; m = 0 <= ref1 ? ++i : --i) {
results.push(this.nextCASMorph());
}
return results;
}).call(this);
nt = this.nextUint();
bns = (function() {
var i, ref1, results;
results = [];
for (s = i = 0, ref1 = nt; 0 <= ref1 ? i < ref1 : i > ref1; s = 0 <= ref1 ? ++i : --i) {
results.push(this.nextCASTRSet());
}
return results;
}).call(this);
return frame = {
time: tcur,
duration: dur,
morphs: mphs,
bones: bns
};
};
AvDefView.prototype.nextSkelBone = function() {
var bone, id4, iix, len, pr4, rtn, trn;
id4 = this.nextUint();
pr4 = this.nextUint();
trn = this.nextVec3();
rtn = this.nextQuat();
iix = this.nextQuat();
len = this.nextFloat();
return bone = {
id4cc: id4,
parent4cc: pr4,
trans: trn,
rot: rtn,
invInitXRot: iix,
length: len
};
};
AvDefView.prototype.checkBytes = function(lo, n, pfx) {
var bhex, i, ihex, k, lpad, ref, ref1, str, thisadv;
thisadv = this;
lpad = function(s, w) {
var i, ixs, ns, ref, ref1, ref2, ss;
ref = [s, s.length], ss = ref[0], ns = ref[1];
if (ns < w) {
for (ixs = i = ref1 = ns, ref2 = w; ref1 <= ref2 ? i < ref2 : i > ref2; ixs = ref1 <= ref2 ? ++i : --i) {
ss = "0" + ss;
}
}
return ss;
};
bhex = function(b) {
return lpad(b.toString(16), 2);
};
ihex = function(z) {
return lpad(z.toString(16), 8);
};
str = "";
for (k = i = ref = lo, ref1 = lo + n; ref <= ref1 ? i < ref1 : i > ref1; k = ref <= ref1 ? ++i : --i) {
str += (bhex(this.data.getUint8(k))) + " ";
}
return log((ihex(lo)) + " " + (pfx || '') + ": " + str);
};
AvDefView.prototype.bin2str = function(getfun, lo, n) {
var k, parts;
parts = (function() {
var i, ref, ref1, results;
results = [];
for (k = i = ref = lo, ref1 = lo + n; ref <= ref1 ? i < ref1 : i > ref1; k = ref <= ref1 ? ++i : --i) {
results.push(String.fromCharCode(getfun(k)));
}
return results;
})();
return parts.join("");
};
AvDefView.prototype.base64Str = function(getfun, lo, n, pfx) {
var chars, k;
chars = (function() {
var i, ref, ref1, results;
results = [];
for (k = i = ref = lo, ref1 = lo + n; ref <= ref1 ? i < ref1 : i > ref1; k = ref <= ref1 ? ++i : --i) {
results.push(String.fromCharCode(getfun(k)));
}
return results;
})();
return window.btoa(chars.join(""));
};
return AvDefView;
})();
cwaenv.add(AvDefView, "AvDefView");
}).call(this);
//-------- js/AvatarCamera.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AvatarCamera, M4, RQ, V3, console, cwaenv, document, log, setTimeout,
bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
M4 = cwaenv.get("Mat4");
AvatarCamera = (function() {
function AvatarCamera(gl, camdata, yadj, FROM_METRES) {
this.gl = gl;
this.FROM_METRES = FROM_METRES;
this.touchmove = bind(this.touchmove, this);
this.touchend = bind(this.touchend, this);
this.touchstart = bind(this.touchstart, this);
this.X_UNIT = V3.makeV3(1, 0, 0);
this.Y_UNIT = V3.makeV3(0, 1, 0);
this.viewMat = AvatarCamera.makeIdTRMat();
this.projMat = AvatarCamera.makeIdTRMat();
this.viewWidth = -1;
this.viewHeight = -1;
this.Z_NEAR = 0.05;
this.Z_FAR = 500;
this.FOV = camdata[5];
this.qCamRot = AvatarCamera.createRotation(this.Y_UNIT, 0);
this.orbitRadius = camdata[2];
this.camTarget = V3.makeV3(camdata[0], camdata[1] + yadj, 0);
this.initCamRots = [camdata[3], -camdata[4]];
this.camEye = V3.make3Vec();
this.camEyeR = V3.make3Vec();
this.camTargetR = V3.make3Vec();
this.dragMode = -1;
this.shiftDown = false;
this.ctrlDown = false;
this.prevMouseXY = [0, 0];
this.newMouseXY = [0, 0];
this.prevTouchXY = [0, 0];
this.newTouchXY = [0, 0];
this.SCALE_TIME = 200;
this.DRAG_SENSITIVITY = 0.7;
this.DELTA_DIST_SCALE = 0.01;
}
AvatarCamera.DEGS_TO_RADS = RQ.DEGS_TO_RADS;
AvatarCamera.createRotation = function(axis, angle) {
return RQ.setAxisAngleQV(RQ.makeQV(0, 0, 0, 0), axis, angle);
};
AvatarCamera.makeIdTRMat = function() {
var m;
m = new Float32Array(16);
m[0] = m[5] = m[10] = m[15] = 1;
return m;
};
AvatarCamera.prototype.getViewMatrix = function() {
return this.viewMat;
};
AvatarCamera.prototype.getProjMatrix = function() {
return this.projMat;
};
AvatarCamera.prototype.update = function(dt, w, h) {
var dts, dx, dxm, dy, dym;
this.checkUpdateViewport(w, h);
if (0 <= this.dragMode) {
dts = this.SCALE_TIME * dt;
dx = this.newMouseXY[0] - this.prevMouseXY[0] + this.newTouchXY[0] - this.prevTouchXY[0];
dy = this.newMouseXY[1] - this.prevMouseXY[1] + this.newTouchXY[1] - this.prevTouchXY[1];
dx = 0 < dx ? Math.min(dts, dx) : Math.max(-dts, dx);
dy = 0 < dy ? Math.min(dts, dy) : Math.max(-dts, dy);
dxm = dx * this.DRAG_SENSITIVITY;
dym = dy * this.DRAG_SENSITIVITY;
if (this.dragMode === 0) {
this.applyRotsOnVertAndHoriz(-dxm, 0);
this.orbitRadius -= dy * this.DELTA_DIST_SCALE;
} else if (this.dragMode === 1) {
this.applyRotsOnVertAndHoriz(-dxm, -dym);
} else if (this.dragMode === 2) {
V3.setAddV3(this.camTarget, [0, dy * this.DELTA_DIST_SCALE, 0]);
}
this.prevMouseXY = this.newMouseXY;
this.prevTouchXY = this.newTouchXY;
return this.updateViewMatrix();
}
};
AvatarCamera.prototype.setShift = function(flag) {
return this.shiftDown = Boolean(flag);
};
AvatarCamera.prototype.setCtrl = function(flag) {
return this.ctrlDown = Boolean(flag);
};
AvatarCamera.prototype.mouseover = function(evt) {};
AvatarCamera.prototype.mouseout = function(evt) {
return this.mouseup();
};
AvatarCamera.prototype.mousedown = function(evt) {
this.setShift(evt.shiftKey);
this.setCtrl(evt.ctrlKey || evt.metaKey);
this.dragMode = this.shiftDown ? 1 : this.ctrlDown ? 2 : 0;
this.prevMouseXY = [evt.screenX, evt.screenY];
return this.mousemove(evt);
};
AvatarCamera.prototype.mouseup = function() {
return this.dragMode = -1;
};
AvatarCamera.prototype.mousemove = function(evt) {
this.setShift(evt.shiftKey);
this.setCtrl(evt.ctrlKey || evt.metaKey);
if (0 <= this.dragMode) {
return this.newMouseXY = [evt.screenX, evt.screenY];
}
};
AvatarCamera.prototype.touchstart = function(evt) {
this.dragMode = Math.min(evt.touches.length - 1, 2);
this.prevTouchXY = [evt.touches[0].pageX, evt.touches[0].pageY];
return this.touchmove(evt);
};
AvatarCamera.prototype.touchend = function(evt) {
return this.dragMode = -1;
};
AvatarCamera.prototype.touchmove = function(evt) {
evt.preventDefault();
evt.stopPropagation();
if (0 <= this.dragMode) {
return this.newTouchXY = [evt.touches[0].pageX, evt.touches[0].pageY];
}
};
AvatarCamera.prototype.zVecFromViewMat = function(zXYZ, m4) {
return V3.setV3_xyz(zXYZ, m4[2], m4[6], m4[10]);
};
AvatarCamera.prototype.applyRotsOnVertAndHoriz = function(vdegs, hdegs) {
var DEGS_TO_RADS, qrotH, qrotV;
DEGS_TO_RADS = AvatarCamera.DEGS_TO_RADS;
if (vdegs !== 0) {
qrotV = AvatarCamera.createRotation(this.Y_UNIT, vdegs * DEGS_TO_RADS);
RQ.setProductQV(this.qCamRot, qrotV, this.qCamRot);
}
if (hdegs !== 0) {
qrotH = AvatarCamera.createRotation(this.X_UNIT, hdegs * DEGS_TO_RADS);
RQ.setProductQV(this.qCamRot, this.qCamRot, qrotH);
}
return RQ.setRotMat4x4TransposeFromQV(this.viewMat, this.qCamRot);
};
AvatarCamera.prototype.checkUpdateViewport = function(w, h) {
var crots;
crots = this.initCamRots;
if (crots) {
this.applyRotsOnVertAndHoriz(crots[0], crots[1]);
this.initCamRots = null;
this.updateViewMatrix();
}
if (this.viewWidth !== w || this.viewHeight !== h) {
this.viewWidth = w;
this.viewHeight = h;
return this.setProjMatrix();
}
};
AvatarCamera.prototype.setProjMatrix = function() {
var h, szFar, szNear, w;
w = this.viewWidth;
h = this.viewHeight;
szNear = this.Z_NEAR * this.FROM_METRES;
szFar = this.Z_FAR * this.FROM_METRES;
return M4.setPerspective(this.projMat, this.FOV, w / h, szNear, szFar);
};
AvatarCamera.prototype.updateViewMatrix = function() {
this.zVecFromViewMat(this.camEye, this.viewMat);
V3.setScaleV3(this.camEye, this.orbitRadius);
V3.setAddV3(this.camEye, this.camTarget);
V3.setV3(this.camEyeR, this.camEye);
V3.setV3(this.camTargetR, this.camTarget);
V3.setScaleV3(this.camEyeR, this.FROM_METRES);
V3.setScaleV3(this.camTargetR, this.FROM_METRES);
return M4.setLookAt(this.viewMat, this.camEyeR, this.camTargetR, this.Y_UNIT);
};
return AvatarCamera;
})();
cwaenv.add(AvatarCamera, "AvatarCamera");
}).call(this);
//-------- js/CASTRSet.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CASTRSet, FourCC, RQ, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
CASTRSet = (function() {
function CASTRSet() {
this.fourCCName = 0;
this.rotation = [0, 0, 0, 1];
this.translation = [0, 0, 0];
}
CASTRSet.fromJSON = function(jsntrset) {
var trset;
trset = new CASTRSet;
trset.setFromJSON(jsntrset);
return trset;
};
CASTRSet.fromXML = function(boneel) {
var trset;
trset = new CASTRSet;
trset.setFromXML(boneel);
return trset;
};
CASTRSet.fromBin = function(avdv) {
var trset;
trset = new CASTRSet;
trset.setFromBin(avdv);
return trset;
};
CASTRSet.create = function(name4cc, rot, trans) {
var trset;
trset = new CASTRSet;
trset.setFrom(name4cc, rot, trans);
return trset;
};
CASTRSet.createFromStr = function(name4ccstr, rot, trans) {
var trset;
trset = new CASTRSet;
trset.setFromStr(name4ccstr, rot, trans);
return trset;
};
CASTRSet.equalTrans = function(ta, tb) {
return ta[0] === tb[0] && ta[1] === tb[1] && ta[2] === tb[2];
};
CASTRSet.approxEq = function(x, y) {
var DIFF, EPS, SIZE;
EPS = 5e-5;
DIFF = Math.abs(x - y);
SIZE = Math.max(Math.abs(x), Math.abs(y));
if (SIZE <= 1) {
return DIFF < EPS;
} else {
return DIFF / SIZE < EPS;
}
};
CASTRSet.approxEqTrans = function(ta, tb) {
var aeq, i;
aeq = (function() {
var j, results;
results = [];
for (i = j = 0; j < 3; i = ++j) {
results.push(this.approxEq(ta[i], tb[i]));
}
return results;
}).call(this);
return aeq[0] && aeq[1] && aeq[2];
};
CASTRSet.approxEqRots = function(ra, rb) {
var aeq, i;
aeq = (function() {
var j, results;
results = [];
for (i = j = 0; j < 4; i = ++j) {
results.push(this.approxEq(ra[i], rb[i]));
}
return results;
}).call(this);
return aeq[0] && aeq[1] && aeq[2] && aeq[3];
};
CASTRSet.prototype.setFromJSON = function(jsntrset) {
this.fourCCName = FourCC.fourCCInt(jsntrset.id4cc);
if (jsntrset.rot) {
RQ.setQV(this.rotation, jsntrset.rot);
}
if (jsntrset.trans) {
return V3.setV3(this.translation, jsntrset.trans);
}
};
CASTRSet.prototype.setFromXML = function(boneel) {
var bname, brot, btrans, c, pel, rel, xyz, xyzw;
btrans = null;
brot = null;
bname = boneel.getAttribute("name");
pel = (boneel.getElementsByTagName("position")).item(0);
rel = (boneel.getElementsByTagName("qRotation")).item(0);
if (pel) {
xyz = ["x", "y", "z"];
btrans = (function() {
var j, len, results;
results = [];
for (j = 0, len = xyz.length; j < len; j++) {
c = xyz[j];
results.push(Number(pel.getAttribute(c)));
}
return results;
})();
}
if (rel) {
xyzw = ["x", "y", "z", "w"];
brot = (function() {
var j, len, results;
results = [];
for (j = 0, len = xyzw.length; j < len; j++) {
c = xyzw[j];
results.push(Number(rel.getAttribute(c)));
}
return results;
})();
}
return this.setFromStr(bname, brot, btrans);
};
CASTRSet.prototype.setFromBin = function(avdv) {
var id4cc, rot, trans, xyz, xyzw;
id4cc = avdv.nextUint();
trans = (function() {
var j, len, ref, results;
ref = avdv.nextVec3();
results = [];
for (j = 0, len = ref.length; j < len; j++) {
xyz = ref[j];
results.push(xyz);
}
return results;
})();
rot = (function() {
var j, len, ref, results;
ref = avdv.nextQuat();
results = [];
for (j = 0, len = ref.length; j < len; j++) {
xyzw = ref[j];
results.push(xyzw);
}
return results;
})();
return this.setFrom(id4cc, rot, trans);
};
CASTRSet.prototype.setFromStr = function(name, rot, trans) {
return this.setFrom(FourCC.fourCCInt(name), rot, trans);
};
CASTRSet.prototype.setFrom = function(name4cc, rot, trans) {
this.fourCCName = name4cc;
this.rotation = rot;
return this.translation = trans;
};
CASTRSet.prototype.setFromTRSet = function(trs) {
this.fourCCName = trs.getFourCC();
RQ.setQV(this.rotation, trs.getRotation());
return V3.setV3(this.translation, trs.getTranslation());
};
CASTRSet.prototype.has4CCName = function(nm4cc) {
return this.fourCCName === nm4cc;
};
CASTRSet.prototype.getFourCC = function() {
return this.fourCCName;
};
CASTRSet.prototype.getTranslation = function() {
return this.translation;
};
CASTRSet.prototype.getRotation = function() {
return this.rotation;
};
CASTRSet.prototype.set = function(trs) {
return this.setFromTRSet(trs);
};
CASTRSet.prototype.setFourCC = function(fcctag) {
return this.fourCCName = fcctag;
};
CASTRSet.prototype.setRotation = function(trs) {
return this.rotation = RQ.copyOfQV(trs.getRotation());
};
CASTRSet.prototype.setTranslation = function(trs) {
return this.translation = V3.copyOfV3(trs.getTranslation());
};
CASTRSet.prototype.hashCode = function() {
var rhc, thc;
thc = this.translation === null ? 0 : this.translation.hashCode();
rhc = this.rotation === null ? 0 : this.rotation.hashCode();
return this.fourCCName + thc + rhc;
};
CASTRSet.prototype.matches = function(other) {
var FOURCC, ROT, TRANS, TRS, eq;
TRS = CASTRSet;
eq = this === other;
if (!eq && (other instanceof TRS)) {
FOURCC = other.getFourCC();
TRANS = other.getTranslation();
ROT = other.getRotation();
if (this.fourCCName === FOURCC) {
if (TRS.equalTrans(this.translation, TRANS)) {
if (TRS.approxEqRots(this.rotation, ROT)) {
eq = true;
}
}
}
}
return eq;
};
return CASTRSet;
})();
cwaenv.add(CASTRSet, "CASTRSet");
}).call(this);
//-------- js/CASMorph.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CASMorph, FourCC, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
CASMorph = (function() {
function CASMorph() {
this.fourCCName = 0;
this.amount = 0;
}
CASMorph.NO_MORPHS = [];
CASMorph.fromJSON = function(jsnmorph) {
var morph;
morph = new CASMorph;
morph.setFromJSON(jsnmorph);
return morph;
};
CASMorph.fromXML = function(mrphel) {
var morph;
morph = new CASMorph;
morph.setFromXML(mrphel);
return morph;
};
CASMorph.fromBin = function(avdv) {
var morph;
morph = new CASMorph;
morph.setFromBin(avdv);
return morph;
};
CASMorph.create = function(name4cc, value) {
var morph;
morph = new CASMorph;
morph.set(name4cc, value);
return morph;
};
CASMorph.createFromStr = function(name4ccstr, value) {
var morph;
morph = new CASMorph;
morph.setFromStr(name4ccstr, value);
return morph;
};
CASMorph.prototype.setFromJSON = function(jsnmrph) {
this.fourCCName = FourCC.fourCCInt(jsnmrph.id4cc);
return this.amount = jsnmrph.amount;
};
CASMorph.prototype.setFromXML = function(mrphel) {
return this.setFromStr(mrphel.getAttribute("name"), Number(mrphel.getAttribute("amount")));
};
CASMorph.prototype.setFromBin = function(avdv) {
this.fourCCName = avdv.nextUint();
return this.amount = avdv.nextFloat();
};
CASMorph.prototype.setFromStr = function(name, value) {
return this.set(FourCC.fourCCInt(name), value);
};
CASMorph.prototype.set = function(name4cc, value) {
this.fourCCName = name4cc;
return this.amount = value;
};
CASMorph.prototype.setFromMorph = function(morph) {
this.fourCCName = morph.getName();
return this.amount = morph.getAmount();
};
CASMorph.prototype.hasName = function(nm4cc) {
return this.fourCCName === nm4cc;
};
CASMorph.prototype.getName = function() {
return this.fourCCName;
};
CASMorph.prototype.getFourCC = function() {
return this.fourCCName;
};
CASMorph.prototype.getFourCCStr = function() {
return FourCC.fourCCStr(this.fourCCName);
};
CASMorph.prototype.getAmount = function() {
return this.amount;
};
CASMorph.prototype._makeText = function(amtstr) {
var NX, nmstr, pad;
nmstr = FourCC.fourCCString(this.fourCCName);
NX = 4 - nmstr.length;
pad = 0 < NX ? "    ".slice(0, NX) : "";
return "" + nmstr + pad + "  " + this.amtstr;
};
CASMorph.prototype.asText = function() {
return this._makeText("" + this.amount);
};
CASMorph.prototype.asText4 = function() {
return this._makeText("" + (this.amount.toFixed(4)));
};
return CASMorph;
})();
cwaenv.add(CASMorph, "CASMorph");
}).call(this);
//-------- js/CASFrame.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CASFrame, CASMorph, CASTRSet, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
CASTRSet = cwaenv.get("CASTRSet");
CASMorph = cwaenv.get("CASMorph");
CASFrame = (function() {
function CASFrame() {
this.timeStamp = this.duration = 0;
this.trSets = this.morphs = this.trSetMap = this.morphMap = null;
}
CASFrame.MAP_LO_SIZE = 8;
CASFrame.NO_MORPHS = [];
CASFrame.fromJSON = function(jsnframe) {
var frame;
frame = new CASFrame;
frame.setFromJSON(jsnframe);
return frame;
};
CASFrame.fromXML = function(frmel) {
var frame;
frame = new CASFrame;
frame.setFromXML(frmel);
return frame;
};
CASFrame.fromBin = function(avdv) {
var frame;
frame = new CASFrame;
frame.setFromBin(avdv);
return frame;
};
CASFrame.create = function(time, dur, bones, morphs) {
var frame;
frame = new CASFrame;
frame.set(time, dur, bones, morphs);
return frame;
};
CASFrame.getFrameRate = function(frames) {
var frameok;
frameok = frames && frames.length !== 0;
if (frameok) {
return 1000 / frames[0].duration;
} else {
return 25;
}
};
CASFrame.prototype.copyCASFrame = function(frame) {
return this.copy(frame.getTime(), frame.getDuration(), frame.getTRSets(), frame.getMorphs());
};
CASFrame.prototype.copy = function(time, dur, bones, morphvec) {
return this.set(time, dur, bones.slice(), morphvec != null ? morphvec.slice() : void 0);
};
CASFrame.prototype.setCASFrameBM = function(bones, morphs) {
return this.set(-1, 0, bones, morphs);
};
CASFrame.prototype.setCASFrameTBM = function(time, bones, morphs) {
return this.set(time, 0, bones, morphs);
};
CASFrame.prototype.setFromJSON_TD = function(jsnframe, t, dur) {
this.setFromJSON(jsnframe);
this.time = t;
return this.duration = dur;
};
CASFrame.prototype.setFromJSON = function(jsnframe) {
var JMPHS, bones, morphs;
JMPHS = jsnframe.morphs;
morphs = JMPHS.length === 0 ? null : JMPHS.map(CASMorph.fromJSON);
bones = jsnframe.bones.map(CASTRSet.fromJSON);
return this.set(jsnframe.time, jsnframe.duration, bones, morphs);
};
CASFrame.prototype.setFromXML = function(frmel) {
var NB, NM, b, bones, dur, fbones, fmphs, j, k, m, morphs, ref, ref1, time;
morphs = null;
bones = [];
time = Number(frmel.getAttribute("time"));
dur = Number(frmel.getAttribute("duration"));
fmphs = frmel.getElementsByTagName("morph");
fbones = frmel.getElementsByTagName("bone");
NM = fmphs.length;
NB = fbones.length;
if (NM !== 0) {
morphs = [];
for (m = j = 0, ref = NM; 0 <= ref ? j < ref : j > ref; m = 0 <= ref ? ++j : --j) {
morphs.push(CASMorph.fromXML(fmphs.item(m)));
}
}
for (b = k = 0, ref1 = NB; 0 <= ref1 ? k < ref1 : k > ref1; b = 0 <= ref1 ? ++k : --k) {
bones.push(CASTRSet.fromXML(fbones.item(b)));
}
return this.set(time, dur, bones, morphs);
};
CASFrame.prototype.setFromBin = function(avdv) {
var b, bones, m, morphs, nBones, nMorphs;
nMorphs = avdv.nextUint();
morphs = nMorphs === 0 ? null : (function() {
var j, ref, results;
results = [];
for (m = j = 0, ref = nMorphs; 0 <= ref ? j < ref : j > ref; m = 0 <= ref ? ++j : --j) {
results.push(CASMorph.fromBin(avdv));
}
return results;
})();
nBones = avdv.nextUint();
bones = (function() {
var j, ref, results;
results = [];
for (b = j = 0, ref = nBones; 0 <= ref ? j < ref : j > ref; b = 0 <= ref ? ++j : --j) {
results.push(CASTRSet.fromBin(avdv));
}
return results;
})();
return this.set(-1, -1, bones, morphs);
};
CASFrame.prototype.set = function(time, dur, bones, morphs) {
this.timeStamp = time;
this.duration = dur;
this.trSets = bones;
this.morphs = morphs || CASMorph.NO_MORPHS;
this.makeTRSetMap();
return this.makeMorphMap();
};
CASFrame.prototype.getTime = function() {
return this.timeStamp;
};
CASFrame.prototype.getDuration = function() {
return this.duration;
};
CASFrame.prototype.getTRSets = function() {
return this.trSets;
};
CASFrame.prototype.getMorphs = function() {
return this.morphs;
};
CASFrame.prototype.getTRSet = function(bone4cc) {
return this.trSetMap[bone4cc] || null;
};
CASFrame.prototype.getMorph = function(morph4cc) {
return this.morphMap[morph4cc] || null;
};
CASFrame.prototype.setTime = function(ts) {
return this.timeStamp = ts;
};
CASFrame.prototype.adjustTime = function(tadj) {
return this.timeStamp += tadj;
};
CASFrame.prototype.setDuration = function(dur) {
return this.duration = dur;
};
CASFrame.prototype.makeTRSetMap = function() {
var NS, TRSETS, TRSMAP, i, j, ref, trs;
TRSETS = this.trSets;
NS = TRSETS.length;
TRSMAP = [];
for (i = j = 0, ref = NS; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
trs = TRSETS[i];
TRSMAP[trs.getFourCC()] = trs;
}
return this.trSetMap = TRSMAP;
};
CASFrame.prototype.makeMorphMap = function() {
var MORPHS, MPHMAP, NM, i, j, mph, ref;
MORPHS = this.morphs;
NM = MORPHS.length;
MPHMAP = [];
for (i = j = 0, ref = NM; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
mph = MORPHS[i];
MPHMAP[mph.getFourCC()] = mph;
}
return this.morphMap = MPHMAP;
};
return CASFrame;
})();
cwaenv.add(CASFrame, "CASFrame");
}).call(this);
//-------- js/Bone.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Bone, FourCC, RQ, TRX, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
TRX = cwaenv.get("TRXform");
Bone = (function() {
function Bone() {
this.parent = null;
this.fourCCName = this.parentFourCCName = 0;
this.localTrans = null;
this.localRot = null;
this.inverseInitRotationX = null;
this.length = 0;
this.doWristTwist = this.doShoulderTwist = false;
this.childBones = [];
this.globalTRX = TRX.create();
this.bindPoseTRX = TRX.create();
this.invBindPoseTRX = TRX.create();
this.skinTRX = TRX.create();
}
Bone.DEGS_TO_RADS = RQ.DEGS_TO_RADS;
Bone.RADS_TO_DEGS = RQ.RADS_TO_DEGS;
Bone.LUPA_4CC = FourCC.fourCCInt("LUPA");
Bone.RUPA_4CC = FourCC.fourCCInt("RUPA");
Bone.LLRA_4CC = FourCC.fourCCInt("LLRA");
Bone.RLRA_4CC = FourCC.fourCCInt("RLRA");
Bone.fromJSON = function(jsnbone) {
var bone;
bone = new Bone;
bone.setFromJSON(jsnbone);
return bone;
};
Bone.fromBin = function(avdv) {
var bone;
bone = new Bone;
bone.setFromBin(avdv);
return bone;
};
Bone.prototype.setFromJSON = function(jsnbone) {
var CVT4cc;
CVT4cc = FourCC.fourCCInt;
this.fourCCName = CVT4cc(jsnbone.id4cc);
this.parentFourCCName = CVT4cc(jsnbone.parent4cc);
this.localTrans = V3.copyOfV3(jsnbone.trans);
this.localRot = RQ.copyOfQV(jsnbone.rot);
this.inverseInitRotationX = jsnbone.invInitXRot;
this.length = jsnbone.length;
return this.setSlideFlags();
};
Bone.prototype.setFromBin = function(avdv) {
var xyz, xyzw;
this.fourCCName = avdv.nextUint();
this.parentFourCCName = avdv.nextUint();
this.localTrans = (function() {
var j, len, ref, results;
ref = avdv.nextVec3();
results = [];
for (j = 0, len = ref.length; j < len; j++) {
xyz = ref[j];
results.push(xyz);
}
return results;
})();
this.localRot = (function() {
var j, len, ref, results;
ref = avdv.nextQuat();
results = [];
for (j = 0, len = ref.length; j < len; j++) {
xyzw = ref[j];
results.push(xyzw);
}
return results;
})();
this.inverseInitRotationX = (function() {
var j, len, ref, results;
ref = avdv.nextQuat();
results = [];
for (j = 0, len = ref.length; j < len; j++) {
xyzw = ref[j];
results.push(xyzw);
}
return results;
})();
this.length = avdv.nextFloat();
return this.setSlideFlags();
};
Bone.prototype.setSlideFlags = function() {
var B, ID4;
B = Bone;
ID4 = this.fourCCName;
this.doShoulderTwist = ID4 === B.LUPA_4CC || ID4 === B.RUPA_4CC;
return this.doWristTwist = ID4 === B.LLRA_4CC || ID4 === B.RLRA_4CC;
};
Bone.prototype.setParent = function(prnt) {
return this.parent = prnt;
};
Bone.prototype.getGlobalTRX = function() {
return this.globalTRX;
};
Bone.prototype.getParent = function() {
return this.parent;
};
Bone.prototype.getChild = function(i) {
return this.childBones[i];
};
Bone.prototype.addChild = function(cb) {
return this.childBones.push(cb);
};
Bone.prototype.isRoot = function() {
return this.parent === null;
};
Bone.prototype.get4CC = function() {
return this.fourCCName;
};
Bone.prototype.getParent4CC = function() {
return this.parentFourCCName;
};
Bone.prototype.getLength = function() {
return this.length;
};
Bone.prototype.getLocalRot = function() {
return this.localRot;
};
Bone.prototype.getInvInitRotX = function() {
return this.inverseInitRotationX;
};
Bone.prototype.doesTwist = function() {
return this.doShoulderTwist || this.doWristTwist || this.parentDoesWristTwist();
};
Bone.prototype.parentDoesWristTwist = function() {
return this.parent !== null && (this.parent.doWristTwist());
};
Bone.prototype.doesShoulderTwist = function() {
return this.doShoulderTwist;
};
Bone.prototype.doesWristTwist = function() {
return this.doWristTwist;
};
Bone.prototype.getBindPoseTRX = function() {
return this.bindPoseTRX;
};
Bone.prototype.getInvBindPoseTRX = function() {
return this.invBindPoseTRX;
};
Bone.prototype.updateLocalTransAndRot = function(newtrs) {
this.localTrans = newtrs.getTranslation();
return this.localRot = newtrs.getRotation();
};
Bone.prototype.updateLocalRot = function(newtrs) {
return this.localRot = newtrs.getRotation();
};
Bone.prototype.computeGlobalTransforms = function() {
var child, j, len, ref, results;
this.globalTRX.copyTRV(this.localTrans, this.localRot);
if (!this.isRoot()) {
this.globalTRX.setPreStar(this.parent.getGlobalTRX());
}
ref = this.childBones;
results = [];
for (j = 0, len = ref.length; j < len; j++) {
child = ref[j];
results.push(child.computeGlobalTransforms());
}
return results;
};
Bone.prototype.generateBindPoseData = function() {
this.bindPoseTRX.copyTRX(this.globalTRX);
this.invBindPoseTRX.copyTRX(this.globalTRX);
return this.invBindPoseTRX.setInvert();
};
Bone.prototype.generateSkinMatRows = function(m) {
this.skinTRX.copyTRX(this.globalTRX);
this.skinTRX.setPostStar(this.invBindPoseTRX);
this.skinTRX.convertToRowsMat3x4(m);
return m;
};
Bone.prototype.idStr = function() {
return FourCC.fourCCStr(this.fourCCName);
};
/*-------- for debugging --------
idStr: -> FourCC.fourCCStr @fourCCName
#----
showTRMat: (tag, m) ->
#--------
SP = " "
rowStr = (i) -> RQ.qStr (m[i+4*j] for j in [0...4]), 2
id = do @idStr
log "#{id} #{tag}:"
log "        #{rowStr i}" for i in [0...4]
*/
return Bone;
})();
cwaenv.add(Bone, "Bone");
}).call(this);
//-------- js/Skeleton.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Bone, FourCC, RQ, Skeleton, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
RQ = cwaenv.get("RotQuat");
Bone = cwaenv.get("Bone");
Skeleton = (function() {
function Skeleton(usetrx, cputrx2mat) {
this.root = null;
this.bones = null;
this.boneIndicesBy4CC = null;
this.skinMatRows = null;
this.boneSkinMatRows = null;
this.USE_TRX_BONE_DATA = usetrx;
this.TEST_CPU_TRX_TO_MAT = cputrx2mat;
this.skelTexWidth = 0;
this.skelTexHeight = 0;
this.skelXformsData = null;
this.twistData = null;
this.ntdchk = 0;
this.nchk = 0;
}
Skeleton.SHOULDER_TWIST_FLAG_VALUE = 2;
Skeleton.WRIST_TWIST_FLAG_VALUE = 3;
Skeleton.ROOT4cc = FourCC.fourCCInt("ROOT");
Skeleton.create = function(jsnskel, usetrx, cputrx2mat) {
var skeleton;
skeleton = new Skeleton(usetrx, cputrx2mat);
skeleton.setFromJSON(jsnskel);
return skeleton;
};
Skeleton.fromBin = function(avdv, usetrx, cputrx2mat) {
var skeleton;
skeleton = new Skeleton(usetrx, cputrx2mat);
skeleton.setFromBin(avdv);
return skeleton;
};
Skeleton.prototype.setFromJSON = function(jsnbones) {
return this.buildSkeleton(jsnbones.length, (function(b) {
return Bone.fromJSON(jsnbones[b]);
}));
};
Skeleton.prototype.setFromBin = function(avdv) {
return this.buildSkeleton(avdv.nextUint(), (function() {
return Bone.fromBin(avdv);
}));
};
Skeleton.prototype.buildSkeleton = function(nbones, nextBoneFun) {
var b, bone, k, ref;
this.bones = new Array(nbones);
this.boneIndicesBy4CC = [];
for (b = k = 0, ref = nbones; 0 <= ref ? k < ref : k > ref; b = 0 <= ref ? ++k : --k) {
this.bones[b] = bone = nextBoneFun(b);
this.setExtraDataForBone(b, bone);
}
this.createTwistData();
return this.generateBindPoseData();
};
Skeleton.prototype.setExtraDataForBone = function(b, bone) {
var b4cc, p4cc, parentBone;
b4cc = bone.get4CC();
if (b4cc === Skeleton.ROOT4cc) {
this.root = bone;
}
this.boneIndicesBy4CC[b4cc] = b;
p4cc = bone.getParent4CC();
if (p4cc) {
parentBone = this.getBoneBy4CC(p4cc);
bone.setParent(parentBone);
return parentBone.addChild(bone);
}
};
Skeleton.prototype.calcTexSize = function(elFloats, elRows) {
var texHeight, texWidth;
texWidth = 1;
while (texWidth < elFloats) {
texWidth *= 2;
}
if (elFloats !== texWidth) {
log("calTexSize: WARNING: Element size " + elFloats + " for data as texture needs to be power of two");
}
texWidth = Math.max(4, texWidth);
texHeight = 1;
while (texWidth * texHeight < elRows * elFloats) {
texHeight *= 2;
}
return [texWidth * texHeight, texWidth / 4, texHeight];
};
Skeleton.prototype.createTwistData = function() {
var NB, SKEL, b, b4, bTwData, bone, flags, i, k, len, p4cc, parentID, ref, ref1, results, rotW, rotX, vecSize;
NB = this.bones.length;
SKEL = Skeleton;
ref = this.calcTexSize(4, NB), vecSize = ref[0], this.twistTexWidth = ref[1], this.twistTexHeight = ref[2];
this.twistData = new Float32Array(vecSize);
ref1 = this.bones;
results = [];
for (b = k = 0, len = ref1.length; k < len; b = ++k) {
bone = ref1[b];
b4 = 4 * b;
flags = 1;
if (bone.doesShoulderTwist()) {
flags *= SKEL.SHOULDER_TWIST_FLAG_VALUE;
}
if (bone.doesWristTwist()) {
flags *= SKEL.WRIST_TWIST_FLAG_VALUE;
}
p4cc = bone.getParent4CC();
parentID = p4cc === 0 ? -1 : this.boneIndicesBy4CC[p4cc];
rotX = rotW = -1;
bTwData = [rotX, rotW, parentID, flags];
results.push((function() {
var l, results1;
results1 = [];
for (i = l = 0; l < 4; i = ++l) {
results1.push(this.twistData[b4 + i] = bTwData[i]);
}
return results1;
}).call(this));
}
return results;
};
Skeleton.prototype.updateTwistData = function() {
var b, b4, bone, iirxRQ, k, len, ref, tbone, twistRQ;
twistRQ = RQ.create();
iirxRQ = RQ.create();
ref = this.bones;
for (b = k = 0, len = ref.length; k < len; b = ++k) {
bone = ref[b];
b4 = 4 * b;
if (this.twistData[b4 + 3] !== 1) {
tbone = bone;
if (bone.doesWristTwist()) {
tbone = bone.getChild(0);
}
iirxRQ.setVec(tbone.getInvInitRotX());
twistRQ.setVec(tbone.getLocalRot());
twistRQ.setExtractRotX();
twistRQ.setPostMultiply(iirxRQ);
if (bone.doesShoulderTwist()) {
twistRQ.setInvertX();
}
this.twistData[b4 + 0] = twistRQ.xyzw[0];
this.twistData[b4 + 1] = twistRQ.xyzw[3];
}
}
if (this.ntdchk < 10) {
/*
log "____  skel twist data #{@ntdchk}"
for bone,b in @bones
bStr = do bone.idStr
[tda, tdb, tdc, tdd] = (@twistData[b*4+i] for i in [0...4])
if @ntdchk is 0 or tdc is 39
tdas = RQ.fStr tda, 3;  tdbs = RQ.fStr tdb, 3
tdcs = ""+Math.floor tdc;    tdds = ""+Math.floor tdd
log "#{bStr}: #{tdas} #{tdbs} #{tdcs} #{tdds}"
*/
}
return ++this.ntdchk;
};
Skeleton.prototype.generateBindPoseData = function() {
var NB, bone, k, len, ref, ref1, vecSize;
this.root.computeGlobalTransforms();
ref = this.bones;
for (k = 0, len = ref.length; k < len; k++) {
bone = ref[k];
bone.generateBindPoseData();
}
if (this.USE_TRX_BONE_DATA) {
NB = this.bones.length;
ref1 = this.calcTexSize(16, NB), vecSize = ref1[0], this.skelTexWidth = ref1[1], this.skelTexHeight = ref1[2];
this.skelXformsData = new Float32Array(vecSize);
if (this.TEST_CPU_TRX_TO_MAT) {
this.skinMatRows = new Float32Array(this.bones.length * 3 * 4);
this.boneSkinMatRows = new Float32Array(3 * 4);
this.vsSkinMatRows = new Array(this.bones.length * 3 * 4);
}
this.setInvBindPoseTRXData();
this.updateCurGlobalPoseTRXData();
this.updateTwistData();
} else {
this.skinMatRows = new Float32Array(this.bones.length * 3 * 4);
this.boneSkinMatRows = new Float32Array(3 * 4);
this.updateSkinMatRows();
}
return void 0;
};
Skeleton.prototype.setInvBindPoseTRXData = function() {
var boneIBPFun;
boneIBPFun = function(bone) {
return bone.getInvBindPoseTRX();
};
return this._setTRXDataBuffers(0, boneIBPFun);
};
Skeleton.prototype.updateCurGlobalPoseTRXData = function() {
var boneCGPFun;
boneCGPFun = function(bone) {
return bone.getGlobalTRX();
};
this._setTRXDataBuffers(2 * 4, boneCGPFun);
if (this.TEST_CPU_TRX_TO_MAT) {
this.updateSkinMatRows();
return this.updateVSSkinMatRows();
}
};
Skeleton.prototype._setTRXDataBuffers = function(offset, btrxfun) {
var b, bone, br, brot, bt, btrans, btrx, i, k, l, len, ref, results;
ref = this.bones;
results = [];
for (b = k = 0, len = ref.length; k < len; b = ++k) {
bone = ref[b];
bt = b * 4 * 4 + offset;
br = bt + 4;
btrx = btrxfun(bone);
btrans = (btrx.trans()).xyz;
brot = (btrx.rot()).xyzw;
for (i = l = 0; l < 3; i = ++l) {
this.skelXformsData[bt + i] = btrans[i];
}
results.push((function() {
var m, results1;
results1 = [];
for (i = m = 0; m < 4; i = ++m) {
results1.push(this.skelXformsData[br + i] = brot[i]);
}
return results1;
}).call(this));
}
return results;
};
void 0;
Skeleton.prototype.updateSkinMatRows = function() {
var b, b12, bSMR, bone, i, k, l, len, len1, ref, ref1, s, sMR;
sMR = this.skinMatRows;
bSMR = this.boneSkinMatRows;
b12 = 0;
ref = this.bones;
for (b = k = 0, len = ref.length; k < len; b = ++k) {
bone = ref[b];
ref1 = bone.generateSkinMatRows(bSMR);
for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
s = ref1[i];
sMR[b12 + i] = s;
}
b12 += 3 * 4;
}
return void 0;
};
Skeleton.prototype.getBones = function() {
return this.bones;
};
Skeleton.prototype.getBonesCount = function() {
if (this.bones) {
return this.bones.length;
} else {
return 0;
}
};
Skeleton.prototype.getBoneBy4CC = function(fourcc) {
return this.bones[this.boneIndicesBy4CC[fourcc]];
};
Skeleton.prototype.getBone = function(b) {
return this.bones[b];
};
Skeleton.prototype.getBoneIndex = function(fourcc) {
return this.boneIndicesBy4CC[fourcc];
};
Skeleton.prototype.setBones = function(trsets) {
var bone, k, len, trset;
for (k = 0, len = trsets.length; k < len; k++) {
trset = trsets[k];
bone = this.getBoneBy4CC(trset.getFourCC());
if (bone) {
if (bone.isRoot()) {
bone.updateLocalTransAndRot(trset);
} else {
bone.updateLocalRot(trset);
}
}
}
this.root.computeGlobalTransforms();
if (this.USE_TRX_BONE_DATA) {
this.updateCurGlobalPoseTRXData();
return this.updateTwistData();
} else {
return this.updateSkinMatRows();
}
};
Skeleton.prototype.getSkinMatRows = function() {
return this.skinMatRows;
};
Skeleton.prototype.getSkelXformsData = function() {
return this.skelXformsData;
};
Skeleton.prototype.getSkelTexWidth = function() {
return this.skelTexWidth;
};
Skeleton.prototype.getSkelTexHeight = function() {
return this.skelTexHeight;
};
Skeleton.prototype.getBoneTwistData = function() {
return this.twistData;
};
Skeleton.prototype.getTwistTexWidth = function() {
return this.twistTexWidth;
};
Skeleton.prototype.getTwistTexHeight = function() {
return this.twistTexHeight;
};
Skeleton.prototype.getVSSkinMatRows = function() {
return this.vsSkinMatRows;
};
Skeleton.prototype.updateVSSkinMatRows = function() {
var b, b12, bone, i, i4, j, k, l, len, m, ref, vsbsmr;
vsbsmr = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
ref = this.bones;
for (b = k = 0, len = ref.length; k < len; b = ++k) {
bone = ref[b];
b12 = b * 3 * 4;
this._vsSetSkinMatRowsForBone(vsbsmr, b);
for (i = l = 0; l < 3; i = ++l) {
i4 = i * 4;
for (j = m = 0; m < 4; j = ++m) {
this.vsSkinMatRows[b12 + i4 + j] = vsbsmr[i][j];
}
}
}
return this.checkSkinningTRXs();
};
Skeleton.prototype.checkSkinningTRXs = function() {
var b, b12, bok, i, k, l, nmatch, ref, rowstr, smrb, vssmrb;
if (this.nchk === 0) {
rowstr = (function(_this) {
return function(mat, b, i) {
var base, j, row;
base = (b * 3 + i) * 4;
row = (function() {
var k, results;
results = [];
for (j = k = 0; k < 4; j = ++k) {
results.push(mat[base + j]);
}
return results;
})();
return RQ.qStr(row, 3);
};
})(this);
nmatch = 0;
for (b = k = 0, ref = this.bones.length; 0 <= ref ? k < ref : k > ref; b = 0 <= ref ? ++k : --k) {
b12 = b * 3 * 4;
smrb = (function() {
var l, results;
results = [];
for (i = l = 0; l < 12; i = ++l) {
results.push(this.skinMatRows[b12 + i]);
}
return results;
}).call(this);
vssmrb = (function() {
var l, results;
results = [];
for (i = l = 0; l < 12; i = ++l) {
results.push(this.vsSkinMatRows[b12 + i]);
}
return results;
}).call(this);
bok = true;
for (i = l = 0; l <= 12; i = ++l) {
if (1e-4 <= Math.abs(smrb[i] - vssmrb[i])) {
bok = false;
}
}
if (!bok) {
log("skin mats match FAILS for bone " + b);
}
if (bok) {
++nmatch;
}
}
log("matching skin mat count: " + nmatch + " / " + this.bones.length);
return ++this.nchk;
}
};
Skeleton.prototype._setQProd = function(qr, qa, qb) {
var i, k, rc, rd, re, va, vb, wa, wb;
va = [qa[0], qa[1], qa[2]];
vb = [qb[0], qb[1], qb[2]];
wa = qa[3];
wb = qb[3];
qr[3] = (wa * wb) - (va[0] * vb[0] + va[1] * vb[1] + va[2] * vb[2]);
rc = [wa * vb[0], wa * vb[1], wa * vb[2]];
rd = [wb * va[0], wb * va[1], wb * va[2]];
re = [va[1] * vb[2] - va[2] * vb[1], va[2] * vb[0] - va[0] * vb[2], va[0] * vb[1] - va[1] * vb[0]];
for (i = k = 0; k < 3; i = ++k) {
qr[i] = rc[i] + rd[i] + re[i];
}
return void 0;
};
Skeleton.prototype._setRotate = function(tr, t, q) {
var i, k, qc, qq, qr, qt;
qc = [-q[0], -q[1], -q[2], q[3]];
qt = [t[0], t[1], t[2], 0];
qq = [0, 0, 0, 0];
qr = [0, 0, 0, 0];
this._setQProd(qq, qt, qc);
this._setQProd(qr, q, qq);
for (i = k = 0; k < 3; i = ++k) {
tr[i] = qr[i];
}
return void 0;
};
Skeleton.prototype._setTRXProd = function(tr, rr, ta, ra, tb, rb) {
var i, k, tba;
tba = [0, 0, 0];
this._setRotate(tba, tb, ra);
for (i = k = 0; k < 3; i = ++k) {
tr[i] = ta[i] + tba[i];
}
this._setQProd(rr, ra, rb);
return void 0;
};
Skeleton.prototype._setTRMatRows = function(smr, t, r) {
var ref, ref1, ref2, w, wx2, wy2, wz2, x, x2, xx2, xy2, xz2, y, y2, yy2, yz2, z, z2, zz2;
x = r[0];
y = r[1];
z = r[2];
w = r[3];
x2 = x + x;
y2 = y + y;
z2 = z + z;
wx2 = w * x2;
wy2 = w * y2;
wz2 = w * z2;
xx2 = x * x2;
xy2 = x * y2;
xz2 = x * z2;
yy2 = y * y2;
yz2 = y * z2;
zz2 = z * z2;
[].splice.apply(smr[0], [0, 4].concat(ref = [1.0 - yy2 - zz2, xy2 - wz2, xz2 + wy2, t[0]])), ref;
[].splice.apply(smr[1], [0, 4].concat(ref1 = [xy2 + wz2, 1.0 - xx2 - zz2, yz2 - wx2, t[1]])), ref1;
return ([].splice.apply(smr[2], [0, 4].concat(ref2 = [xz2 - wy2, yz2 + wx2, 1.0 - xx2 - yy2, t[2]])), ref2);
};
Skeleton.prototype._vsSetSkinMatRowsForBone = function(bsmr, b) {
var i, icgr, icgt, iibr, iibt, rCGb, rIBb, rSkinb, tCGb, tIBb, tSkinb;
iibt = b * 4 * 4;
iibr = iibt + 4;
icgt = iibr + 4;
icgr = icgt + 4;
tSkinb = [0, 0, 0];
rSkinb = [0, 0, 0, 0];
tCGb = (function() {
var k, results;
results = [];
for (i = k = 0; k < 3; i = ++k) {
results.push(this.skelXforms[icgt + i]);
}
return results;
}).call(this);
rCGb = (function() {
var k, results;
results = [];
for (i = k = 0; k < 4; i = ++k) {
results.push(this.skelXforms[icgr + i]);
}
return results;
}).call(this);
tIBb = (function() {
var k, results;
results = [];
for (i = k = 0; k < 3; i = ++k) {
results.push(this.skelXforms[iibt + i]);
}
return results;
}).call(this);
rIBb = (function() {
var k, results;
results = [];
for (i = k = 0; k < 4; i = ++k) {
results.push(this.skelXforms[iibr + i]);
}
return results;
}).call(this);
this._setTRXProd(tSkinb, rSkinb, tCGb, rCGb, tIBb, rIBb);
return this._setTRMatRows(bsmr, tSkinb, rSkinb);
};
return Skeleton;
})();
cwaenv.add(Skeleton, "Skeleton");
}).call(this);
//-------- js/Morphvertex.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var MorphVertex, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
V3 = cwaenv.get("E3Vec");
MorphVertex = (function() {
function MorphVertex() {
this.ixVertex = -1;
this.offset = this.normal = null;
}
MorphVertex.fromJSON = function(jsnmphvtx) {
var mphvtx;
mphvtx = new MorphVertex;
mphvtx.setFromJSON(jsnmphvtx);
return mphvtx;
};
MorphVertex.fromBin = function(avdv) {
var mphvtx;
mphvtx = new MorphVertex;
mphvtx.setFromBin(avdv);
return mphvtx;
};
MorphVertex.prototype.setFromJSON = function(jsnmphvtx) {
this.ixVertex = jsnmphvtx.vertex;
this.offset = V3.copyOfV3(jsnmphvtx.offset);
return this.normal = V3.copyOfV3(jsnmphvtx.normal);
};
MorphVertex.prototype.setFromBin = function(avdv) {
var weight;
this.ixVertex = avdv.nextUint();
weight = avdv.nextFloat();
this.offset = avdv.nextVec3();
return this.normal = avdv.nextVec3();
};
MorphVertex.prototype.getVertexId = function() {
return this.ixVertex;
};
MorphVertex.prototype.getOffset = function() {
return this.offset;
};
MorphVertex.prototype.getNormal = function() {
return this.normal;
};
return MorphVertex;
})();
cwaenv.add(MorphVertex, "MorphVertex");
}).call(this);
//-------- js/MorphTarget.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var FourCC, MorphTarget, MorphVertex, RQ, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
RQ = cwaenv.get("RotQuat");
MorphVertex = cwaenv.get("MorphVertex");
MorphTarget = (function() {
function MorphTarget() {
this.fourCCName = 0;
this.vertices = null;
this.stdVerticesDesc = [-1, 0, [], []];
this.dupVerticesDesc = [-1, 0, [], []];
}
MorphTarget.fromJSON = function(jsnmphtgt) {
var mphtgt;
mphtgt = new MorphTarget;
mphtgt.setFromJSON(jsnmphtgt);
return mphtgt;
};
MorphTarget.fromBin = function(avdv) {
var mphtgt;
mphtgt = new MorphTarget;
mphtgt.setFromBin(avdv);
return mphtgt;
};
MorphTarget.prototype.setFromJSON = function(jsnmphtgt) {
this.fourCCName = FourCC.fourCCInt(jsnmphtgt.morphTargetName);
return this.vertices = jsnmphtgt.morphSets.map(MorphVertex.fromJSON);
};
MorphTarget.prototype.setFromBin = function(avdv) {
var nMorphSets, s;
this.fourCCName = avdv.nextStr4cc();
nMorphSets = avdv.nextUint();
return this.vertices = (function() {
var j, ref, results;
results = [];
for (s = j = 0, ref = nMorphSets; 0 <= ref ? j < ref : j > ref; s = 0 <= ref ? ++j : --j) {
results.push(MorphVertex.fromBin(avdv));
}
return results;
})();
};
MorphTarget.prototype.getFourCCName = function() {
return this.fourCCName;
};
MorphTarget.prototype.getVertexCount = function() {
return this.vertices.length;
};
MorphTarget.prototype.getVertices = function() {
return this.vertices;
};
MorphTarget.prototype.getVertex = function(i) {
return this.vertices[i];
};
MorphTarget.prototype.getVertexSegments = function() {
return [this.stdVerticesDesc, this.dupVerticesDesc];
};
MorphTarget.prototype.vertexRangeLimits = function(NV, NVNoDups, dupLists) {
var dhi, dlo, dv, hi, j, l, len, len1, lo, ref, ref1, v, vtx;
lo = NVNoDups;
hi = 0;
dlo = NV;
dhi = NVNoDups;
ref = this.vertices;
for (j = 0, len = ref.length; j < len; j++) {
vtx = ref[j];
v = vtx.getVertexId();
if (v < lo) {
lo = v;
}
if (hi <= v) {
hi = v + 1;
}
ref1 = dupLists[v];
for (l = 0, len1 = ref1.length; l < len1; l++) {
dv = ref1[l];
if (dv < dlo) {
dlo = dv;
}
if (dhi <= dv) {
dhi = dv + 1;
}
}
}
if (hi <= lo) {
lo = hi = -1;
}
if (dhi <= dlo) {
dlo = dhi = -1;
}
return [lo, hi, dlo, dhi];
};
MorphTarget.prototype.makeVertexArraySegments = function(NV, NVNoDups, dupLists, headRotQV) {
var NM, NM3, NMD, NMD3, NV3, NVND, delta, dhi, dlo, dmnorm, dmpos, dmv, dmv3, hi, j, k, l, len, len1, lo, m, mnorm, mpos, mtItem, mv, mv3, n, ref, ref1, ref2, ref3, ref4;
NV3 = NV * 3;
NVND = NVNoDups;
ref = this.vertexRangeLimits(NV, NVND, dupLists), lo = ref[0], hi = ref[1], dlo = ref[2], dhi = ref[3];
NM = hi - lo;
NMD = dhi - dlo;
NM3 = 3 * NM;
NMD3 = 3 * NMD;
mpos = new Float32Array(NM3);
mnorm = new Float32Array(NM3);
for (k = j = 0, ref1 = NM3; 0 <= ref1 ? j < ref1 : j > ref1; k = 0 <= ref1 ? ++j : --j) {
mpos[k] = 0;
mnorm[k] = 0;
}
dmpos = new Float32Array(NMD3);
dmnorm = new Float32Array(NMD3);
for (k = l = 0, ref2 = NM3; 0 <= ref2 ? l < ref2 : l > ref2; k = 0 <= ref2 ? ++l : --l) {
dmpos[k] = 0;
dmnorm[k] = 0;
}
delta = [0, 0, 0];
ref3 = this.vertices;
for (m = 0, len = ref3.length; m < len; m++) {
mtItem = ref3[m];
mv = mtItem.getVertexId();
mv3 = 3 * (mv - lo);
RQ.rotateV3(delta, mtItem.getOffset(), headRotQV);
mpos[mv3] = delta[0];
mpos[mv3 + 1] = delta[1];
mpos[mv3 + 2] = delta[2];
RQ.rotateV3(delta, mtItem.getNormal(), headRotQV);
mnorm[mv3] = delta[0];
mnorm[mv3 + 1] = delta[1];
mnorm[mv3 + 2] = delta[2];
if (dupLists[mv].length !== 0) {
ref4 = dupLists[mv];
for (n = 0, len1 = ref4.length; n < len1; n++) {
dmv = ref4[n];
dmv3 = 3 * (dmv - dlo);
dmpos[dmv3] = mpos[mv3];
dmpos[dmv3 + 1] = mpos[mv3 + 1];
dmpos[dmv3 + 2] = mpos[mv3 + 2];
dmnorm[dmv3] = mnorm[mv3];
dmnorm[dmv3 + 1] = mnorm[mv3 + 1];
dmnorm[dmv3 + 2] = mnorm[mv3 + 2];
}
}
}
this.stdVerticesDesc = {
range: {
base: lo,
size: NM
},
buffers: {
pos: mpos,
norm: mnorm
}
};
this.dupVerticesDesc = {
range: {
base: dlo,
size: NMD
},
buffers: {
pos: dmpos,
norm: dmnorm
}
};
return void 0;
};
return MorphTarget;
})();
cwaenv.add(MorphTarget, "MorphTarget");
}).call(this);
//-------- js/MorphsManager.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var MorphTarget, MorphsManager, RQ, VBO, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
VBO = cwaenv.get("VBO");
RQ = cwaenv.get("RotQuat");
MorphTarget = cwaenv.get("MorphTarget");
MorphsManager = (function() {
function MorphsManager(mtags) {
this.MORPH_TAGS = mtags;
this.morphTargets = [];
this.mtIndicesBy4CC = null;
this.nVertices = -1;
this.nVerticesNoDups = -1;
this.morphOffsetBufs = [];
this.morphNormBufs = [];
this.posVBOs = null;
this.normVBOs = null;
this.zeroMorphBuf = null;
this.multiMorphOffsetBuf = null;
this.multiMorphNormBuf = null;
this.vbosUsage = null;
this.morphAlloc = null;
this.morphAllocIsNew = null;
this.iMulti = -1;
this.multiMorphs = [];
this.morphWeights = null;
this.prevMorphAlloc = null;
this.mmRanges = null;
this.mmWeightedSegsList = null;
}
MorphsManager.fromJSON = function(jsnmtl, mtags) {
var mm;
mm = new MorphsManager(mtags);
mm.setFromJSON(jsnmtl);
return mm;
};
MorphsManager.fromBin = function(avdv, mtags) {
var mm;
mm = new MorphsManager(mtags);
mm.setFromBin(avdv);
return mm;
};
MorphsManager.prototype._lohi = function(lo, hi) {
return [lo, hi];
};
MorphsManager.prototype._lohistr = function(lohi) {
var hi, lo;
lo = lohi[0], hi = lohi[1];
return "[" + lo + ".." + hi + ")";
};
MorphsManager.prototype._lohi2str = function(lo, hi) {
return this._lohistr(this._lohi(lo, hi));
};
MorphsManager.prototype._limits = function(rng) {
var lo, sz;
lo = rng.base;
sz = rng.size;
return this._lohi(lo, lo + sz);
};
MorphsManager.prototype._rngstr = function(rng) {
return this._lohistr(this._limits(rng));
};
MorphsManager.prototype._jstr = function(j) {
if (j === 0) {
return "main";
} else {
return " dup";
}
};
MorphsManager.prototype.setFromJSON = function(jsnmtl) {
var NMT, json2mt, t;
json2mt = MorphTarget.fromJSON;
NMT = jsnmtl.length;
this.morphTargets = (function() {
var k, ref, results;
results = [];
for (t = k = 0, ref = NMT; 0 <= ref ? k < ref : k > ref; t = 0 <= ref ? ++k : --k) {
results.push(json2mt(jsnmtl[t]));
}
return results;
})();
return this.set4CCIndex();
};
MorphsManager.prototype.setFromBin = function(avdv) {
var NMT, t;
NMT = avdv.nextUint();
this.morphTargets = (function() {
var k, ref, results;
results = [];
for (t = k = 0, ref = NMT; 0 <= ref ? k < ref : k > ref; t = 0 <= ref ? ++k : --k) {
results.push(MorphTarget.fromBin(avdv));
}
return results;
})();
return this.set4CCIndex();
};
MorphsManager.prototype.set4CCIndex = function() {
var k, len, m, mBy4cc, mtgt, ref;
mBy4cc = [];
ref = this.morphTargets;
for (m = k = 0, len = ref.length; k < len; m = ++k) {
mtgt = ref[m];
mBy4cc[mtgt.getFourCCName()] = m;
}
return this.mtIndicesBy4CC = mBy4cc;
};
MorphsManager.prototype.enableMorphVBOs = function() {
var i, k, len, ref, w;
ref = this.morphWeights;
for (i = k = 0, len = ref.length; k < len; i = ++k) {
w = ref[i];
if (!(w !== 0)) {
continue;
}
this.posVBOs[i].enableAttrib();
this.normVBOs[i].enableAttrib();
}
return void 0;
};
MorphsManager.prototype.disableMorphVBOs = function() {
var i, k, len, ref, w;
ref = this.morphWeights;
for (i = k = 0, len = ref.length; k < len; i = ++k) {
w = ref[i];
if (!(w !== 0)) {
continue;
}
this.posVBOs[i].disableAttrib();
this.normVBOs[i].disableAttrib();
}
return void 0;
};
MorphsManager.prototype.getMorphWeights = function() {
return this.morphWeights;
};
MorphsManager.prototype.createCPUVertexBuffers = function(nv) {
var nV3;
this.nVertices = nv;
nV3 = nv * 3;
this.zeroMorphBuf = new Float32Array(nV3);
this.multiMorphOffsetBuf = new Float32Array(nV3);
return this.multiMorphNormBuf = new Float32Array(nV3);
};
MorphsManager.prototype.createGLVBOs = function(gl, getAttrLoc) {
var abcd, k, len, ref, setVBO;
this.gl = gl;
this.posVBOs = [];
this.normVBOs = [];
setVBO = (function(_this) {
return function(vbos, id, buf) {
return vbos.push(VBO.makeDyn(gl, 3, buf, getAttrLoc(id)));
};
})(this);
ref = this.MORPH_TAGS;
for (k = 0, len = ref.length; k < len; k++) {
abcd = ref[k];
setVBO(this.posVBOs, "MorphPos" + abcd, this.zeroMorphBuf);
setVBO(this.normVBOs, "MorphNorm" + abcd, this.zeroMorphBuf);
}
return void 0;
};
MorphsManager.prototype.makeVertexArrays = function(vDupIndices, globalHeadRot) {
var NMT, NV, NV3, NVND, d, dupLists, i, k, l, len, len1, m, mtgt, n, ref, ref1, t, v;
NV = this.nVertices;
NV3 = 3 * NV;
this.nVerticesNoDups = NVND = NV - vDupIndices.length;
NMT = this.morphTargets.length;
dupLists = (function() {
var k, ref, results;
results = [];
for (i = k = 0, ref = NVND; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
results.push([]);
}
return results;
})();
for (d = k = 0, len = vDupIndices.length; k < len; d = ++k) {
v = vDupIndices[d];
dupLists[v].push(NVND + d);
}
ref = this.morphTargets;
for (m = l = 0, len1 = ref.length; l < len1; m = ++l) {
mtgt = ref[m];
mtgt.makeVertexArraySegments(NV, NVND, dupLists, globalHeadRot.xyzw);
}
this.morphAlloc = [];
this.morphWeights = [];
this.vbosUsage = [];
for (t = n = 0, ref1 = this.MORPH_TAGS.length; 0 <= ref1 ? n < ref1 : n > ref1; t = 0 <= ref1 ? ++n : --n) {
this.morphAlloc.push(-1);
this.morphWeights.push(0);
this.vbosUsage.push([
{
base: -1,
size: 0
}, {
base: -1,
size: 0
}
]);
}
return void 0;
};
MorphsManager.prototype.setGLDataForDraw = function(currentMorphs) {
var activeMorphs, k, len, m, morph, t;
this.prevMorphAlloc = this.morphAlloc;
this.morphWeights = (function() {
var k, ref, results;
results = [];
for (t = k = 0, ref = this.MORPH_TAGS.length; 0 <= ref ? k < ref : k > ref; t = 0 <= ref ? ++k : --k) {
results.push(0);
}
return results;
}).call(this);
activeMorphs = [];
for (k = 0, len = currentMorphs.length; k < len; k++) {
morph = currentMorphs[k];
if (!((morph.getAmount()) !== 0)) {
continue;
}
m = this.mtIndicesBy4CC[morph.getName()];
activeMorphs.push([m, morph.getAmount()]);
}
if (activeMorphs.length !== 0) {
this.allocGLMorphSlots(activeMorphs);
this.morphDataToGPU();
}
return void 0;
};
MorphsManager.prototype.allocGLMorphSlots = function(activeMorphs) {
var NMT, a, aMph, aa, assignSlot, getFreeSlot, i, iMulti, k, l, len, multi, nUnalloc, nUsed, pm, ref, ref1, t, uLimit;
NMT = this.MORPH_TAGS.length;
this.morphAlloc = [];
this.morphAllocIsNew = [];
for (t = k = 0, ref = NMT; 0 <= ref ? k < ref : k > ref; t = 0 <= ref ? ++k : --k) {
this.morphAlloc.push(-1);
this.morphAllocIsNew.push(false);
}
nUsed = 0;
nUnalloc = activeMorphs.length;
uLimit = (activeMorphs.length <= NMT ? NMT : NMT - 1);
assignSlot = (function(_this) {
return function(i, aMph) {
_this.morphAlloc[i] = aMph[0];
_this.morphWeights[i] = aMph[1];
++nUsed;
--nUnalloc;
return aMph[0] = -1;
};
})(this);
ref1 = this.prevMorphAlloc;
for (i = l = 0, len = ref1.length; l < len; i = ++l) {
pm = ref1[i];
if (!(0 <= pm && nUsed !== uLimit)) {
continue;
}
a = 0;
aa = activeMorphs.length;
while (a !== aa) {
if (activeMorphs[a][0] === pm) {
aa = a;
} else {
++a;
}
}
if (a !== activeMorphs.length) {
assignSlot(i, activeMorphs[a]);
}
}
getFreeSlot = (function(_this) {
return function() {
i = 0;
while (0 <= _this.morphAlloc[i]) {
++i;
}
return i;
};
})(this);
multi = [];
iMulti = -1;
a = 0;
while (nUnalloc !== 0) {
if (nUsed !== uLimit) {
while (activeMorphs[a][0] < 0) {
++a;
}
i = getFreeSlot();
this.morphAllocIsNew[i] = true;
assignSlot(i, activeMorphs[a]);
++a;
} else {
multi = (function() {
var len1, n, results;
results = [];
for (n = 0, len1 = activeMorphs.length; n < len1; n++) {
aMph = activeMorphs[n];
if (0 <= aMph[0]) {
results.push(aMph);
}
}
return results;
})();
iMulti = getFreeSlot();
this.morphWeights[iMulti] = 1;
++nUsed;
nUnalloc -= multi.length;
}
}
this.iMulti = iMulti;
this.multiMorphs = multi;
return void 0;
};
MorphsManager.prototype.dirtyRangesForVBOClean = function(usedrange, newrange) {
var hi, k, len, limslist, lo, ref, results, uhi, ulo;
ulo = usedrange.base;
uhi = ulo + usedrange.size;
lo = newrange.base;
hi = lo + newrange.size;
if (ulo < lo && hi < uhi) {
limslist = [[ulo, lo], [hi, uhi]];
} else if (lo <= ulo && uhi <= hi) {
limslist = [];
} else {
if (uhi <= hi) {
limslist = [[ulo, (lo < uhi ? lo : uhi)]];
}
if (lo <= ulo) {
limslist = [[(ulo < hi ? hi : ulo), uhi]];
}
}
results = [];
for (k = 0, len = limslist.length; k < len; k++) {
ref = limslist[k], lo = ref[0], hi = ref[1];
results.push({
base: lo,
size: hi - lo
});
}
return results;
};
MorphsManager.prototype.cleanMorphVBOs = function(i, m, newsegs) {
var cleanBuf, dhi, dlo, dr, drngs, j, k, l, len, len1, newrng, ref, usedrng, vbou_i;
vbou_i = this.vbosUsage[i];
ref = [0, 1];
for (k = 0, len = ref.length; k < len; k++) {
j = ref[k];
usedrng = vbou_i[j];
newrng = newsegs[j].range;
if (usedrng.size === 0 || newrng.size === 0) {
} else {
drngs = this.dirtyRangesForVBOClean(usedrng, newrng);
for (l = 0, len1 = drngs.length; l < len1; l++) {
dr = drngs[l];
dlo = dr.base;
dhi = dlo + dr.size;
cleanBuf = this.zeroMorphBuf.subarray(3 * dlo, 3 * dhi);
this.posVBOs[i].uploadPartialData(dlo, cleanBuf);
this.normVBOs[i].uploadPartialData(dlo, cleanBuf);
}
}
if (newrng.size !== 0) {
usedrng.base = newrng.base;
usedrng.size = newrng.size;
}
}
return void 0;
};
MorphsManager.prototype.setMorphVBOs = function(i, mVtxSegs) {
var bufs, j, k, len, mvsegs, ref, rng;
ref = [0, 1];
for (k = 0, len = ref.length; k < len; k++) {
j = ref[k];
mvsegs = mVtxSegs[j];
rng = mvsegs.range;
bufs = mvsegs.buffers;
if (rng.size !== 0) {
this.posVBOs[i].uploadPartialData(rng.base, bufs.pos);
this.normVBOs[i].uploadPartialData(rng.base, bufs.norm);
}
}
return void 0;
};
MorphsManager.prototype.generateMultiMorphsSegsDescs = function() {
var NV, NVND, hi, j, k, l, len, len1, limits, lo, lohi, m, mmrng, mweight, ref, ref1, ref2, ref3, segs, segsj, shi, slo, srng, ssz, wSegs, wSegsList, wSegs_j, wSegsj;
NV = this.nVertices;
NVND = this.nVerticesNoDups;
limits = [[NVND, 0], [NV, NVND]];
wSegsList = [];
ref = this.multiMorphs;
for (k = 0, len = ref.length; k < len; k++) {
ref1 = ref[k], m = ref1[0], mweight = ref1[1];
segs = this.morphTargets[m].getVertexSegments();
wSegs = [];
ref2 = [0, 1];
for (l = 0, len1 = ref2.length; l < len1; l++) {
j = ref2[l];
segsj = segs[j];
srng = segsj.range;
slo = srng.base;
ssz = srng.size;
shi = slo + ssz;
ref3 = lohi = limits[j], lo = ref3[0], hi = ref3[1];
wSegs_j = null;
if (ssz !== 0) {
if (slo < lo) {
lohi[0] = slo;
}
if (hi < shi) {
lohi[1] = shi;
}
wSegsj = {
range: segsj.range,
buffers: segsj.buffers,
weight: mweight
};
}
wSegs.push(wSegsj);
}
wSegsList.push(wSegs);
}
mmrng = function(lohi) {
lo = lohi[0], hi = lohi[1];
if (hi <= lo) {
lo = hi = -1;
}
return {
base: lo,
size: hi - lo
};
};
this.mmRanges = (function() {
var len2, n, results;
results = [];
for (n = 0, len2 = limits.length; n < len2; n++) {
lohi = limits[n];
results.push(mmrng(lohi));
}
return results;
})();
this.mmWeightedSegsList = wSegsList;
return void 0;
};
MorphsManager.prototype.generateMultiMorphsVBOs = function() {
var hi, hi3, j, k, k3, l, len, len1, lo, lo3, mmNBuf, mmPBuf, n, nbseg, normbuf, o, pbseg, posbuf, ranges, ref, ref1, ref2, ref3, rng, slo, slo3, ssz, ssz3, wSegs, wSegsList, wSegsj, weight;
ranges = this.mmRanges;
wSegsList = this.mmWeightedSegsList;
mmPBuf = this.multiMorphOffsetBuf;
mmNBuf = this.multiMorphNormBuf;
ref = [0, 1];
for (k = 0, len = ref.length; k < len; k++) {
j = ref[k];
rng = ranges[j];
lo = rng.base;
hi = lo + rng.size;
if (lo < hi) {
lo3 = 3 * lo;
hi3 = 3 * hi;
for (k3 = l = ref1 = lo3, ref2 = hi3; ref1 <= ref2 ? l < ref2 : l > ref2; k3 = ref1 <= ref2 ? ++l : --l) {
mmPBuf[k3] = 0;
mmNBuf[k3] = 0;
}
for (n = 0, len1 = wSegsList.length; n < len1; n++) {
wSegs = wSegsList[n];
if (!wSegs[j]) {
continue;
}
wSegsj = wSegs[j];
weight = wSegsj.weight;
rng = wSegsj.range;
slo = rng.base;
ssz = rng.size;
posbuf = wSegsj.buffers.pos;
normbuf = wSegsj.buffers.norm;
slo3 = 3 * slo;
ssz3 = 3 * ssz;
for (k3 = o = 0, ref3 = ssz3; 0 <= ref3 ? o < ref3 : o > ref3; k3 = 0 <= ref3 ? ++o : --o) {
mmPBuf[slo3 + k3] += weight * posbuf[k3];
mmNBuf[slo3 + k3] += weight * normbuf[k3];
}
}
pbseg = mmPBuf.subarray(lo3, hi3);
nbseg = mmNBuf.subarray(lo3, hi3);
this.posVBOs[this.iMulti].uploadPartialData(lo, pbseg);
this.normVBOs[this.iMulti].uploadPartialData(lo, nbseg);
}
}
return void 0;
};
MorphsManager.prototype.morphDataToGPU = function() {
var GL, GL_A_BUF, i, k, len, m, mmrng, mmvsegs, mvsegs, ref;
GL = this.gl;
GL_A_BUF = GL.ARRAY_BUFFER;
ref = this.morphAlloc;
for (i = k = 0, len = ref.length; k < len; i = ++k) {
m = ref[i];
if (!(0 <= m && this.morphAllocIsNew[i])) {
continue;
}
mvsegs = this.morphTargets[m].getVertexSegments();
this.cleanMorphVBOs(i, m, mvsegs);
this.setMorphVBOs(i, mvsegs);
}
if (0 <= this.iMulti) {
this.generateMultiMorphsSegsDescs();
mmvsegs = (function() {
var l, len1, ref1, results;
ref1 = this.mmRanges;
results = [];
for (l = 0, len1 = ref1.length; l < len1; l++) {
mmrng = ref1[l];
results.push({
range: mmrng
});
}
return results;
}).call(this);
this.cleanMorphVBOs(this.iMulti, -1, mmvsegs);
this.generateMultiMorphsVBOs();
}
return void 0;
};
return MorphsManager;
})();
cwaenv.add(MorphsManager, "MorphsManager");
}).call(this);
//-------- js/MeshVertex.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var FourCC, MeshVertex, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
FourCC = cwaenv.get("FourCC");
V3 = cwaenv.get("E3Vec");
MeshVertex = (function() {
function MeshVertex() {
this.index = -1;
this.countBones = 0;
this.bone4cc = null;
this.weight = null;
this.offsetVector = null;
this.baseNormal = null;
this.distance = null;
}
MeshVertex.fromJSON = function(jsnmvtx, ix) {
var mvtx;
mvtx = new MeshVertex;
mvtx.setFromJSON(jsnmvtx, ix);
return mvtx;
};
MeshVertex.fromBin = function(avdv, ix) {
var mvtx;
mvtx = new MeshVertex;
mvtx.setFromBin(avdv, ix);
return mvtx;
};
MeshVertex.prototype.setFromJSON = function(jsnmvtx, ix) {
var CVT_4CC, MAKE_V3F;
CVT_4CC = FourCC.fourCCInt;
MAKE_V3F = V3.fromVec.bind(V3);
this.index = ix;
this.countBones = jsnmvtx.countInfluences;
this.offsetVector = jsnmvtx.offsets.map(MAKE_V3F);
this.baseNormal = jsnmvtx.baseNormals.map(MAKE_V3F);
this.bone4cc = jsnmvtx.influenceNames.map(CVT_4CC);
this.weight = jsnmvtx.weights.slice();
return this.distance = jsnmvtx.xDistances.slice();
};
MeshVertex.prototype.setFromBin = function(avdv, ix) {
var b, i, ibRange, j, ref, ref1, results;
this.index = ix;
this.countBones = avdv.nextUint();
ibRange = (function() {
results = [];
for (var i = 0, ref = this.countBones; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
return results;
}).apply(this);
this.offsetVector = (function() {
var j, len, results1;
results1 = [];
for (j = 0, len = ibRange.length; j < len; j++) {
b = ibRange[j];
results1.push(V3.fromVec(avdv.nextVec3()));
}
return results1;
})();
this.baseNormal = (function() {
var j, len, results1;
results1 = [];
for (j = 0, len = ibRange.length; j < len; j++) {
b = ibRange[j];
results1.push(V3.fromVec(avdv.nextVec3()));
}
return results1;
})();
this.bone4cc = new Array(this.countBones);
for (b = j = 0, ref1 = this.countBones; 0 <= ref1 ? j < ref1 : j > ref1; b = 0 <= ref1 ? ++j : --j) {
this.bone4cc[b] = avdv.nextStr4cc();
}
this.weight = (function() {
var k, len, results1;
results1 = [];
for (k = 0, len = ibRange.length; k < len; k++) {
b = ibRange[k];
results1.push(avdv.nextFloat());
}
return results1;
})();
return this.distance = (function() {
var k, len, results1;
results1 = [];
for (k = 0, len = ibRange.length; k < len; k++) {
b = ibRange[k];
results1.push(avdv.nextFloat());
}
return results1;
})();
};
MeshVertex.prototype.getBoneEndDistance = function(b) {
return this.distance[b];
};
MeshVertex.prototype.getIndex = function() {
return this.index;
};
MeshVertex.prototype.getNumBones = function() {
return this.countBones;
};
MeshVertex.prototype.getBone4cc = function(b) {
return this.bone4cc[b];
};
MeshVertex.prototype.getWeight = function(b) {
return this.weight[b];
};
MeshVertex.prototype.getOffset = function(b) {
return this.offsetVector[b];
};
MeshVertex.prototype.getBaseNormal = function(b) {
return this.baseNormal[b];
};
return MeshVertex;
})();
this.MeshVertex = MeshVertex;
}).call(this);
//-------- js/Mesh.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Config, Data, FourCC, M4, Mesh, MorphsManager, RQ, Shader, Texture, V3, VBO, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Config = cwaenv.get("Config");
Data = cwaenv.get("Data");
Shader = cwaenv.get("Shader");
Texture = cwaenv.get("Texture");
VBO = cwaenv.get("VBO");
FourCC = cwaenv.get("FourCC");
V3 = cwaenv.get("E3Vec");
RQ = cwaenv.get("RotQuat");
M4 = cwaenv.get("Mat4");
MorphsManager = cwaenv.get("MorphsManager");
Mesh = (function() {
function Mesh(gl, usebonetrx, cputrx2mat) {
var floatext;
this.gl = gl;
this.modelMat = M4.makeMat4();
this.modelViewMat = M4.makeMat4();
this.modelViewProjMat = M4.makeMat4();
this.skinningShader = null;
this.vertices = null;
this.vertexDuplicateIndices = null;
this.texture = null;
this.texCoords = null;
this.boneIxs = null;
this.boneWeights = null;
this.triStripIndices = null;
this.bindPos = null;
this.bindNorm = null;
this.vbos = [];
this.morphsManager = null;
this.uniformMVMat = null;
this.uniformMVPMat = null;
this.uniformBones = null;
this.uniformMorphWeights = null;
this.uniformTexture = null;
this.DO_TRX_BONE_UNIFORMS = usebonetrx;
this.TEST_CPU_TRX_TO_MAT = cputrx2mat;
this.boneTexture = null;
this.twistTexture = null;
this.uniformSkelXforms = null;
this.uniformSkelXformsWidth = null;
this.uniformSkelXformsHeight = null;
this.boneTwists = null;
this.uniformBoneTwistData = null;
this.uniformBoneTwistWidth = null;
this.uniformBoneTwistHeight = null;
floatext = this.gl.getExtension('OES_texture_float');
this.DO_ARM_TWISTS = true;
this._SUPPRESS_A_T = false;
this.USE_TEXTURES = floatext != null;
log("Mesh: DO_TRX_BONE_UNIFORMS: " + this.DO_TRX_BONE_UNIFORMS + ", TEST_CPU_TRX_TO_MAT: " + this.TEST_CPU_TRX_TO_MAT + ", DO_ARM_TWISTS: " + this.DO_ARM_TWISTS + ", SUPPRESS_A_T: " + this._SUPPRESS_A_T + ", USE_TEXTURES: " + this.USE_TEXTURES);
}
Mesh.MORPH_TAGS = ["A", "B", "C", "D"];
Mesh.prototype.setFromJSON = function(jsnmesh) {
this.loadVertices(jsnmesh.meshPoints);
this.loadTriangleStripIndices(jsnmesh.triangleStripIndices);
this.loadVertexDuplicateData(jsnmesh.duplicateVertexIndices);
this.loadTextureCoords(jsnmesh.textureCoordinatePairs);
this.morphsManager = MorphsManager.fromJSON(jsnmesh.morphTargets, Mesh.MORPH_TAGS);
return this.createCPUVertexBuffers();
};
Mesh.prototype.setFromBin = function(avdv) {
this.lodRange = avdv.nextFloat();
this.loadVerticesBin(avdv);
this.loadTriangleStripIndicesBin(avdv);
this.loadVertexDuplicateDataBin(avdv);
this.loadTextureCoordsBin(avdv);
this.morphsManager = MorphsManager.fromBin(avdv, Mesh.MORPH_TAGS);
return this.createCPUVertexBuffers();
};
Mesh.prototype.loadVertices = function(jsnmpts) {
this.vertices = jsnmpts.map(MeshVertex.fromJSON);
return this.nVertsNoDups = this.vertices.length;
};
Mesh.prototype.loadVerticesBin = function(avdv) {
var nMV, v;
nMV = avdv.nextUint();
this.vertices = (function() {
var l, ref, results;
results = [];
for (v = l = 0, ref = nMV; 0 <= ref ? l < ref : l > ref; v = 0 <= ref ? ++l : --l) {
results.push(MeshVertex.fromBin(avdv, v));
}
return results;
})();
return this.nVertsNoDups = this.vertices.length;
};
Mesh.prototype.loadTriangleStripIndices = function(jsntsis) {
return this.triStripIndices = new Uint16Array(jsntsis);
};
Mesh.prototype.loadTriangleStripIndicesBin = function(avdv) {
var l, nTSI, ref, t, tsi;
nTSI = avdv.nextUint();
tsi = new Uint16Array(nTSI);
for (t = l = 0, ref = nTSI; 0 <= ref ? l < ref : l > ref; t = 0 <= ref ? ++l : --l) {
tsi[t] = avdv.nextUshort();
}
return this.triStripIndices = tsi;
};
Mesh.prototype.appendDuplicatedVertices = function() {
var l, len, ref, results, vdi;
ref = this.vertexDuplicateIndices;
results = [];
for (l = 0, len = ref.length; l < len; l++) {
vdi = ref[l];
results.push(this.vertices.push(this.vertices[vdi]));
}
return results;
};
Mesh.prototype.loadVertexDuplicateData = function(jsndvis) {
this.vertexDuplicateIndices = jsndvis;
return this.appendDuplicatedVertices();
};
Mesh.prototype.loadVertexDuplicateDataBin = function(avdv) {
var j, nDupVertices;
nDupVertices = avdv.nextUint();
this.vertexDuplicateIndices = (function() {
var l, ref, results;
results = [];
for (j = l = 0, ref = nDupVertices; 0 <= ref ? l < ref : l > ref; j = 0 <= ref ? ++l : --l) {
results.push(avdv.nextUint());
}
return results;
})();
return this.appendDuplicatedVertices();
};
Mesh.prototype.loadTextureCoords = function(jsntcpairs) {
var i, tca;
tca = new Float32Array(2 * jsntcpairs.length);
i = 0;
jsntcpairs.forEach((function(cc) {
this[i] = cc[0];
this[i + 1] = cc[1];
return i += 2;
}), tca);
return this.texCoords = tca;
};
Mesh.prototype.loadTextureCoordsBin = function(avdv) {
var c, cc, i, l, nTC2, ref, tca;
nTC2 = avdv.nextUint();
tca = new Float32Array(2 * nTC2);
i = 0;
for (c = l = 0, ref = nTC2; 0 <= ref ? l < ref : l > ref; c = 0 <= ref ? ++l : --l) {
cc = avdv.nextVec2();
tca[i] = cc[0];
tca[i + 1] = cc[1];
i += 2;
}
return this.texCoords = tca;
};
Mesh.prototype.createCPUVertexBuffers = function() {
var nV, nV3, nV4;
nV = this.vertices.length;
nV3 = nV * 3;
nV4 = nV * 4;
this.bindPos = new Float32Array(nV3);
this.bindNorm = new Float32Array(nV3);
this.boneIxs = new Float32Array(nV4);
this.boneWeights = new Float32Array(nV4);
if (this.DO_ARM_TWISTS) {
this.boneTwists = new Float32Array(nV4);
}
return this.morphsManager.createCPUVertexBuffers(nV);
};
Mesh.prototype.createShaders = function(callback, nbones) {
var fsloaded, fspath, sroot, useQSkin, vsloaded, vsloc, vspath, vssource, vssubs;
useQSkin = this.DO_TRX_BONE_UNIFORMS && !this.TEST_CPU_TRX_TO_MAT;
sroot = useQSkin ? "qskin" : "skinning";
vspath = "shaders/" + sroot + ".vert";
fspath = "shaders/" + sroot + ".frag";
vssubs = [["N_BONES", "" + nbones], ["DO_TWIST", this.DO_ARM_TWISTS ? "1" : "0"], ["USE_TXTR", this.USE_TEXTURES ? "1" : "0"]];
vssource = null;
fsloaded = (function(_this) {
return function(fssource) {
_this.skinningShader = new Shader(_this.gl, vspath, fspath, vssource, fssource, vssubs);
return callback();
};
})(this);
vsloaded = function(vstxt) {
var fsloc;
vssource = vstxt;
fsloc = Data.absoluteURI(fspath, Config.theConfig.cwaBase);
return Data.fetchText(fsloc, fsloaded);
};
vsloc = Data.absoluteURI(vspath, Config.theConfig.cwaBase);
return Data.fetchText(vsloc, vsloaded);
};
Mesh.prototype.createTextureFromJSON = function(tURL) {
log("Texture directly from URL " + tURL + " ...");
return this.texture = new Texture(this.gl, (function(tURLHandler) {
return tURLHandler(tURL);
}), false);
};
Mesh.prototype.createTextureFromAvDV = function(avdv, tName, mustFlip) {
log("Asynchronous texture PNG URI via AvDef entry for " + tName + " ...");
return this.texture = new Texture(this.gl, avdv.pngURIGen(tName), mustFlip);
};
Mesh.prototype.prepareForGL = function(skel) {
var finishShaders;
finishShaders = (function(_this) {
return function() {
if (_this.skinningShader.isValid()) {
_this.createGLVBOs(skel);
return _this.cacheGLUniformLocations();
}
};
})(this);
this.createShaders(finishShaders, skel.getBonesCount());
this.makeVertexArraysForBones(skel);
this.makeVertexArraysForMorphs(skel);
this.generateBindPose(skel);
if (this.USE_TEXTURES) {
this.boneTexture = this.gl.createTexture();
return this.twistTexture = this.gl.createTexture();
}
};
Mesh.prototype.makeVertexArraysForBones = function(skel) {
var b, bb, bone, k, l, len, m, nV4, o, ref, ref1, ref2, results, scale, stw, v, v4, vertex, wtw;
nV4 = this.vertices.length * 4;
for (k = l = 0, ref = nV4; 0 <= ref ? l < ref : l > ref; k = 0 <= ref ? ++l : --l) {
this.boneIxs[k] = 0;
this.boneWeights[k] = 0;
}
if (this.DO_ARM_TWISTS) {
for (k = m = 0, ref1 = nV4; 0 <= ref1 ? m < ref1 : m > ref1; k = 0 <= ref1 ? ++m : --m) {
this.boneTwists[k] = -1;
}
}
ref2 = this.vertices;
results = [];
for (v = o = 0, len = ref2.length; o < len; v = ++o) {
vertex = ref2[v];
v4 = v * 4;
results.push((function() {
var p, ref3, results1;
results1 = [];
for (b = p = 0, ref3 = vertex.getNumBones(); 0 <= ref3 ? p < ref3 : p > ref3; b = 0 <= ref3 ? ++p : --p) {
bb = skel.getBoneIndex(vertex.getBone4cc(b));
this.boneIxs[v4 + b] = bb;
this.boneWeights[v4 + b] = vertex.getWeight(b);
if (this.DO_ARM_TWISTS && !this._SUPPRESS_A_T) {
scale = -1;
bone = skel.getBone(bb);
stw = bone.doesShoulderTwist();
wtw = bone.doesWristTwist();
if (stw || wtw) {
scale = (vertex.getBoneEndDistance(b)) / (bone.getLength());
if (scale < 0) {
scale = 0;
}
if (1 < scale) {
scale = 1;
}
if (stw) {
scale = 1 - scale;
}
}
results1.push(this.boneTwists[v4 + b] = scale);
} else {
results1.push(void 0);
}
}
return results1;
}).call(this));
}
return results;
};
Mesh.prototype.makeVertexArraysForMorphs = function(skel) {
var globalHeadRot, headBone;
headBone = skel.getBoneBy4CC(FourCC.fourCCInt("HEAD"));
globalHeadRot = RQ.fromRQ((headBone.getGlobalTRX()).rot());
globalHeadRot.setPostMultiply(RQ.ROT_NEG_PI_BY_2_ON_Z);
return this.morphsManager.makeVertexArrays(this.vertexDuplicateIndices, globalHeadRot);
};
Mesh.prototype.generateBindPose = function(skeleton) {
var b, bone, bpTRX, i, l, len, m, norm3V, normXYZ, o, offset3V, offsetXYZ, ref, ref1, v, v3, v4, vertex, weight;
offset3V = V3.create();
offsetXYZ = offset3V.xyz;
norm3V = V3.create();
normXYZ = norm3V.xyz;
ref = this.vertices;
for (v = l = 0, len = ref.length; l < len; v = ++l) {
vertex = ref[v];
v3 = v * 3;
v4 = v * 4;
for (b = m = 0, ref1 = vertex.getNumBones(); 0 <= ref1 ? m < ref1 : m > ref1; b = 0 <= ref1 ? ++m : --m) {
bone = skeleton.getBone(this.boneIxs[v4 + b]);
weight = this.boneWeights[v4 + b];
bpTRX = bone.getBindPoseTRX();
offset3V.setFromE3V(vertex.getOffset(b));
norm3V.setFromE3V(vertex.getBaseNormal(b));
bpTRX.transform(offset3V);
(bpTRX.rot()).rotate(norm3V);
for (i = o = 0; o < 3; i = ++o) {
this.bindPos[v3 + i] += offsetXYZ[i] * weight;
this.bindNorm[v3 + i] += normXYZ[i] * weight;
}
}
}
return void 0;
};
Mesh.prototype.createGLVBOs = function(skeleton) {
var GL, setVBO_std, ssal;
GL = this.gl;
ssal = (function(_this) {
return function(id) {
return _this.skinningShader.getAttributeLocation(id);
};
})(this);
setVBO_std = (function(_this) {
return function(id, n, buf) {
_this.vbos[id] = VBO.makeStd(GL, n, buf, ssal(id));
return void 0;
};
})(this);
setVBO_std("BindPos", 3, this.bindPos);
setVBO_std("BindNorm", 3, this.bindNorm);
setVBO_std("BoneIxs", 4, this.boneIxs);
setVBO_std("BoneWeights", 4, this.boneWeights);
if (this.DO_ARM_TWISTS) {
setVBO_std("BoneTwists", 4, this.boneTwists);
}
setVBO_std("VSTexCoord0", 2, this.texCoords);
this.morphsManager.createGLVBOs(GL, ssal);
this.vbos["TriStripIndices"] = VBO.makeEls(GL, 1, this.triStripIndices, GL.TRIANGLE_STRIP, false);
return void 0;
};
Mesh.prototype.cacheGLUniformLocations = function() {
var ssuLoc, ssuaLoc;
ssuLoc = (function(_this) {
return function(unm) {
return _this.skinningShader.getUniformLocation(unm);
};
})(this);
ssuaLoc = function(uanm) {
return ssuLoc(uanm + "[0]");
};
this.uniformMVMat = ssuLoc("ModelViewMat");
this.uniformMVPMat = ssuLoc("ModelViewProjMat");
if (this.DO_TRX_BONE_UNIFORMS) {
if (!this.TEST_CPU_TRX_TO_MAT) {
if (this.USE_TEXTURES) {
this.uniformSkelXformsWidth = ssuLoc("SkelXformsWidth");
this.uniformSkelXformsHeight = ssuLoc("SkelXformsHeight");
this.uniformSkelXforms = ssuLoc("SkelXforms");
if (this.DO_ARM_TWISTS) {
this.uniformBoneTwistWidth = ssuLoc("BoneTwistWidth");
this.uniformBoneTwistHeight = ssuLoc("BoneTwistHeight");
this.uniformBoneTwistData = ssuLoc("BoneTwistData");
}
} else {
this.uniformSkelXforms = ssuaLoc("SkelXforms");
if (this.DO_ARM_TWISTS) {
this.uniformBoneTwistData = ssuaLoc("BoneTwistData");
}
}
} else {
this.uniformBones = ssuaLoc("Bones");
}
} else {
this.uniformBones = ssuaLoc("Bones");
}
this.uniformMorphWeights = ssuLoc("MorphWeights");
return this.uniformTexture = ssuLoc("Texture");
};
Mesh.prototype.draw = function(skeleton, currentMorphs, x, y, z, viewMat, projMat) {
var ref, ref1;
if (((ref = this.skinningShader) != null ? ref.isValid() : void 0) && ((ref1 = this.texture) != null ? ref1.isValid() : void 0)) {
return this.doDraw(skeleton, currentMorphs, x, y, z, viewMat, projMat);
}
};
Mesh.prototype.doDraw = function(skeleton, currentMorphs, x, y, z, viewMat, projMat) {
var GL, GL_A_BUF, GL_EL_A_BUF, avbo, avbos, avids, id, l, len, len1, m, mWeights, skelXforms, texHeight, texWidth, twistData;
this.morphsManager.setGLDataForDraw(currentMorphs);
M4.setTRComposeT(this.modelViewMat, viewMat, x, y, z);
M4.setProduct(this.modelViewProjMat, projMat, this.modelViewMat);
GL = this.gl;
GL_A_BUF = GL.ARRAY_BUFFER;
GL_EL_A_BUF = GL.ELEMENT_ARRAY_BUFFER;
GL.useProgram(this.skinningShader.getHandle());
GL.uniformMatrix4fv(this.uniformMVMat, false, this.modelViewMat);
GL.uniformMatrix4fv(this.uniformMVPMat, false, this.modelViewProjMat);
if (this.DO_TRX_BONE_UNIFORMS) {
if (!this.TEST_CPU_TRX_TO_MAT) {
skelXforms = skeleton.getSkelXformsData();
twistData = skeleton.getBoneTwistData();
if (this.USE_TEXTURES) {
texWidth = skeleton.getSkelTexWidth();
texHeight = skeleton.getSkelTexHeight();
GL.activeTexture(GL.TEXTURE1);
GL.bindTexture(GL.TEXTURE_2D, this.boneTexture);
GL.uniform1i(this.uniformSkelXforms, 1);
GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, false);
GL.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
GL.pixelStorei(GL.UNPACK_ALIGNMENT, 4);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, texWidth, texHeight, 0, GL.RGBA, GL.FLOAT, skelXforms);
GL.uniform1i(this.uniformSkelXformsWidth, texWidth);
GL.uniform1i(this.uniformSkelXformsHeight, texHeight);
if (this.DO_ARM_TWISTS) {
texWidth = skeleton.getTwistTexWidth();
texHeight = skeleton.getTwistTexHeight();
GL.activeTexture(GL.TEXTURE2);
GL.bindTexture(GL.TEXTURE_2D, this.twistTexture);
GL.uniform1i(this.uniformBoneTwistData, 2);
GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, false);
GL.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
GL.pixelStorei(GL.UNPACK_ALIGNMENT, 4);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, texWidth, texHeight, 0, GL.RGBA, GL.FLOAT, twistData);
GL.uniform1i(this.uniformBoneTwistWidth, texWidth);
GL.uniform1i(this.uniformBoneTwistHeight, texHeight);
}
} else {
GL.uniformMatrix4fv(this.uniformSkelXforms, false, skelXforms);
if (this.DO_ARM_TWISTS) {
GL.uniform4fv(this.uniformBoneTwistData, twistData);
}
}
} else {
GL.uniform4fv(this.uniformBones, skeleton.getVSSkinMatRows());
}
} else {
GL.uniform4fv(this.uniformBones, skeleton.getSkinMatRows());
}
mWeights = this.morphsManager.getMorphWeights();
GL.uniform4fv(this.uniformMorphWeights, mWeights);
GL.activeTexture(GL.TEXTURE0);
GL.bindTexture(GL.TEXTURE_2D, this.texture.getHandle());
GL.uniform1i(this.uniformTexture, 0);
avids = ["BindPos", "BindNorm", "BoneIxs", "BoneWeights"];
if (this.DO_ARM_TWISTS) {
avids.push("BoneTwists");
}
avids.push("VSTexCoord0");
avbos = (function() {
var l, len, results;
results = [];
for (l = 0, len = avids.length; l < len; l++) {
id = avids[l];
results.push(this.vbos[id]);
}
return results;
}).call(this);
for (l = 0, len = avbos.length; l < len; l++) {
avbo = avbos[l];
avbo.enableAttrib();
}
this.morphsManager.enableMorphVBOs();
this.vbos["TriStripIndices"].drawElements();
this.morphsManager.disableMorphVBOs();
for (m = 0, len1 = avbos.length; m < len1; m++) {
avbo = avbos[m];
avbo.disableAttrib();
}
GL.useProgram(null);
return void 0;
};
Mesh.prototype.checkMesh = function(tag, skel) {
var b, b4cc, bb, l, len, max4cc, nb, nondup, ref, results, sb, v, vertex, vl;
max4cc = Math.pow(2, 32) - 1;
sb = skel != null ? skel.getBonesCount() : void 0;
vl = this.vertices.length;
nondup = vl - this.vertexDuplicateIndices.length;
log("* " + tag + " Check Mesh: vertices=" + vl + " of which duplicates=" + this.vertexDuplicateIndices.length);
ref = this.vertices;
results = [];
for (v = l = 0, len = ref.length; l < len; v = ++l) {
vertex = ref[v];
if (v < nondup && v !== vertex.getIndex()) {
log("* Mesh: Mismatch pos=" + v + " index=" + (vertex.getIndex()));
}
nb = vertex.getNumBones();
if (nb == null) {
results.push(log("* Mesh: undefined getNumBones for v=" + v));
} else if (nb < 0 || nb > 4) {
results.push(log("* Mesh: bad ib count (" + nb + ") for v=" + v + "/" + vl));
} else {
results.push((function() {
var m, ref1, results1;
results1 = [];
for (b = m = 0, ref1 = nb; 0 <= ref1 ? m < ref1 : m > ref1; b = 0 <= ref1 ? ++m : --m) {
b4cc = vertex.getBone4cc(b);
if (b4cc == null) {
results1.push(log("* Mesh: undefined getBone4cc for v=" + v + " ib=" + b + "/" + nb));
} else if (b4cc < 0 || b4cc > max4cc) {
results1.push(log("* Mesh: invalid getBone4cc for v=" + v + " ib=" + b + "/" + nb + " b4cc=" + b4cc + "(\"" + (FourCC.fourCCStr(b4cc)) + "\")"));
} else if (skel != null) {
bb = skel.getBoneBy4CC(b4cc);
if (bb == null) {
results1.push(log("* Mesh: missing bone for v=" + v + "/" + vl + " ib=" + b + "/" + nb + " b4cc=" + b4cc + "(\"" + (FourCC.fourCCStr(b4cc)) + "\")"));
} else if (bb < 0 || bb >= sb) {
results1.push(log("* Mesh: bad bone number for v=" + v + "/" + vl + " ib=" + b + "/" + nb + " b4cc=" + b4cc + "(\"" + (FourCC.fourCCStr(b4cc)) + "\") bb=" + bb + "/" + sb));
} else {
results1.push(void 0);
}
} else {
results1.push(void 0);
}
}
return results1;
})());
}
}
return results;
};
return Mesh;
})();
cwaenv.add(Mesh, "Mesh");
}).call(this);
//-------- js/HNSDefs.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var HNSDefs, cwaenv;
cwaenv = this.getCWAEnv();
HNSDefs = (function() {
function HNSDefs() {}
HNSDefs.tokenNameMap = ["", "", "", "", "", "", "", "", "", "hamtab", "hamlinefeed", "", "hampagebreak", "hamreturn", "", "", "", "", "", "", "hamversion40", "", "", "", "", "", "", "", "", "", "", "", "hamspace", "hamexclaim", "hamquery", "hamfullstop", "hamcomma", "hamplus", "hammetaalt", "hamclocku", "hamclockul", "hamclockl", "hamclockdl", "hamclockd", "hamclockdr", "hamclockr", "hamclockur", "hamclockfull", "hamsymmpar", "hamsymmlr", "hamfist", "hamflathand", "hamfinger2", "hamfinger23", "hamfinger23spread", "hamfinger2345", "hamthumboutmod", "hamthumbacrossmod", "hampinch12", "hampinchall", "hampinch12open", "hamcee12", "hamceeall", "hamcee12open hamceeopen", "hamthumbopenmod", "hamfingerstraightmod", "hamfingerbendmod", "hamfingerhookedmod hamfingerhookmod", "hamnondominant", "hamdoublebent", "hamdoublehooked", "", "hamextfingeru", "hamextfingerur", "hamextfingerr", "hamextfingerdr", "hamextfingerd", "hamextfingerdl", "hamextfingerl", "hamextfingerul", "hamextfingerol", "hamextfingero", "hamextfingeror", "hamextfingeril", "hamextfingeri", "hamextfingerir", "hamextfingerui", "hamextfingerdi", "hamextfingerdo", "hamextfingeruo", "", "", "", "hamearlobe", "hamnostrils", "hamshouldertop", "hampalmu", "hampalmur", "hampalmr", "hampalmdr", "hampalmd", "hampalmdl", "hampalml", "hampalmul", "hamreplace", "hamarmextended", "hambehind", "hametc", "hamorirelative", "hamtongue", "hamteeth", "hamstomach", "hamneutralspace", "hamhead", "hamheadtop", "hamforehead", "hameyebrows", "hameyes", "hamnose", "hamear", "hamcheek", "hamlips", "hamchin", "hamunderchin", "hamneck", "hamshoulders", "hamchest", "hamstomach", "hambelowstomach", "hamlrbeside", "hamlrat", "hamUpperarm", "hamelbow", "hamelbowinside", "hamlowerarm", "hamwristback", "hamwristpulse", "hamthumbball", "hampalm", "hamhandback", "hamthumb", "hamindexfinger", "hammiddlefinger", "hamringfinger", "hampinky", "hamthumbside", "hampinkyside", "hambetween", "hamfingertip", "hamfingernail", "hamfingerpad", "hamfingermidjoint", "hamfingerbase", "hamfingerside", "hamwristtopulse", "hamwristtoback", "hamwristtothumb", "hamwristtopinky", "hamcoreftag", "hamcorefref", "hamnomotion", "hammoveu", "hammoveur", "hammover", "hammovedr", "hammoved", "hammovedl", "hammovel", "hammoveul", "hammoveol", "hammoveo", "hammoveor", "hammoveil", "hammovei", "hammoveir", "hammoveui", "hammovedi", "hammovedo", "hammoveuo", "hammovecross", "hammovex", "hamsmallmod", "hamlargemod", "hamarcl", "hamarcu", "hamarcr", "hamarcd", "hamwavy", "hamzigzag", "hamfingerplay", "hamparbegin", "hamparend", "hamcircleo", "hamcirclei", "hamcircled", "hamcircleu", "hamcirclel", "hamcircler", "hamincreasing", "hamdecreasing", "hamclose", "hamtouch", "haminterlock", "hamcross", "hamfast", "hamslow", "hamtense", "hamrest", "hamhalt", "hamrepeatfromstart", "hamrepeatfromstartseveral", "hamrepeatcontinue", "hamrepeatcontinueseveral", "hamseqbegin", "hamseqend", "hamalternatingmotion", "hamrepeatreverse", "hambrushing", "hamnonipsi", "", "hamellipseh", "hamellipseur", "hamellipsev", "hamellipseul", "hammime", "hamaltbegin", "hamaltend", "hamnodding", "hamswinging", "hamtwisting", "hamstircw", "hamstirccw", "", "", "", "", "hamfusionbegin", "hamfusionend", "", "", "hamcircleul", "hamcircledr", "hamcircleur", "hamcircledl", "hamcircleol", "hamcircleir", "hamcircleor", "hamcircleil", "hamcircledo", "hamcircleui", "hamcircledi", "hamcircleuo", "", "", "hamnbs", ""];
HNSDefs.hamMap = (function() {
var i, ix, j, len, len1, ref, ref1, str, strs, theMap;
theMap = {};
ref = HNSDefs.tokenNameMap;
for (ix = i = 0, len = ref.length; i < len; ix = ++i) {
strs = ref[ix];
ref1 = strs.split(" ");
for (j = 0, len1 = ref1.length; j < len1; j++) {
str = ref1[j];
theMap[str] = String.fromCharCode(ix);
}
}
return theMap;
})();
HNSDefs.MOUTH_PICTURE_LETTER = "m";
HNSDefs.EYES_LETTER = "e";
HNSDefs.MOUTH_GESTURE_LETTERS = "djlct";
HNSDefs.NON_MOUTH_RELATED_LETTERS = "sbh" + HNSDefs.EYES_LETTER + "n";
HNSDefs.EYES_TAG_LISTS = ["AD FR HD HI HC UP DN LE RI NO RO LU LD RU RD", "RB RR RL FU", "WB WR WL SB SR SL CB CR CL TB TR TL BB"];
HNSDefs.HNS_SHOULDER_TAG = "hnm_shoulder";
HNSDefs.HNS_BODY_TAG = "hnm_body";
HNSDefs.HNS_HEAD_TAG = "hnm_head";
HNSDefs.HNS_NOSE_TAG = "hnm_nose";
HNSDefs.NON_MOUTH_RELATED_HML_TAGS = [HNSDefs.HNS_SHOULDER_TAG, HNSDefs.HNS_BODY_TAG, HNSDefs.HNS_HEAD_TAG, null, HNSDefs.HNS_NOSE_TAG];
HNSDefs.HNS_EYEGAZE_TAG = "hnm_eyegaze";
HNSDefs.HNS_EYEBROWS_TAG = "hnm_eyebrows";
HNSDefs.HNS_EYELIDS_TAG = "hnm_eyelids";
HNSDefs.EYE_RELATED_HML_TAGS = [HNSDefs.HNS_EYEGAZE_TAG, HNSDefs.HNS_EYEBROWS_TAG, HNSDefs.HNS_EYELIDS_TAG];
HNSDefs.HNS_MOUTHGESTURE_TAG = "hnm_mouthgesture";
HNSDefs.HNS_MOUTHPICTURE_TAG = "hnm_mouthpicture";
HNSDefs.HNS_EXTRA_TAG = "hnm_extra";
HNSDefs.HNS_NONMAN_TAG = "hamnosys_nonmanual";
HNSDefs.PICTURE_ATTR = "picture";
HNSDefs.TAG_ATTR = "tag";
HNSDefs.xmlSpecials = "<>&\'\"";
HNSDefs.xmlEscapes = ["&lt;", "&gt;", "&amp;", "&apos;", "&quot;"];
return HNSDefs;
})();
cwaenv.add(HNSDefs, "HNSDefs");
}).call(this);
//-------- js/antlr3-all-min.js --------
/*
Copyright (c) 2003-2008 Terence Parr. All rights reserved.
Code licensed under the BSD License:
http://www.antlr.org/license.html
Some parts of the ANTLR class:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
*/
if(typeof org=="undefined"||!org){var org={}}if(typeof org.antlr=="undefined"||!org.antlr){org.antlr={}}org.antlr.global=(function(){return this}).call(null);org.antlr.namespace=function(){var A=arguments,E=null,C,B,D;for(C=0;C<A.length;C=C+1){D=A[C].split(".");E=org.antlr.global;for(B=0;B<D.length;B=B+1){E[D[B]]=E[D[B]]||{};E=E[D[B]]}}return E};org.antlr.env=org.antlr.env||{};org.antlr.env.ua=function(){var D={ie:0,opera:0,gecko:0,webkit:0,mobile:null,air:0,rhino:false};var B,A;try{B=navigator.userAgent;if((/KHTML/).test(B)){D.webkit=1}A=B.match(/AppleWebKit\/([^\s]*)/);if(A&&A[1]){D.webkit=parseFloat(A[1]);if(/ Mobile\//.test(B)){D.mobile="Apple"}else{A=B.match(/NokiaN[^\/]*/);if(A){D.mobile=A[0]}}A=B.match(/AdobeAIR\/([^\s]*)/);if(A){D.air=A[0]}}if(!D.webkit){A=B.match(/Opera[\s\/]([^\s]*)/);if(A&&A[1]){D.opera=parseFloat(A[1]);A=B.match(/Opera Mini[^;]*/);if(A){D.mobile=A[0]}}else{A=B.match(/MSIE\s([^;]*)/);if(A&&A[1]){D.ie=parseFloat(A[1])}else{A=B.match(/Gecko\/([^\s]*)/);if(A){D.gecko=1;A=B.match(/rv:([^\s\)]*)/);if(A&&A[1]){D.gecko=parseFloat(A[1])}}}}}}catch(C){}try{if(typeof window=="undefined"&&loadClass){D.rhino=true}}catch(C){}return D}();org.antlr.namespace("org.antlr.runtime.tree");org.antlr.lang=org.antlr.lang||{isArray:function(B){if(B){var A=org.antlr.lang;return A.isNumber(B.length)&&A.isFunction(B.splice)}return false},isBoolean:function(A){return typeof A==="boolean"},isFunction:function(A){return typeof A==="function"},isNull:function(A){return A===null},isNumber:function(A){return typeof A==="number"&&isFinite(A)},isObject:function(A){return(A&&(typeof A==="object"||org.antlr.lang.isFunction(A)))||false},isString:function(A){return typeof A==="string"},isUndefined:function(A){return typeof A==="undefined"},_IEEnumFix:function(C,B){if(org.antlr.env.ua.ie){var E=["toString","valueOf"],A;for(A=0;A<E.length;A=A+1){var F=E[A],D=B[F];if(org.antlr.lang.isFunction(D)&&D!=Object.prototype[F]){C[F]=D}}}},extend:function(D,E,C){if(!E||!D){throw new Error("org.antlr.lang.extend failed, please check that all dependencies are included.")}var B=function(){};B.prototype=E.prototype;D.prototype=new B();D.prototype.constructor=D;D.superclass=E.prototype;if(E.prototype.constructor==Object.prototype.constructor){E.prototype.constructor=E}if(C){for(var A in C){D.prototype[A]=C[A]}org.antlr.lang._IEEnumFix(D.prototype,C)}},augmentObject:function(E,D){if(!D||!E){throw new Error("Absorb failed, verify dependencies.")}var A=arguments,C,F,B=A[2];if(B&&B!==true){for(C=2;C<A.length;C=C+1){E[A[C]]=D[A[C]]}}else{for(F in D){if(B||!E[F]){E[F]=D[F]}}org.antlr.lang._IEEnumFix(E,D)}},augmentProto:function(D,C){if(!C||!D){throw new Error("Augment failed, verify dependencies.")}var A=[D.prototype,C.prototype];for(var B=2;B<arguments.length;B=B+1){A.push(arguments[B])}org.antlr.lang.augmentObject.apply(this,A)},merge:function(){var D={},B=arguments;for(var C=0,A=B.length;C<A;C=C+1){org.antlr.lang.augmentObject(D,B[C],true)}return D},isValue:function(B){var A=org.antlr.lang;return(A.isObject(B)||A.isString(B)||A.isNumber(B)||A.isBoolean(B))},array:{peek:function(B){if(!org.antlr.lang.isArray(B)){throw new Error("org.antlr.lang.array.peek: a is not an array.")}var A=B.length;if(A<=0){throw new Error("org.antlr.lang.array.peek: a is empty.")}return B[A-1]}}};org.antlr.runtime.RecognizerSharedState=function(){this.following=[];this._fsp=-1;this.errorRecovery=false;this.lastErrorIndex=-1;this.failed=false;this.syntaxErrors=0;this.backtracking=0;this.ruleMemo=null;this.token=null;this.tokenStartCharIndex=-1;this.text=null};org.antlr.runtime.IndexOutOfBoundsException=function(A){org.antlr.runtime.IndexOutOfBoundsException.superclass.constructor.call(this,A)};org.antlr.lang.extend(org.antlr.runtime.IndexOutOfBoundsException,Error,{name:"org.antlr.runtime.IndexOutOfBoundsException"});org.antlr.runtime.RecognitionException=function(A){org.antlr.runtime.RecognitionException.superclass.constructor.call(this);this.input=A;this.index=A.index();if(A instanceof org.antlr.runtime.CommonTokenStream){this.token=A.LT(1);this.line=this.token.getLine();this.charPositionInLine=this.token.getCharPositionInLine()}if(A instanceof org.antlr.runtime.tree.TreeNodeStream){this.extractInformationFromTreeNodeStream(A)}else{if(A instanceof org.antlr.runtime.ANTLRStringStream){this.c=A.LA(1);this.line=A.getLine();this.charPositionInLine=A.getCharPositionInLine()}else{this.c=A.LA(1)}}this.message=this.toString()};org.antlr.lang.extend(org.antlr.runtime.RecognitionException,Error,{input:null,index:null,token:null,node:null,c:null,line:null,name:"org.antlr.runtime.RecognitionException",charPositionInLine:null,approximateLineInfo:null,extractInformationFromTreeNodeStream:function(F){var A=F,E,I,D,H,C;this.node=A.LT(1);var B=A.getTreeAdaptor(),G=B.getToken(this.node);if(G){this.token=G;if(G.getLine()<=0){C=-1;E=A.LT(C);while(E){priorPayload=B.getToken(E);if(priorPayload&&priorPayload.getLine()>0){this.line=priorPayload.getLine();this.charPositionInLine=priorPayload.getCharPositionInLine();this.approximateLineInfo=true;break}--C;E=A.LT(C)}}else{this.line=G.getLine();this.charPositionInLine=G.getCharPositionInLine()}}else{if(this.node instanceof org.antlr.runtime.tree.CommonTree){this.line=this.node.getLine();this.charPositionInLine=this.node.getCharPositionInLine();if(this.node instanceof org.antlr.runtime.tree.CommonTree){this.token=this.node.token}}else{D=B.getType(this.node);H=B.getText(this.node);this.token=new org.antlr.runtime.CommonToken(D,H)}}},getUnexpectedType:function(){if(this.input instanceof org.antlr.runtime.CommonTokenStream){return this.token.getType()}else{if(this.input instanceof org.antlr.runtime.tree.TreeNodeStream){var A=this.input;var B=A.getTreeAdaptor();return B.getType(this.node)}else{return this.c}}}});org.antlr.runtime.MismatchedTokenException=function(B,A){if(arguments.length===0){this.expecting=org.antlr.runtime.Token.INVALID_TOKEN_TYPE}else{org.antlr.runtime.MismatchedTokenException.superclass.constructor.call(this,A);this.expecting=B}};org.antlr.lang.extend(org.antlr.runtime.MismatchedTokenException,org.antlr.runtime.RecognitionException,{toString:function(){return"MismatchedTokenException("+this.getUnexpectedType()+"!="+this.expecting+")"},name:"org.antlr.runtime.MismatchedTokenException"});org.antlr.runtime.UnwantedTokenException=function(B,A){if(arguments.length>0){org.antlr.runtime.UnwantedTokenException.superclass.constructor.call(this,B,A)}};org.antlr.lang.extend(org.antlr.runtime.UnwantedTokenException,org.antlr.runtime.MismatchedTokenException,{getUnexpectedToken:function(){return this.token},toString:function(){var A=", expected "+this.expecting;if(this.expecting===org.antlr.runtime.Token.INVALID_TOKEN_TYPE){A=""}if(!org.antlr.lang.isValue(this.token)){return"UnwantedTokenException(found="+A+")"}return"UnwantedTokenException(found="+this.token.getText()+A+")"},name:"org.antlr.runtime.UnwantedTokenException"});org.antlr.runtime.MissingTokenException=function(B,A,C){if(arguments.length>0){org.antlr.runtime.MissingTokenException.superclass.constructor.call(this,B,A);this.inserted=C}};org.antlr.lang.extend(org.antlr.runtime.MissingTokenException,org.antlr.runtime.MismatchedTokenException,{getMissingType:function(){return this.expecting},toString:function(){if(org.antlr.lang.isValue(this.inserted)&&org.antlr.lang.isValue(this.token)){return"MissingTokenException(inserted "+this.inserted+" at "+this.token.getText()+")"}if(org.antlr.lang.isValue(this.token)){return"MissingTokenException(at "+this.token.getText()+")"}return"MissingTokenException"},name:"org.antlr.runtime.MissingTokenException"});org.antlr.runtime.NoViableAltException=function(C,B,D,A){org.antlr.runtime.NoViableAltException.superclass.constructor.call(this,A);this.grammarDecisionDescription=C;this.decisionNumber=B;this.stateNumber=D};org.antlr.lang.extend(org.antlr.runtime.NoViableAltException,org.antlr.runtime.RecognitionException,{toString:function(){if(this.input instanceof org.antlr.runtime.ANTLRStringStream){return"NoViableAltException('"+this.getUnexpectedType()+"'@["+this.grammarDecisionDescription+"])"}else{return"NoViableAltException("+this.getUnexpectedType()+"@["+this.grammarDecisionDescription+"])"}},name:"org.antlr.runtime.NoViableAltException"});org.antlr.runtime.EarlyExitException=function(B,A){org.antlr.runtime.EarlyExitException.superclass.constructor.call(this,A);this.decisionNumber=B};org.antlr.lang.extend(org.antlr.runtime.EarlyExitException,org.antlr.runtime.RecognitionException,{name:"org.antlr.runtime.EarlyExitException"});org.antlr.runtime.MismatchedSetException=function(B,A){org.antlr.runtime.MismatchedSetException.superclass.constructor.call(this,A);this.expecting=B};org.antlr.lang.extend(org.antlr.runtime.MismatchedSetException,org.antlr.runtime.RecognitionException,{toString:function(){return"MismatchedSetException("+this.getUnexpectedType()+"!="+this.expecting+")"},name:"org.antlr.runtime.MismatchedSetException"});org.antlr.runtime.MismatchedNotSetException=function(B,A){org.antlr.runtime.MismatchedNotSetException.superclass.constructor.call(this,B,A)};org.antlr.lang.extend(org.antlr.runtime.MismatchedNotSetException,org.antlr.runtime.MismatchedSetException,{toString:function(){return"MismatchedNotSetException("+this.getUnexpectedType()+"!="+this.expecting+")"},name:"org.antlr.runtime.MismatchedNotSetException"});org.antlr.runtime.MismatchedRangeException=function(B,A,C){if(arguments.length===0){return this}org.antlr.runtime.MismatchedRangeException.superclass.constructor.call(this,C);this.a=B;this.b=A};org.antlr.lang.extend(org.antlr.runtime.MismatchedRangeException,org.antlr.runtime.RecognitionException,{toString:function(){return"MismatchedRangeException("+this.getUnexpectedType()+" not in ["+this.a+","+this.b+"])"},name:"org.antlr.runtime.MismatchedRangeException"});org.antlr.runtime.FailedPredicateException=function(A,C,B){org.antlr.runtime.FailedPredicateException.superclass.constructor.call(this,A);this.ruleName=C;this.predicateText=B};org.antlr.lang.extend(org.antlr.runtime.FailedPredicateException,org.antlr.runtime.RecognitionException,{toString:function(){return"FailedPredicateException("+this.ruleName+",{"+this.predicateText+"}?)"},name:"org.antlr.runtime.FailedPredicateException"});org.antlr.runtime.BitSet=function(A){if(!A){A=org.antlr.runtime.BitSet.BITS}if(org.antlr.lang.isArray(A)){this.bits=A}else{if(org.antlr.lang.isNumber(A)){this.bits=[]}}};org.antlr.lang.augmentObject(org.antlr.runtime.BitSet,{BITS:32,LOG_BITS:5,MOD_MASK:31,bitMask:function(B){var A=B&org.antlr.runtime.BitSet.MOD_MASK;return 1<<A},numWordsToHold:function(A){return(A>>org.antlr.runtime.BitSet.LOG_BITS)+1},wordNumber:function(A){return A>>org.antlr.runtime.BitSet.LOG_BITS},of:function(D,A){var B,F,C,E;if(org.antlr.lang.isNumber(D)){if(org.antlr.lang.isNumber(A)){C=new org.antlr.runtime.BitSet(A+1);for(B=D;B<=A;B++){F=org.antlr.runtime.BitSet.wordNumber(B);C.bits[F]|=org.antlr.runtime.BitSet.bitMask(B)}return C}else{C=new org.antlr.runtime.BitSet(D+1);C.add(D);return C}}else{if(org.antlr.lang.isArray(D)){C=new org.antlr.runtime.BitSet();for(B=D.length-1;B>=0;B--){C.add(D[B])}return C}else{if(D instanceof org.antlr.runtime.BitSet){if(!D){return null}return D}else{if(D instanceof org.antlr.runtime.IntervalSet){if(!D){return null}C=new org.antlr.runtime.BitSet();C.addAll(D);return C}else{if(org.antlr.lang.isObject(D)){E=[];for(B in D){if(org.antlr.lang.isNumber(B)){E.push(B)}}return org.antlr.runtime.BitSet.of(E)}}}}}}});org.antlr.runtime.BitSet.prototype={add:function(A){var B=org.antlr.runtime.BitSet.wordNumber(A);if(B>=this.bits.length){this.growToInclude(A)}this.bits[B]|=org.antlr.runtime.BitSet.bitMask(A)},addAll:function(C){var A,B,D;if(C instanceof org.antlr.runtime.BitSet){this.orInPlace(C)}else{if(C instanceof org.antlr.runtime.IntervalSet){A=C}else{if(org.antlr.lang.isArray(C)){for(B=0;B<C.length;B++){D=C[B];this.add(D)}}else{return }}}},and:function(A){var B=this.clone();B.andInPlace(A);return B},andInPlace:function(A){var C=Math.min(this.bits.length,A.bits.length),B;for(B=C-1;B>=0;B--){this.bits[B]&=A.bits[B]}for(B=C;B<this.bits.length;B++){this.bits[B]=0}},clear:function(B){if(arguments.length===0){var A;for(A=this.bits.length-1;A>=0;A--){this.bits[A]=0}return }var C=org.antlr.runtime.BitSet.wordNumber(B);if(C>=this.bits.length){this.growToInclude(B)}this.bits[C]&=~org.antlr.runtime.BitSet.bitMask(B)},clone:function(){var C,B,A=[];for(C=0,B=this.bits.length;C<B;C++){A[C]=this.bits[C]}return new org.antlr.runtime.BitSet(A)},size:function(){var B=0,A,C,D;for(A=this.bits.length-1;A>=0;A--){C=this.bits[A];if(C!==0){for(D=org.antlr.runtime.BitSet.BITS-1;D>=0;D--){if((C&(1<<D))!==0){B++}}}}return B},equals:function(A){if(!A||!(A instanceof org.antlr.runtime.BitSet)){return false}var B=A,C,D=Math.min(this.bits.length,B.bits.length);for(C=0;C<D;C++){if(this.bits[C]!=B.bits[C]){return false}}if(this.bits.length>D){for(C=D+1;C<this.bits.length;C++){if(this.bits[C]!==0){return false}}}else{if(B.bits.length>D){for(C=D+1;C<B.bits.length;C++){if(B.bits[C]!==0){return false}}}}return true},growToInclude:function(D){var A=Math.max(this.bits.length<<1,org.antlr.runtime.BitSet.numWordsToHold(D)),C=[],B;for(B=0,len=this.bits.length;B<len;B++){C[B]=this.bits[B]}this.bits=C},member:function(A){var B=org.antlr.runtime.BitSet.wordNumber(A);if(B>=this.bits.length){return false}return(this.bits[B]&org.antlr.runtime.BitSet.bitMask(A))!==0},getSingleElement:function(){var A;for(A=0;A<(this.bits.length<<org.antlr.runtime.BitSet.LOG_BITS);A++){if(this.member(A)){return A}}return -1},isNil:function(){var A;for(A=this.bits.length-1;A>=0;A--){if(this.bits[A]!==0){return false}}return true},complement:function(B){if(B){return B.subtract(this)}else{var A=this.clone();A.notInPlace();return A}},notInPlace:function(){var A,D,B,C;if(arguments.length===0){for(B=this.bits.length-1;B>=0;B--){this.bits[B]=~this.bits[B]}}else{if(arguments.length===1){A=0;D=arguments[0]}else{A=arguments[0];D=arguments[1]}this.growToInclude(D);for(B=A;B<=D;B++){C=org.antlr.runtime.BitSet.wordNumber(B);this.bits[C]^=org.antlr.runtime.BitSet.bitMask(B)}}},or:function(A){if(!A){return this}var B=this.clone();B.orInPlace(A);return B},orInPlace:function(A){if(!A){return }if(A.bits.length>this.bits.length){this.setSize(A.bits.length)}var C=Math.min(this.bits.length,A.bits.length),B;for(B=C-1;B>=0;B--){this.bits[B]|=A.bits[B]}},remove:function(A){var B=org.antlr.runtime.BitSet.wordNumber(A);if(B>=this.bits.length){this.growToInclude(A)}this.bits[B]&=~org.antlr.runtime.BitSet.bitMask(A)},setSize:function(A){var B=A-this.bits.length;while(B>=0){this.bits.push(0);B--}},numBits:function(){return this.bits.length<<org.antlr.runtime.BitSet.LOG_BITS},lengthInLongWords:function(){return this.bits.length},subset:function(A){if(!A){return false}return this.and(A).equals(this)},subtractInPlace:function(A){if(!A){return }var B;for(B=0;B<this.bits.length&&B<A.bits.length;B++){this.bits[B]&=~A.bits[B]}},subtract:function(A){if(!A||!(A instanceof org.antlr.runtime.BitSet)){return null}var B=this.clone();B.subtractInPlace(A);return B},toArray:function(){var A=[],C,B=0;for(C=0;C<(this.bits.length<<org.antlr.runtime.BitSet.LOG_BITS);C++){if(this.member(C)){A[B++]=C}}return A},toPackedArray:function(){return this.bits},toString:function(){if(arguments.length===0){return this.toString1(null)}else{if(org.antlr.lang.isString(arguments[0])){if(!org.antlr.lang.isValue(arguments[1])){return this.toString1(null)}else{return this.toString2(arguments[0],arguments[1])}}else{return this.toString1(arguments[0])}}},toString1:function(D){var A="{",E=",",B,C=false;for(B=0;B<(this.bits.length<<org.antlr.runtime.BitSet.LOG_BITS);B++){if(this.member(B)){if(B>0&&C){A+=E}if(D){A+=D.getTokenDisplayName(B)}else{A+=B.toString()}C=true}}return A+"}"},toString2:function(C,B){var D="",A;for(A=0;A<(this.bits.length<<org.antlr.runtime.BitSet.LOG_BITS);A++){if(this.member(A)){if(D.length>0){D+=C}if(A>=B.size()){D+="'"+A+"'"}else{if(!org.antlr.lang.isValue(B.get(A))){D+="'"+A+"'"}else{D+=B.get(A)}}}}return D}};org.antlr.runtime.CharStream={EOF:-1};org.antlr.runtime.CommonToken=function(){var A;this.charPositionInLine=-1;this.channel=0;this.index=-1;if(arguments.length==1){if(org.antlr.lang.isNumber(arguments[0])){this.type=arguments[0]}else{A=arguments[0];this.text=A.getText();this.type=A.getType();this.line=A.getLine();this.index=A.getTokenIndex();this.charPositionInLine=A.getCharPositionInLine();this.channel=A.getChannel();if(A instanceof org.antlr.runtime.CommonToken){this.start=A.start;this.stop=A.stop}}}else{if(arguments.length==2){this.type=arguments[0];this.text=arguments[1];this.channel=0}else{if(arguments.length==5){this.input=arguments[0];this.type=arguments[1];this.channel=arguments[2];this.start=arguments[3];this.stop=arguments[4]}}}};org.antlr.runtime.CommonToken.prototype={getType:function(){return this.type},setLine:function(A){this.line=A},getText:function(){if(org.antlr.lang.isString(this.text)){return this.text}if(!this.input){return null}this.text=this.input.substring(this.start,this.stop);return this.text},setText:function(A){this.text=A},getLine:function(){return this.line},getCharPositionInLine:function(){return this.charPositionInLine},setCharPositionInLine:function(A){this.charPositionInLine=A},getChannel:function(){return this.channel},setChannel:function(A){this.channel=A},setType:function(A){this.type=A},getStartIndex:function(){return this.start},setStartIndex:function(A){this.start=A},getStopIndex:function(){return this.stop},setStopIndex:function(A){this.stop=A},getTokenIndex:function(){return this.index},setTokenIndex:function(A){this.index=A},getInputStream:function(){return this.input},setInputStream:function(A){this.input=A},toString:function(){var B="";if(this.channel>0){B=",channel="+this.channel}var A=this.getText();if(!org.antlr.lang.isNull(A)){A=A.replace(/\n/g,"\\\\n");A=A.replace(/\r/g,"\\\\r");A=A.replace(/\t/g,"\\\\t")}else{A="<no text>"}return"[@"+this.getTokenIndex()+","+this.start+":"+this.stop+"='"+A+"',<"+this.type+">"+B+","+this.line+":"+this.getCharPositionInLine()+"]"}};org.antlr.runtime.Token=function(){};org.antlr.lang.augmentObject(org.antlr.runtime.Token,{EOR_TOKEN_TYPE:1,DOWN:2,UP:3,MIN_TOKEN_TYPE:4,EOF:org.antlr.runtime.CharStream.EOF,EOF_TOKEN:new org.antlr.runtime.CommonToken(org.antlr.runtime.CharStream.EOF),INVALID_TOKEN_TYPE:0,INVALID_TOKEN:new org.antlr.runtime.CommonToken(0),SKIP_TOKEN:new org.antlr.runtime.CommonToken(0),DEFAULT_CHANNEL:0,HIDDEN_CHANNEL:99});org.antlr.lang.augmentObject(org.antlr.runtime.CommonToken,org.antlr.runtime.Token);org.antlr.runtime.tree.RewriteCardinalityException=function(A){this.elementDescription=A};org.antlr.lang.extend(org.antlr.runtime.tree.RewriteCardinalityException,Error,{getMessage:function(){if(org.antlr.lang.isString(this.elementDescription)){return this.elementDescription}return null},name:function(){return"org.antlr.runtime.tree.RewriteCardinalityException"}});org.antlr.runtime.tree.RewriteEmptyStreamException=function(B){var A=org.antlr.runtime.tree.RewriteEmptyStreamException.superclass;A.constructor.call(this,B)};org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEmptyStreamException,org.antlr.runtime.tree.RewriteCardinalityException,{name:function(){return"org.antlr.runtime.tree.RewriteEmptyStreamException"}});org.antlr.runtime.tree.RewriteEarlyExitException=function(B){var A=org.antlr.runtime.tree.RewriteEarlyExitException.superclass;if(org.antlr.lang.isUndefined(B)){B=null}A.constructor.call(this,B)};org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEarlyExitException,org.antlr.runtime.tree.RewriteCardinalityException,{name:function(){return"org.antlr.runtime.tree.RewriteEarlyExitException"}});org.antlr.runtime.MismatchedTreeNodeException=function(B,A){if(B&&A){org.antlr.runtime.MismatchedTreeNodeException.superclass.constructor.call(this,A);this.expecting=B}};org.antlr.lang.extend(org.antlr.runtime.MismatchedTreeNodeException,org.antlr.runtime.RecognitionException,{toString:function(){return"MismatchedTreeNodeException("+this.getUnexpectedType()+"!="+this.expecting+")"},name:"org.antlr.runtime.MismatchedTreeNodeException"});org.antlr.runtime.tree.BaseTree=function(){};org.antlr.runtime.tree.BaseTree.prototype={getChild:function(A){if(!this.children||A>=this.children.length){return null}return this.children[A]},getChildren:function(){return this.children},getFirstChildWithType:function(C){var B,A;for(B=0;this.children&&B<this.children.length;B++){A=this.children[B];if(A.getType()===C){return A}}return null},getChildCount:function(){if(!this.children){return 0}return this.children.length},addChild:function(B){if(!org.antlr.lang.isValue(B)){return }var C=B,E,A,D;if(C.isNil()){if(this.children&&this.children==C.children){throw new Error("attempt to add child list to itself")}if(C.children){if(this.children){E=C.children.length;for(A=0;A<E;A++){D=C.children[A];this.children.push(D);D.setParent(this);D.setChildIndex(this.children.length-1)}}else{this.children=C.children;this.freshenParentAndChildIndexes()}}}else{if(!this.children){this.children=this.createChildrenList()}this.children.push(B);C.setParent(this);C.setChildIndex(this.children.length-1)}},addChildren:function(A){var C,B;for(C=0;C<A.length;C++){B=A[C];this.addChild(B)}},setChild:function(B,A){if(!A){return }if(A.isNil()){throw new Error("Can't set single child to a list")}if(!this.children){this.children=this.createChildrenList()}this.children[B]=A;A.setParent(this);A.setChildIndex(B)},deleteChild:function(B){if(!this.children){return null}if(B<0||B>=this.children.length){throw new Error("Index out of bounds.")}var A=this.children.splice(B,1)[0];this.freshenParentAndChildIndexes(B);return A},replaceChildren:function(H,I,P){if(!this.children){throw new Error("indexes invalid; no children in list")}var O=I-H+1;var A;var K=P;var D=null;if(K.isNil()){D=K.children}else{D=[];D.push(K)}A=D.length;var B=D.length;var N=O-A;var F,G,C,E,M,J,L;if(N===0){F=0;for(G=H;G<=I;G++){C=D[F];this.children[G]=C;C.setParent(this);C.setChildIndex(G);F++}}else{if(N>0){for(F=0;F<B;F++){this.children[H+F]=D[F]}E=H+B;for(M=E;M<=I;M++){J=this.children.splice(E,1)[0]}this.freshenParentAndChildIndexes(H)}else{for(F=0;F<O;F++){this.children[H+F]=D[F]}L=A-O;for(F=O;F<A;F++){this.children.splice(H+F,0,D[F])}this.freshenParentAndChildIndexes(H)}}},createChildrenList:function(){return[]},isNil:function(){return false},freshenParentAndChildIndexes:function(A){if(!org.antlr.lang.isNumber(A)){A=0}var D=this.getChildCount(),C,B;for(C=A;C<D;C++){B=this.getChild(C);B.setChildIndex(C);B.setParent(this)}},sanityCheckParentAndChildIndexes:function(B,A){if(arguments.length===0){B=null;A=-1}if(B!==this.getParent()){throw new Error("parents don't match; expected "+B+" found "+this.getParent())}if(A!==this.getChildIndex()){throw new Error("child indexes don't match; expected "+A+" found "+this.getChildIndex())}var E=this.getChildCount(),D,C;for(D=0;D<E;D++){C=this.getChild(D);C.sanityCheckParentAndChildIndexes(this,D)}},getChildIndex:function(){return 0},setChildIndex:function(A){},getParent:function(){return null},setParent:function(A){},getTree:function(){return this},toStringTree:function(){if(!this.children||this.children.length===0){return this.toString()}var A="",C,B;if(!this.isNil()){A+="(";A+=this.toString();A+=" "}for(C=0;this.children&&C<this.children.length;C++){B=this.children[C];if(C>0){A+=" "}A+=B.toStringTree()}if(!this.isNil()){A+=")"}return A},getLine:function(){return 0},getCharPositionInLine:function(){return 0}};org.antlr.runtime.tree.CommonTree=function(A){this.startIndex=-1;this.stopIndex=-1;this.childIndex=-1;this.parent=null;this.token=null;if(A instanceof org.antlr.runtime.tree.CommonTree){org.antlr.runtime.tree.CommonTree.superclass.constructor.call(this,A);this.token=A.token;this.startIndex=A.startIndex;this.stopIndex=A.stopIndex}else{if(A instanceof org.antlr.runtime.CommonToken){this.token=A}}};org.antlr.lang.extend(org.antlr.runtime.tree.CommonTree,org.antlr.runtime.tree.BaseTree,{getToken:function(){return this.token},dupNode:function(){return new org.antlr.runtime.tree.CommonTree(this)},isNil:function(){return !this.token},getType:function(){if(!this.token){return org.antlr.runtime.Token.INVALID_TOKEN_TYPE}return this.token.getType()},getText:function(){if(!this.token){return null}return this.token.getText()},getLine:function(){if(!this.token||this.token.getLine()===0){if(this.getChildCount()>0){return this.getChild(0).getLine()}return 0}return this.token.getLine()},getCharPositionInLine:function(){if(!this.token||this.token.getCharPositionInLine()===-1){if(this.getChildCount()>0){return this.getChild(0).getCharPositionInLine()}return 0}return this.token.getCharPositionInLine()},getTokenStartIndex:function(){if(this.token){return this.token.getTokenIndex()}return this.startIndex},setTokenStartIndex:function(A){this.startIndex=A},getTokenStopIndex:function(){if(this.token){return this.token.getTokenIndex()}return this.stopIndex},setTokenStopIndex:function(A){this.stopIndex=A},getChildIndex:function(){return this.childIndex},getParent:function(){return this.parent},setParent:function(A){this.parent=A},setChildIndex:function(A){this.childIndex=A},toString:function(){if(this.isNil()){return"nil"}if(this.getType()===org.antlr.runtime.Token.INVALID_TOKEN_TYPE){return"<errornode>"}if(!this.token){return null}return this.token.getText()}});org.antlr.runtime.tree.Tree={INVALID_NODE:new org.antlr.runtime.tree.CommonTree(org.antlr.runtime.Token.INVALID_TOKEN)};org.antlr.runtime.tree.CommonErrorNode=function(A,D,B,C){if(!B||(B.getTokenIndex()<D.getTokenIndex()&&B.getType()!=org.antlr.runtime.Token.EOF)){B=D}this.input=A;this.start=D;this.stop=B;this.trappedException=C};org.antlr.lang.extend(org.antlr.runtime.tree.CommonErrorNode,org.antlr.runtime.tree.CommonTree,{isNil:function(){return false},getType:function(){return org.antlr.runtime.Token.INVALID_TOKEN_TYPE},getText:function(){var C=null;if(this.start instanceof org.antlr.runtime.CommonToken){var B=this.start.getTokenIndex();var A=this.stop.getTokenIndex();if(this.stop.getType()===org.antlr.runtime.Token.EOF){A=this.input.size()}C=this.input.toString(B,A)}else{if(this.start instanceof org.antlr.runtime.tree.CommonTree){C=this.input.toString(this.start,this.stop)}else{C="<unknown>"}}return C},toString:function(){if(this.trappedException instanceof org.antlr.runtime.MissingTokenException){return"<missing type: "+this.trappedException.getMissingType()+">"}else{if(this.trappedException instanceof org.antlr.runtime.UnwantedTokenException){return"<extraneous: "+this.trappedException.getUnexpectedToken()+", resync="+this.getText()+">"}else{if(this.trappedException instanceof org.antlr.runtime.MismatchedTokenException){return"<mismatched token: "+this.trappedException.token+", resync="+this.getText()+">"}else{if(this.trappedException instanceof org.antlr.runtime.NoViableAltException){return"<unexpected: "+this.trappedException.token+", resync="+this.getText()+">"}}}}return"<error: "+this.getText()+">"}});org.antlr.runtime.tree.BaseTreeAdaptor=function(){this.uniqueNodeID=1};org.antlr.runtime.tree.BaseTreeAdaptor.prototype={nil:function(){return this.create(null)},errorNode:function(A,E,C,D){var B=new org.antlr.runtime.tree.CommonErrorNode(A,E,C,D);return B},isNil:function(A){return A.isNil()},dupTree:function(B,C){if(arguments.length===1){C=null}if(!B){return null}var D=this.dupNode(B);this.setChildIndex(D,this.getChildIndex(B));this.setParent(D,C);var G=this.getChildCount(B),A,F,E;for(A=0;A<G;A++){F=this.getChild(B,A);E=this.dupTree(F,B);this.addChild(D,E)}return D},addChild:function(A,B){if(A&&org.antlr.lang.isValue(B)){A.addChild(B)}},becomeRoot:function(D,C){if(D instanceof org.antlr.runtime.CommonToken||!D){D=this.create(D)}var A=D,B=C;if(!C){return D}if(A.isNil()){if(A.getChildCount()>1){throw new Error("more than one node as root (TODO: make exception hierarchy)")}A=A.getChild(0)}A.addChild(B);return A},rulePostProcessing:function(A){var B=A;if(B&&B.isNil()){if(B.getChildCount()===0){B=null}else{if(B.getChildCount()===1){B=B.getChild(0);B.setParent(null);B.setChildIndex(-1)}}}return B},create:function(C,B){var D,A;if(arguments.length===2){if(org.antlr.lang.isString(arguments[1])){D=arguments[1];B=this.createToken(C,D);A=this.create(B);return A}else{B=this.createToken(B);B.setType(C);A=this.create(B);return A}}else{if(arguments.length===3){D=arguments[2];B=this.createToken(B);B.setType(C);B.setText(D);A=this.create(B);return A}}},getType:function(A){A.getType();return 0},setType:function(A,B){throw new Error("don't know enough about Tree node")},getText:function(A){return A.getText()},setText:function(A,B){throw new Error("don't know enough about Tree node")},getChild:function(B,A){return B.getChild(A)},setChild:function(B,A,C){B.setChild(A,C)},deleteChild:function(B,A){return B.deleteChild(A)},getChildCount:function(A){return A.getChildCount()},getUniqueID:function(B){if(!this.treeToUniqueIDMap){this.treeToUniqueIDMap={}}var C=this.treeToUniqueIDMap[B];if(org.antlr.lang.isValue(C)){return C}var A=this.uniqueNodeID;this.treeToUniqueIDMap[B]=A;this.uniqueNodeID++;return A}};org.antlr.runtime.tree.CommonTreeAdaptor=function(){};org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeAdaptor,org.antlr.runtime.tree.BaseTreeAdaptor,{dupNode:function(A){if(!org.antlr.lang.isValue(A)){return null}return A.dupNode()},create:function(A){if(arguments.length>1){return org.antlr.runtime.tree.CommonTreeAdaptor.superclass.create.apply(this,arguments)}return new org.antlr.runtime.tree.CommonTree(A)},createToken:function(A){if(arguments.length===2){return new org.antlr.runtime.CommonToken(arguments[0],arguments[1])}else{return new org.antlr.runtime.CommonToken(arguments[0])}},setTokenBoundaries:function(C,E,A){if(!org.antlr.lang.isValue(C)){return }var D=0,B=0;if(org.antlr.lang.isValue(E)){if(E.getTokenIndex){D=E.getTokenIndex()}else{if(E.getStartIndex){D=E.getStartIndex()}else{D=E.getTokenStartIndex()}}}if(org.antlr.lang.isValue(A)){if(B.getTokenIndex){B=A.getTokenIndex()}else{if(A.getStopIndex){B=A.getStopIndex()}else{B=A.getTokenStopIndex()}}}C.setTokenStartIndex(D);C.setTokenStopIndex(B)},getTokenStartIndex:function(A){if(!A){return -1}return A.getTokenStartIndex()},getTokenStopIndex:function(A){if(!A){return -1}return A.getTokenStopIndex()},getText:function(A){if(!A){return null}return A.getText()},getType:function(A){if(!A){return org.antlr.runtime.Token.INVALID_TOKEN_TYPE}return A.getType()},getToken:function(A){if(A instanceof org.antlr.runtime.tree.CommonTree){return A.getToken()}return null},getChild:function(B,A){if(!B){return null}return B.getChild(A)},getChildCount:function(A){if(!A){return 0}return A.getChildCount()},getParent:function(A){return A.getParent()},setParent:function(A,B){A.setParent(B)},getChildIndex:function(A){return A.getChildIndex()},setChildIndex:function(B,A){B.setChildIndex(A)},replaceChildren:function(D,B,A,C){if(D){D.replaceChildren(B,A,C)}}});org.antlr.runtime.ANTLRStringStream=function(A){this.p=0;this.line=1;this.charPositionInLine=0;this.markDepth=0;this.markers=null;this.lastMarker=null;this.data=A;this.n=A.length};org.antlr.runtime.ANTLRStringStream.prototype={reset:function(){this.p=0;this.line=1;this.charPositionInLine=0;this.markDepth=0},consume:function(){if(this.p<this.n){this.charPositionInLine++;if(this.data.charAt(this.p)==="\n"){this.line++;this.charPositionInLine=0}this.p++}},LA:function(B){if(B<0){B++}var A=this.p+B-1;if(A>=this.n||A<0){return org.antlr.runtime.CharStream.EOF}return this.data.charAt(A)},index:function(){return this.p},size:function(){return this.n},mark:function(){if(!this.markers){this.markers=[];this.markers.push(null)}this.markDepth++;var A=null;if(this.markDepth>=this.markers.length){A={};this.markers.push(A)}else{A=this.markers[this.markDepth]}A.p=this.p;A.line=this.line;A.charPositionInLine=this.charPositionInLine;this.lastMarker=this.markDepth;return this.markDepth},rewind:function(A){if(!org.antlr.lang.isNumber(A)){A=this.lastMarker}var B=this.markers[A];this.seek(B.p);this.line=B.line;this.charPositionInLine=B.charPositionInLine;this.release(A)},release:function(A){this.markDepth=A;this.markDepth--},seek:function(A){if(A<=this.p){this.p=A;return }while(this.p<A){this.consume()}},substring:function(B,A){return this.data.substr(B,A-B+1)},getLine:function(){return this.line},getCharPositionInLine:function(){return this.charPositionInLine},setLine:function(A){this.line=A},setCharPositionInLine:function(A){this.charPositionInLine=A},getSourceName:function(){return null}};org.antlr.runtime.ANTLRStringStream.LT=org.antlr.runtime.ANTLRStringStream.LA;org.antlr.runtime.CommonTokenStream=function(A,B){this.p=-1;this.channel=org.antlr.runtime.Token.DEFAULT_CHANNEL;this.v_discardOffChannelTokens=false;this.tokens=[];if(arguments.length>=2){this.channel=B}else{if(arguments.length===1){this.tokenSource=A}}};org.antlr.runtime.CommonTokenStream.prototype={setTokenSource:function(A){this.tokenSource=A;this.tokens=[];this.p=-1;this.channel=org.antlr.runtime.Token.DEFAULT_CHANNEL},fillBuffer:function(){var B=0,C=this.tokenSource.nextToken(),A,D;while(org.antlr.lang.isValue(C)&&C.getType()!=org.antlr.runtime.CharStream.EOF){A=false;if(this.channelOverrideMap){D=this.channelOverrideMap[C.getType()];if(org.antlr.lang.isValue(D)){C.setChannel(D)}}if(this.discardSet&&this.discardSet[C.getType()]){A=true}else{if(this.v_discardOffChannelTokens&&C.getChannel()!=this.channel){A=true}}if(!A){C.setTokenIndex(B);this.tokens.push(C);B++}C=this.tokenSource.nextToken()}this.p=0;this.p=this.skipOffTokenChannels(this.p)},consume:function(){if(this.p<this.tokens.length){this.p++;this.p=this.skipOffTokenChannels(this.p)}},skipOffTokenChannels:function(A){var B=this.tokens.length;while(A<B&&(this.tokens[A]).getChannel()!=this.channel){A++}return A},skipOffTokenChannelsReverse:function(A){while(A>=0&&(this.tokens[A]).getChannel()!=this.channel){A--}return A},setTokenTypeChannel:function(B,A){if(!this.channelOverrideMap){this.channelOverrideMap={}}this.channelOverrideMap[B]=A},discardTokenType:function(A){if(!this.discardSet){this.discardSet={}}this.discardSet[A]=true},discardOffChannelTokens:function(A){this.v_discardOffChannelTokens=A},getTokens:function(F,D,C){if(this.p===-1){this.fillBuffer()}if(arguments.length===0){return this.tokens}if(org.antlr.lang.isArray(C)){C=new org.antlr.runtime.BitSet(C)}else{if(org.antlr.lang.isNumber(C)){C=org.antlr.runtime.BitSet.of(C)}}if(D>=this.tokens.length){D=this.tokens.length-1}if(F<0){F=0}if(F>D){return null}var E=[],B,A;for(B=F;B<=D;B++){A=this.tokens[B];if(!this.types||C.member(A.getType())){E.push(A)}}if(E.length===0){E=null}return E},LT:function(A){if(this.p===-1){this.fillBuffer()}if(A===0){return null}if(A<0){return this.LB(-1*A)}if((this.p+A-1)>=this.tokens.length){return org.antlr.runtime.Token.EOF_TOKEN}var B=this.p,C=1;while(C<A){B=this.skipOffTokenChannels(B+1);C++}if(B>=this.tokens.length){return org.antlr.runtime.Token.EOF_TOKEN}return this.tokens[B]},LB:function(A){if(this.p===-1){this.fillBuffer()}if(A===0){return null}if((this.p-A)<0){return null}var B=this.p,C=1;while(C<=A){B=this.skipOffTokenChannelsReverse(B-1);C++}if(B<0){return null}return this.tokens[B]},get:function(A){return this.tokens[A]},LA:function(A){return this.LT(A).getType()},mark:function(){if(this.p===-1){this.fillBuffer()}this.lastMarker=this.index();return this.lastMarker},release:function(A){},size:function(){return this.tokens.length},index:function(){return this.p},rewind:function(A){if(!org.antlr.lang.isNumber(A)){A=this.lastMarker}this.seek(A)},reset:function(){this.p=-1;this.lastMarker=0},seek:function(A){this.p=A},getTokenSource:function(){return this.tokenSource},getSourceName:function(){return this.getTokenSource().getSourceName()},toString:function(D,C){if(arguments.length===0){if(this.p===-1){this.fillBuffer()}D=0;C=this.tokens.length-1}if(!org.antlr.lang.isNumber(D)&&!org.antlr.lang.isNumber(C)){if(org.antlr.lang.isValue(D)&&org.antlr.lang.isValue(C)){D=D.getTokenIndex();C=C.getTokenIndex()}else{return null}}var A="",B;if(D<0||C<0){return null}if(this.p==-1){this.fillBuffer()}if(C>=this.tokens.length){C=this.tokens.length-1}for(B=D;B<=C;B++){t=this.tokens[B];A=A+this.tokens[B].getText()}return A}};org.antlr.runtime.TokenRewriteStream=function(){var A=org.antlr.runtime.TokenRewriteStream.superclass;this.programs=null;this.lastRewriteTokenIndexes=null;if(arguments.length===0){this.init()}else{A.constructor.apply(this,arguments);this.init()}};(function(){var A=org.antlr.runtime.TokenRewriteStream;org.antlr.lang.augmentObject(A,{DEFAULT_PROGRAM_NAME:"default",PROGRAM_INIT_SIZE:100,MIN_TOKEN_INDEX:0});A.RewriteOperation=function(B,C){this.index=B;this.text=C};A.RewriteOperation.prototype={execute:function(B){return this.index},toString:function(){return this.text}};A.InsertBeforeOp=function(B,C){A.InsertBeforeOp.superclass.constructor.call(this,B,C)};org.antlr.lang.extend(A.InsertBeforeOp,A.RewriteOperation,{execute:function(B){B.push(this.text);return this.index}});A.ReplaceOp=function(D,C,B){A.ReplaceOp.superclass.constructor.call(this,D,B);this.lastIndex=C};org.antlr.lang.extend(A.ReplaceOp,A.RewriteOperation,{execute:function(B){if(org.antlr.lang.isValue(this.text)){B.push(this.text)}return this.lastIndex+1}});A.DeleteOp=function(C,B){A.DeleteOp.superclass.constructor.call(this,C,B)};org.antlr.lang.extend(A.DeleteOp,A.ReplaceOp);org.antlr.lang.extend(A,org.antlr.runtime.CommonTokenStream,{init:function(){this.programs={};this.programs[A.DEFAULT_PROGRAM_NAME]=[];this.lastRewriteTokenIndexes={}},rollback:function(){var B,C;if(arguments.length===1){B=A.DEFAULT_PROGRAM_NAME;C=arguments[0]}else{if(arguments.length===2){B=arguments[0];C=arguments[1]}}var D=this.programs[B];if(D){programs[B]=D.slice(A.MIN_TOKEN_INDEX,this.instructionIndex)}},deleteProgram:function(B){B=B||A.DEFAULT_PROGRAM_NAME;this.rollback(B,A.MIN_TOKEN_INDEX)},addToSortedRewriteList:function(){var H,E;if(arguments.length===1){H=A.DEFAULT_PROGRAM_NAME;E=arguments[0]}else{if(arguments.length===2){H=arguments[0];E=arguments[1]}}var F=this.getProgram(H);var G,I,D,J,B,C;for(I=0,G=F.length;I<G;I++){D=F[I];if(D.index===E.index){if(E instanceof A.ReplaceOp){J=false;for(C=I;C<F.length;C++){B=F[I];if(B.index!==E.index){break}if(B instanceof A.ReplaceOp){F[I]=E;J=true;break}}if(!J){F.splice(C,0,E)}}else{F.splice(I,0,E)}break}else{if(D.index>E.index){F.splice(I,0,E);break}}}if(I===G){F.push(E)}},insertAfter:function(){var C,B,D;if(arguments.length===2){B=A.DEFAULT_PROGRAM_NAME;C=arguments[0];D=arguments[1]}else{if(arguments.length===3){B=arguments[0];C=arguments[1];D=arguments[2]}}if(C instanceof org.antlr.runtime.CommonToken){C=C.index}this.insertBefore(B,C+1,D)},insertBefore:function(){var C,B,D;if(arguments.length===2){B=A.DEFAULT_PROGRAM_NAME;C=arguments[0];D=arguments[1]}else{if(arguments.length===3){B=arguments[0];C=arguments[1];D=arguments[2]}}if(C instanceof org.antlr.runtime.CommonToken){C=C.index}this.addToSortedRewriteList(B,new A.InsertBeforeOp(C,D))},replace:function(){var B,E,C,D;if(arguments.length===2){B=A.DEFAULT_PROGRAM_NAME;E=arguments[0];C=arguments[0];D=arguments[1]}else{if(arguments.length===3){B=A.DEFAULT_PROGRAM_NAME;E=arguments[0];C=arguments[1];D=arguments[2]}}if(arguments.length===4){B=arguments[0];E=arguments[1];C=arguments[2];D=arguments[3]}if(E instanceof org.antlr.runtime.CommonToken){E=E.index}if(C instanceof org.antlr.runtime.CommonToken){C=C.index}if(E>C||C<0||E<0){return }this.addToSortedRewriteList(B,new A.ReplaceOp(E,C,D))},remove:function(){var B=[],C=arguments.length-1;while(C>=0){B[C]=arguments[C];C--}B.push("");this.replace.apply(this,B)},getLastRewriteTokenIndex:function(B){B=B||A.DEFAULT_PROGRAM_NAME;return this.lastRewriteTokenIndexes[B]||-1},setLastRewriteTokenIndex:function(B,C){this.lastRewriteTokenIndexes[B]=C},getProgram:function(B){var C=this.programs[B];if(!C){C=this.initializeProgram(B)}return C},initializeProgram:function(B){var C=[];this.programs[B]=C;return C},toOriginalString:function(E,B){if(!org.antlr.lang.isNumber(E)){E=A.MIN_TOKEN_INDEX}if(!org.antlr.lang.isNumber(B)){B=this.size()-1}var C=[],D;for(D=E;D>=A.MIN_TOKEN_INDEX&&D<=B&&D<this.tokens.length;D++){C.push(this.get(D).getText())}return C.join("")},toString:function(){var J,B,F;if(arguments.length===0){J=A.DEFAULT_PROGRAM_NAME;B=A.MIN_TOKEN_INDEX;F=this.size()-1}else{if(arguments.length===1){J=arguments[0];B=A.MIN_TOKEN_INDEX;F=this.size()-1}else{if(arguments.length===2){J=A.DEFAULT_PROGRAM_NAME;B=arguments[0];F=arguments[1]}}}var H=this.programs[J];if(!H||H.length===0){return this.toOriginalString(B,F)}var E=0,D=B,C=[],G;while(D>=A.MIN_TOKEN_INDEX&&D<=F&&D<this.tokens.length){if(E<H.length){G=H[E];while(G.index<D&&E<H.length){E++;if(E<H.length){G=H[E]}}while(D===G.index&&E<H.length){D=G.execute(C);E++;if(E<H.length){G=H[E]}}}if(D<=F){C.push(this.get(D).getText());D++}}var I;for(I=E;I<H.length;I++){G=H[I];if(G.index>=this.size()){G.execute(C)}}return C.join("")},toDebugString:function(E,B){if(!org.antlr.lang.isNumber(E)){E=A.MIN_TOKEN_INDEX}if(!org.antlr.lang.isNumber(B)){B=this.size()-1}var C=[],D;for(D=E;D>=A.MIN_TOKEN_INDEX&&D<=B&&D<this.tokens.length;D++){C.push(this.get(D))}return C.join("")}})})();org.antlr.runtime.tree.TreeNodeStream=function(){};org.antlr.runtime.tree.CommonTreeNodeStream=function(D,A,B){if(arguments.length===1){A=D;D=new org.antlr.runtime.tree.CommonTreeAdaptor()}if(arguments.length<=2){B=org.antlr.runtime.tree.CommonTreeNodeStream.DEFAULT_INITIAL_BUFFER_SIZE}this.uniqueNavigationNodes=false;this.p=-1;var C=org.antlr.runtime.Token;this.root=A;this.adaptor=D;this.nodes=[];this.down=this.adaptor.create(C.DOWN,"DOWN");this.up=this.adaptor.create(C.UP,"UP");this.eof=this.adaptor.create(C.EOF,"EOF")};org.antlr.lang.augmentObject(org.antlr.runtime.tree.CommonTreeNodeStream,{DEFAULT_INITIAL_BUFFER_SIZE:100,INITIAL_CALL_STACK_SIZE:10});org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeNodeStream,org.antlr.runtime.tree.TreeNodeStream,{StreamIterator:function(){var C=0,B=this.nodes,A=this.eof;return{hasNext:function(){return C<B.length},next:function(){var D=C;C++;if(D<B.length){return B[D]}return A},remove:function(){throw new Error("cannot remove nodes from stream")}}},fillBuffer:function(C){var B=false;if(org.antlr.lang.isUndefined(C)){C=this.root;B=true}var A=this.adaptor.isNil(C);if(!A){this.nodes.push(C)}var F=this.adaptor.getChildCount(C);if(!A&&F>0){this.addNavigationNode(org.antlr.runtime.Token.DOWN)}var E,D;for(E=0;E<F;E++){D=this.adaptor.getChild(C,E);this.fillBuffer(D)}if(!A&&F>0){this.addNavigationNode(org.antlr.runtime.Token.UP)}if(B){this.p=0}},getNodeIndex:function(C){if(this.p==-1){this.fillBuffer()}var B,A;for(B=0;B<this.nodes.length;B++){A=this.nodes[B];if(A===C){return B}}return -1},addNavigationNode:function(B){var A=null;if(B===org.antlr.runtime.Token.DOWN){if(this.hasUniqueNavigationNodes()){A=this.adaptor.create(org.antlr.runtime.Token.DOWN,"DOWN")}else{A=this.down}}else{if(this.hasUniqueNavigationNodes()){A=this.adaptor.create(org.antlr.runtime.Token.UP,"UP")}else{A=this.up}}this.nodes.push(A)},get:function(A){if(this.p===-1){this.fillBuffer()}return this.nodes[A]},LT:function(A){if(this.p===-1){this.fillBuffer()}if(A===0){return null}if(A<0){return this.LB(-1*A)}if((this.p+A-1)>=this.nodes.length){return this.eof}return this.nodes[this.p+A-1]},getCurrentSymbol:function(){return this.LT(1)},LB:function(A){if(A===0){return null}if((this.p-A)<0){return null}return this.nodes[this.p-A]},getTreeSource:function(){return this.root},getSourceName:function(){return this.getTokenStream().getSourceName()},getTokenStream:function(){return this.tokens},setTokenStream:function(A){this.tokens=A},getTreeAdaptor:function(){return this.adaptor},setTreeAdaptor:function(A){this.adaptor=A},hasUniqueNavigationNodes:function(){return this.uniqueNavigationNodes},setUniqueNavigationNodes:function(A){this.uniqueNavigationNodes=A},consume:function(){if(this.p===-1){this.fillBuffer()}this.p++},LA:function(A){return this.adaptor.getType(this.LT(A))},mark:function(){if(this.p===-1){this.fillBuffer()}this.lastMarker=this.index();return this.lastMarker},release:function(A){},index:function(){return this.p},rewind:function(A){if(!org.antlr.lang.isNumber(A)){A=this.lastMarker}this.seek(A)},seek:function(A){if(this.p===-1){this.fillBuffer()}this.p=A},push:function(A){if(!this.calls){this.calls=[]}this.calls.push(this.p);this.seek(A)},pop:function(){var A=this.calls.pop();this.seek(A);return A},reset:function(){this.p=-1;this.lastMarker=0;if(this.calls){this.calls=[]}},size:function(){if(this.p===-1){this.fillBuffer()}return this.nodes.length},iterator:function(){if(this.p===-1){this.fillBuffer()}return this.StreamIterator()},replaceChildren:function(D,B,A,C){if(D){this.adaptor.replaceChildren(D,B,A,C)}},toTokenString:function(E,D){if(this.p===-1){this.fillBuffer()}var A="",C,B;for(C=E;C<this.nodes.length&&C<=D;C++){B=this.nodes[C];A+=" "+this.adaptor.getToken(B)}return A},toString:function(H,D){var A="",E,C,B;if(arguments.length===0){if(this.p===-1){this.fillBuffer()}for(B=0;B<this.nodes.length;B++){C=this.nodes[B];A+=" ";A+=this.adaptor.getType(C)}return A}else{if(!org.antlr.lang.isNumber(H)||!org.antlr.lang.isNumber(D)){return null}if(this.p===-1){this.fillBuffer()}if(H instanceof org.antlr.runtime.tree.CommonTree){}else{}if(D instanceof org.antlr.runtime.tree.CommonTree){}else{}var G,F;if(this.tokens){G=this.adaptor.getTokenStartIndex(H);F=this.adaptor.getTokenStopIndex(D);if(this.adaptor.getType(D)===org.antlr.runtime.Token.UP){F=this.adaptor.getTokenStopIndex(H)}else{if(this.adaptor.getType(D)==org.antlr.runtime.Token.EOF){F=this.size()-2}}return this.tokens.toString(G,F)}C=null;B=0;for(;B<this.nodes.length;B++){C=this.nodes[B];if(C===H){break}}A=E="";C=this.nodes[B];while(C!==D){E=this.adaptor.getText(C);if(!org.antlr.lang.isString(E)){E=" "+this.adaptor.getType(C).toString()}A+=E;B++;C=nodes[B]}E=this.adaptor.getText(D);if(!org.antlr.lang.isString(E)){E=" "+this.adaptor.getType(D).toString()}A+=E;return A}}});org.antlr.runtime.tree.RewriteRuleElementStream=function(C,B,A){this.cursor=0;this.dirty=false;this.elementDescription=B;this.adaptor=C;if(A){if(org.antlr.lang.isArray(A)){this.singleElement=null;this.elements=A}else{this.add(A)}}};org.antlr.runtime.tree.RewriteRuleElementStream.prototype={reset:function(){this.cursor=0;this.dirty=true},add:function(A){if(!org.antlr.lang.isValue(A)){return }if(this.elements){this.elements.push(A);return }if(!org.antlr.lang.isValue(this.singleElement)){this.singleElement=A;return }this.elements=[];this.elements.push(this.singleElement);this.singleElement=null;this.elements.push(A)},nextTree:function(){var B=this.size(),A;if(this.dirty||(this.cursor>=B&&B==1)){A=this._next();return this.dup(A)}A=this._next();return A},_next:function(){var B=this.size();if(B===0){throw new org.antlr.runtime.tree.RewriteEmptyStreamException(this.elementDescription)}if(this.cursor>=B){if(B===1){return this.toTree(this.singleElement)}throw new org.antlr.runtime.tree.RewriteCardinalityException(this.elementDescription)}if(org.antlr.lang.isValue(this.singleElement)){this.cursor++;return this.toTree(this.singleElement)}var A=this.toTree(this.elements[this.cursor]);this.cursor++;return A},toTree:function(A){if(A&&A.getTree){return A.getTree()}return A},hasNext:function(){return(org.antlr.lang.isValue(this.singleElement)&&this.cursor<1)||(this.elements&&this.cursor<this.elements.length)},size:function(){var A=0;if(org.antlr.lang.isValue(this.singleElement)){A=1}if(this.elements){return this.elements.length}return A},getDescription:function(){return this.elementDescription}};org.antlr.runtime.tree.RewriteRuleNodeStream=function(C,B,A){org.antlr.runtime.tree.RewriteRuleNodeStream.superclass.constructor.apply(this,arguments)};org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleNodeStream,org.antlr.runtime.tree.RewriteRuleElementStream,{nextNode:function(){return this._next()},toTree:function(A){return this.adaptor.dupNode(A)},dup:function(){throw new Error("dup can't be called for a node stream.")}});org.antlr.runtime.tree.RewriteRuleTokenStream=function(D,C,B){var A=org.antlr.runtime.tree.RewriteRuleTokenStream.superclass;A.constructor.apply(this,arguments)};org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleTokenStream,org.antlr.runtime.tree.RewriteRuleElementStream,{nextNode:function(){var A=this._next();return this.adaptor.create(A)},nextToken:function(){return this._next()},toTree:function(A){return A},dup:function(A){throw new Error("dup can't be called for a token stream.")}});org.antlr.runtime.tree.RewriteRuleSubtreeStream=function(){var A=org.antlr.runtime.tree.RewriteRuleSubtreeStream.superclass;A.constructor.apply(this,arguments)};org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleSubtreeStream,org.antlr.runtime.tree.RewriteRuleElementStream,{nextNode:function(){var B=this.size(),A;if(this.dirty||(this.cursor>=B&&B===1)){A=this._next();return this.adaptor.dupNode(A)}A=this._next();return A},dup:function(A){return this.adaptor.dupTree(A)}});org.antlr.runtime.BaseRecognizer=function(A){this.state=A||new org.antlr.runtime.RecognizerSharedState()};org.antlr.lang.augmentObject(org.antlr.runtime.BaseRecognizer,{MEMO_RULE_FAILED:-2,MEMO_RULE_UNKNOWN:-1,INITIAL_FOLLOW_STACK_SIZE:100,MEMO_RULE_FAILED_I:-2,DEFAULT_TOKEN_CHANNEL:org.antlr.runtime.Token.DEFAULT_CHANNEL,HIDDEN:org.antlr.runtime.Token.HIDDEN_CHANNEL,NEXT_TOKEN_RULE_NAME:"nextToken"});org.antlr.runtime.BaseRecognizer.prototype={reset:function(){var B,A;if(!this.state){return }this.state._fsp=-1;this.state.errorRecovery=false;this.state.lastErrorIndex=-1;this.state.failed=false;this.state.syntaxErrors=0;this.state.backtracking=0;if(this.state.ruleMemo){for(B=0,A=this.state.ruleMemo.length;B<A;B++){this.state.ruleMemo[B]=null}}},match:function(B,D,A){var C=this.getCurrentInputSymbol(B);if(B.LA(1)===D){B.consume();this.state.errorRecovery=false;this.state.failed=false;return C}if(this.state.backtracking>0){this.state.failed=true;return C}C=this.recoverFromMismatchedToken(B,D,A);return C},matchAny:function(A){this.state.errorRecovery=false;this.state.failed=false;A.consume()},mismatchIsUnwantedToken:function(A,B){return A.LA(2)===B},mismatchIsMissingToken:function(C,A){if(!A){return false}if(A.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE)){if(this.state._fsp>=0){A.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE)}var B=this.computeContextSensitiveRuleFOLLOW();A=A.or(this.viableTokensFollowingThisRule)}if(A.member(C.LA(1))||A.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE)){return true}return false},mismatch:function(B,C,A){if(this.mismatchIsUnwantedToken(B,C)){throw new org.antlr.runtime.UnwantedTokenException(C,B)}else{if(this.mismatchIsMissingToken(B,A)){throw new org.antlr.runtime.MissingTokenException(C,B,null)}}throw new org.antlr.runtime.MismatchedTokenException(C,B)},reportError:function(A){if(this.state.errorRecovery){return }this.state.syntaxErrors++;this.state.errorRecovery=true;this.displayRecognitionError(this.getTokenNames(),A)},displayRecognitionError:function(A,B){var D=this.getErrorHeader(B),C=this.getErrorMessage(B,A);this.emitErrorMessage(D+" "+C)},getErrorHeader:function(A){if(!org.antlr.lang.isNumber(A.line)){A.line=0}return"line "+A.line+":"+A.charPositionInLine},emitErrorMessage:function(A){if(typeof (window)!="undefined"&&window.alert){alert(A)}else{print(A)}},getErrorMessage:function(E,D){var F=(E&&E.getMessage)?E.getMessage():null,A,C;if(E instanceof org.antlr.runtime.UnwantedTokenException){var B=E;C="<unknown>";if(B.expecting==org.antlr.runtime.Token.EOF){C="EOF"}else{C=D[B.expecting]}F="extraneous input "+this.getTokenErrorDisplay(B.getUnexpectedToken())+" expecting "+C}else{if(E instanceof org.antlr.runtime.MissingTokenException){A=E;C="<unknown>";if(A.expecting==org.antlr.runtime.Token.EOF){C="EOF"}else{C=D[A.expecting]}F="missing "+C+" at "+this.getTokenErrorDisplay(E.token)}else{if(E instanceof org.antlr.runtime.MismatchedTokenException){A=E;C="<unknown>";if(A.expecting==org.antlr.runtime.Token.EOF){C="EOF"}else{C=D[A.expecting]}F="mismatched input "+this.getTokenErrorDisplay(E.token)+" expecting "+C}else{if(E instanceof org.antlr.runtime.NoViableAltException){F="no viable alternative at input "+this.getTokenErrorDisplay(E.token)}else{if(E instanceof org.antlr.runtime.EarlyExitException){F="required (...)+ loop did not match anything at input "+this.getTokenErrorDisplay(E.token)}else{if(E instanceof org.antlr.runtime.MismatchedSetException){F="mismatched input "+this.getTokenErrorDisplay(E.token)+" expecting set "+E.expecting}else{if(E instanceof org.antlr.runtime.MismatchedNotSetException){F="mismatched input "+this.getTokenErrorDisplay(E.token)+" expecting set "+E.expecting}else{if(E instanceof org.antlr.runtime.FailedPredicateException){F="rule "+E.ruleName+" failed predicate: {"+E.predicateText+"}?"}}}}}}}}return F},getNumberOfSyntaxErrors:function(){return this.state.syntaxErrors},getTokenErrorDisplay:function(A){var B=A.getText();if(!org.antlr.lang.isValue(B)){if(A.getType()==org.antlr.runtime.Token.EOF){B="<EOF>"}else{B="<"+A.getType()+">"}}B=B.replace(/\n/g,"\\n");B=B.replace(/\r/g,"\\r");B=B.replace(/\t/g,"\\t");return"'"+B+"'"},recover:function(A,B){if(this.state.lastErrorIndex==A.index()){A.consume()}this.state.lastErrorIndex=A.index();var C=this.computeErrorRecoverySet();this.beginResync();this.consumeUntil(A,C);this.endResync()},beginResync:function(){},endResync:function(){},computeErrorRecoverySet:function(){return this.combineFollows(false)},computeContextSensitiveRuleFOLLOW:function(){return this.combineFollows(true)},combineFollows:function(C){var E=this.state._fsp,B,A,D=new org.antlr.runtime.BitSet();for(B=E;B>=0;B--){A=this.state.following[B];D.orInPlace(A);if(C){if(A.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE)){if(B>0){D.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE)}}else{break}}}return D},recoverFromMismatchedToken:function(B,F,A){var E=null;if(this.mismatchIsUnwantedToken(B,F)){E=new org.antlr.runtime.UnwantedTokenException(F,B);this.beginResync();B.consume();this.endResync();this.reportError(E);var D=this.getCurrentInputSymbol(B);B.consume();return D}if(this.mismatchIsMissingToken(B,A)){var C=this.getMissingSymbol(B,E,F,A);E=new org.antlr.runtime.MissingTokenException(F,B,C);this.reportError(E);return C}E=new org.antlr.runtime.MismatchedTokenException(F,B);throw E},recoverFromMismatchedSet:function(B,C,A){if(this.mismatchIsMissingToken(B,A)){this.reportError(C);return this.getMissingSymbol(B,C,org.antlr.runtime.Token.INVALID_TOKEN_TYPE,A)}throw C},getCurrentInputSymbol:function(A){return null},getMissingSymbol:function(B,D,C,A){return null},consumeUntil:function(A,C){var B=A.LA(1);while(B!=org.antlr.runtime.Token.EOF&&!C.member(B)){A.consume();B=A.LA(1)}},pushFollow:function(A){if((this.state._fsp+1)>=this.state.following.length){var C=[];var B;for(B=this.state.following.length-1;B>=0;B--){C[B]=this.state.following[B]}this.state.following=C}this.state._fsp++;this.state.following[this.state._fsp]=A},getRuleInvocationStack:function(B,A){throw new Error("Not implemented.")},getBacktrackingLevel:function(){return this.state.backtracking},getTokenNames:function(){return null},getGrammarFileName:function(){return null},toStrings:function(C){if(!C){return null}var A=[];var B;for(B=0;B<C.length;B++){A.push(C[B].getText())}return A},getRuleMemoization:function(B,A){if(!this.state.ruleMemo[B]){this.state.ruleMemo[B]={}}var C=this.state.ruleMemo[B][A];if(!org.antlr.lang.isNumber(C)){return org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN}return C},alreadyParsedRule:function(B,C){var A=this.getRuleMemoization(C,B.index());if(A==org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN){return false}if(A==org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED){this.state.failed=true}else{B.seek(A+1)}return true},memoize:function(C,D,B){var A=this.state.failed?org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED:C.index()-1;if(!org.antlr.lang.isValue(this.state.ruleMemo)){throw new Error("!!!!!!!!! memo array is null for "+this.getGrammarFileName())}if(D>=this.state.ruleMemo.length){throw new Error("!!!!!!!!! memo size is "+this.state.ruleMemo.length+", but rule index is "+D)}if(org.antlr.lang.isValue(this.state.ruleMemo[D])){this.state.ruleMemo[D][B]=A}},getRuleMemoizationCacheSize:function(){var C=0,A;for(A=0;this.state.ruleMemo&&A<this.state.ruleMemo.length;A++){var B=this.state.ruleMemo[A];if(B){C+=B.length}}return C},traceIn:function(C,B,A){this.emitErrorMessage("enter "+C+" "+A);if(this.state.failed){this.emitErrorMessage(" failed="+this.failed)}if(this.state.backtracking>0){this.emitErrorMessage(" backtracking="+this.state.backtracking)}},traceOut:function(C,B,A){this.emitErrorMessage("exit "+C+" "+A);if(this.state.failed){this.emitErrorMessage(" failed="+this.state.failed)}if(this.state.backtracking>0){this.emitErrorMessage(" backtracking="+this.state.backtracking)}}};org.antlr.runtime.Lexer=function(A,B){if(B){org.antlr.runtime.Lexer.superclass.constructor.call(this,B)}if(A){this.input=A}};org.antlr.lang.extend(org.antlr.runtime.Lexer,org.antlr.runtime.BaseRecognizer,{reset:function(){org.antlr.runtime.Lexer.superclass.reset.call(this);if(org.antlr.lang.isValue(this.input)){this.input.seek(0)}if(!org.antlr.lang.isValue(this.state)){return }this.state.token=null;this.state.type=org.antlr.runtime.Token.INVALID_TOKEN_TYPE;this.state.channel=org.antlr.runtime.Token.DEFAULT_CHANNEL;this.state.tokenStartCharIndex=-1;this.state.tokenStartCharPositionInLine=-1;this.state.tokenStartLine=-1;this.state.text=null},nextToken:function(){while(true){this.state.token=null;this.state.channel=org.antlr.runtime.Token.DEFAULT_CHANNEL;this.state.tokenStartCharIndex=this.input.index();this.state.tokenStartCharPositionInLine=this.input.getCharPositionInLine();this.state.tokenStartLine=this.input.getLine();this.state.text=null;if(this.input.LA(1)===org.antlr.runtime.CharStream.EOF){return org.antlr.runtime.Token.EOF_TOKEN}try{this.mTokens();if(!org.antlr.lang.isValue(this.state.token)){this.emit()}else{if(this.state.token==org.antlr.runtime.Token.SKIP_TOKEN){continue}}return this.state.token}catch(A){if(A instanceof org.antlr.runtime.RecognitionException){this.reportError(A)}else{if(A instanceof org.antlr.runtime.NoViableAltException){this.reportError(A);this.recover(A)}else{throw A}}}}},skip:function(){this.state.token=org.antlr.runtime.Token.SKIP_TOKEN},setCharStream:function(A){this.input=null;this.reset();this.input=A},getCharStream:function(){return this.input},getSourceName:function(){return this.input.getSourceName()},emit:function(){if(arguments.length===0){var A=new org.antlr.runtime.CommonToken(this.input,this.state.type,this.state.channel,this.state.tokenStartCharIndex,this.getCharIndex()-1);A.setLine(this.state.tokenStartLine);A.setText(this.state.text);A.setCharPositionInLine(this.state.tokenStartCharPositionInLine);this.state.token=A;return A}else{this.state.token=arguments[0]}},match:function(C){var B=0,A;if(org.antlr.lang.isString(C)){while(B<C.length){if(this.input.LA(1)!=C.charAt(B)){if(this.state.backtracking>0){this.state.failed=true;return }A=new org.antlr.runtime.MismatchedTokenException(C.charAt(B),this.input);this.recover(A);throw A}B++;this.input.consume();this.state.failed=false}}else{if(org.antlr.lang.isNumber(C)){if(this.input.LA(1)!=C){if(this.state.backtracking>0){this.state.failed=true;return }A=new org.antlr.runtime.MismatchedTokenException(C,this.input);this.recover(A);throw A}this.input.consume();this.state.failed=false}}},matchAny:function(){this.input.consume()},matchRange:function(B,A){if(this.input.LA(1)<B||this.input.LA(1)>A){if(this.state.backtracking>0){this.state.failed=true;return }mre=new org.antlr.runtime.MismatchedRangeException(B,A,this.input);this.recover(mre);throw mre}this.input.consume();this.state.failed=false},getLine:function(){return this.input.getLine()},getCharPositionInLine:function(){return this.input.getCharPositionInLine()},getCharIndex:function(){return this.input.index()},getText:function(){if(org.antlr.lang.isString(this.state.text)){return this.state.text}return this.input.substring(this.state.tokenStartCharIndex,this.getCharIndex()-1)},setText:function(A){this.state.text=A},reportError:function(A){this.displayRecognitionError(this.getTokenNames(),A)},getErrorMessage:function(B,A){var C=null;if(B instanceof org.antlr.runtime.MismatchedTokenException){C="mismatched character "+this.getCharErrorDisplay(B.c)+" expecting "+this.getCharErrorDisplay(B.expecting)}else{if(B instanceof org.antlr.runtime.NoViableAltException){C="no viable alternative at character "+this.getCharErrorDisplay(B.c)}else{if(B instanceof org.antlr.runtime.EarlyExitException){C="required (...)+ loop did not match anything at character "+this.getCharErrorDisplay(B.c)}else{if(B instanceof org.antlr.runtime.MismatchedNotSetException){C="mismatched character "+this.getCharErrorDisplay(B.c)+" expecting set "+B.expecting}else{if(B instanceof org.antlr.runtime.MismatchedSetException){C="mismatched character "+this.getCharErrorDisplay(B.c)+" expecting set "+B.expecting}else{if(B instanceof org.antlr.runtime.MismatchedRangeException){C="mismatched character "+this.getCharErrorDisplay(B.c)+" expecting set "+this.getCharErrorDisplay(B.a)+".."+this.getCharErrorDisplay(B.b)}else{C=org.antlr.runtime.Lexer.superclass.getErrorMessage.call(this,B,A)}}}}}}return C},getCharErrorDisplay:function(B){var A=B;switch(A){case org.antlr.runtime.Token.EOF:A="<EOF>";break;case"\n":A="\\n";break;case"\t":A="\\t";break;case"\r":A="\\r";break}return"'"+A+"'"},recover:function(A){this.input.consume()},traceIn:function(C,B){var A=String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();org.antlr.runtime.Lexer.superclass.traceIn.call(this,C,B,A)},traceOut:function(C,B){var A=String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();org.antlr.runtime.Lexer.superclass.traceOut.call(this,C,B,A)}});org.antlr.runtime.ParserRuleReturnScope=function(){};org.antlr.runtime.ParserRuleReturnScope.prototype={getStart:function(){return this.start},getStop:function(){return this.stop}};org.antlr.runtime.tree.TreeRuleReturnScope=function(){};org.antlr.runtime.tree.TreeRuleReturnScope.prototype={getStart:function(){return this.start}};org.antlr.runtime.Parser=function(A,B){org.antlr.runtime.Parser.superclass.constructor.call(this,B);this.setTokenStream(A)};org.antlr.lang.extend(org.antlr.runtime.Parser,org.antlr.runtime.BaseRecognizer,{reset:function(){org.antlr.runtime.Parser.superclass.reset.call(this);if(org.antlr.lang.isValue(this.input)){this.input.seek(0)}},getCurrentInputSymbol:function(A){return A.LT(1)},getMissingSymbol:function(C,G,E,A){var B="<missing "+this.getTokenNames()[E]+">";var D=new org.antlr.runtime.CommonToken(E,B);var F=C.LT(1);var H;if(F.getType()===org.antlr.runtime.Token.EOF){H=F;F=C.LT(-1);if(!F){F=H}}D.line=F.getLine();D.charPositionInLine=F.getCharPositionInLine();D.channel=org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;return D},setTokenStream:function(A){this.input=null;this.reset();this.input=A},getTokenStream:function(){return this.input},getSourceName:function(){return this.input.getSourceName()},traceIn:function(B,A){org.antlr.runtime.Parser.superclass.traceIn.call(this,B,A,this.input.LT(1))},traceOut:function(B,A){org.antlr.runtime.Parser.superclass.traceOut.call(this,B,A,this.input.LT(1))}});org.antlr.runtime.DFA=function(){};org.antlr.runtime.DFA.prototype={predict:function(C){var F=C.mark(),D=0,B,E,A;try{while(true){B=this.special[D];if(B>=0){D=this.specialStateTransition(B,C);if(D===-1){this.noViableAlt(D,C);return 0}C.consume();continue}if(this.accept[D]>=1){return this.accept[D]}E=C.LA(1);if(E===org.antlr.runtime.Token.EOF){E=-1}else{if(org.antlr.lang.isString(E)){E=E.charCodeAt(0)}}if(E>=this.min[D]&&E<=this.max[D]){A=this.transition[D][E-this.min[D]];if(A<0){if(this.eot[D]>=0){D=this.eot[D];C.consume();continue}this.noViableAlt(D,C);return 0}D=A;C.consume();continue}if(this.eot[D]>=0){D=this.eot[D];C.consume();continue}if(E==org.antlr.runtime.Token.EOF&&this.eof[D]>=0){return this.accept[this.eof[D]]}this.noViableAlt(D,C);return 0}}finally{C.rewind(F)}},noViableAlt:function(C,A){if(this.recognizer.state.backtracking>0){this.recognizer.state.failed=true;return }var B=new org.antlr.runtime.NoViableAltException(this.getDescription(),this.decisionNumber,C,A);this.error(B);throw B},error:function(A){},specialStateTransition:function(B,A){return -1},getDescription:function(){return"n/a"}};org.antlr.lang.augmentObject(org.antlr.runtime.DFA,{unpackEncodedString:function(D){var C,F=[],E=0,G,A,B;for(C=0;C<D.length;C+=2){G=D.charCodeAt(C);A=D.charCodeAt(C+1);if(A===65535){A=-1}for(B=1;B<=G;B++){F[E++]=A}}return F},unpackEncodedStringToUnsignedChars:function(A){return org.antlr.runtime.DFA.unpackEncodedString(A)}});org.antlr.runtime.tree.TreeParser=function(A){org.antlr.runtime.tree.TreeParser.superclass.constructor.call(this,arguments[1]);this.setTreeNodeStream(A)};(function(){var A=org.antlr.runtime.tree.TreeParser;org.antlr.lang.augmentObject(A,{DOWN:org.antlr.runtime.Token.DOWN,UP:org.antlr.runtime.Token.UP});org.antlr.lang.extend(A,org.antlr.runtime.BaseRecognizer,{reset:function(){A.superclass.reset.call(this);if(this.input){this.input.seek(0)}},setTreeNodeStream:function(B){this.input=B},getTreeNodeStream:function(){return this.input},getSourceName:function(){return this.input.getSourceName()},getCurrentInputSymbol:function(B){return B.LT(1)},getMissingSymbol:function(D,F,E,B){var C="<missing "+this.getTokenNames()[E]+">";return new org.antlr.runtime.tree.CommonTree(new org.antlr.runtime.CommonToken(E,C))},matchAny:function(E){this.state.errorRecovery=false;this.state.failed=false;var B=this.input.LT(1);if(this.input.getTreeAdaptor().getChildCount(B)===0){this.input.consume();return }var D=0,C=this.input.getTreeAdaptor().getType(B);while(C!==org.antlr.runtime.Token.EOF&&!(C===A.UP&&D===0)){this.input.consume();B=this.input.LT(1);C=this.input.getTreeAdaptor().getType(B);if(C===A.DOWN){D++}else{if(C===A.UP){D--}}}this.input.consume()},mismatch:function(C,D,B){throw new org.antlr.runtime.MismatchedTreeNodeException(D,C)},getErrorHeader:function(B){return this.getGrammarFileName()+": node from "+(B.approximateLineInfo?"after ":"")+"line "+B.line+":"+B.charPositionInLine},getErrorMessage:function(C,B){var D;if(this instanceof A){D=C.input.getTreeAdaptor();C.token=D.getToken(C.node);if(!org.antlr.lang.isValue(C.token)){C.token=new org.antlr.runtime.CommonToken(D.getType(C.node),D.getText(C.node))}}return A.superclass.getErrorMessage.call(this,C,B)},traceIn:function(C,B){A.superclass.traceIn.call(this,C,B,this.input.LT(1))},traceOut:function(C,B){A.superclass.traceOut.call(this,C,B,this.input.LT(1))}})})();//-------- js/Ham4Parser.js --------
// $ANTLR 3.3 Nov 30, 2010 12:50:56 Ham4Parser.g 2017-01-17 17:44:58
// Parser header
var Ham4Parser = function(input, state) {
if (!state) {
state = new org.antlr.runtime.RecognizerSharedState();
}
(function(){
// Parser members
// /** Logger. */
// private static final Logger	logger = LogManager.getLogger();
// 
// private boolean eReportImmediate = false;
// 
// private static String EOL_4sp = StringUtils.EOL+"    ";
// private int errorCount = 0;
// private String errorString = "";
var errorCount = 0;
var errorString = "";
// /** Constructs a new HNS-4 sign parser, taking input from the given
//  * token stream, and using the given setting of the
//  * <q>Immediate Error Reporting</q> flag.
//  */
// public Ham4Parser(TokenStream lexer, boolean erimmed) {
//     this(lexer);
//     this.eReportImmediate = erimmed;
// }
// 
// /** Does nothing unless parse errors have occurred, in which case
//  * a new {@code RecognitionException} is thrown whose detail message
//  * is a complete parsing error log.
//  */
// public void checkForParseError() throws RecognitionException {
//     if (this.errorCount != 0) {
//         String emsgmid =
//             this.errorCount == 1 ? " error:  " : " errors:"+EOL_4sp;
//         String msg =
//             this.errorCount + emsgmid + this.errorString;
//         System.err.println(msg);
//         // Wrong argument type for ANTLR3
//         // throw new RecognitionException(msg);
//         throw new RecognitionException();
//     }
// }
// /** Reports the parsing error defined by the given exception: an error
//  * message is appended to the overall error text for this parse, and
//  * a message is also generated immediately on standard output
//  * if the parser's <q>Immediate Error Reporting</q> flag is set.
//  */
// public void reportError(RecognitionException ex) {
//     //super.reportError(ex);
//     if (this.eReportImmediate) {
//         System.out.println("#### PARSE-ERR:" + ex.toString() + " ####");
//     }
//     logger.log(LoggerConfig.LOGLevel, LoggerConfig.ANTLRMarker,"Parse: Error: "+ex.toString());
this.reportError = function(ex) {
if (this.logLev >= 300) {
console.warn ("Parsing Error: " + ex);
}
var pfx = errorCount == 0 ? "" : "\n";
errorCount++;
errorString += pfx + "[" + ex + "]";
}
var logLev = 0;
this.setLogLevel = function(lev) {
this.logLev = lev;
};
this.trace = function(str) {
if (this.logLev >= 440) {
console.log(str);
}
};
this.checkErrors = function() {
if (errorCount == 0)
return null
else
return { errCount: errorCount, errText: errorString };
}
// //########  BEGIN GENERATED CODE  ########
}).call(this);
Ham4Parser.superclass.constructor.call(this, input, state);
this.dfa13 = new Ham4Parser.DFA13(this);
this.dfa14 = new Ham4Parser.DFA14(this);
this.dfa16 = new Ham4Parser.DFA16(this);
this.dfa15 = new Ham4Parser.DFA15(this);
this.dfa18 = new Ham4Parser.DFA18(this);
this.dfa21 = new Ham4Parser.DFA21(this);
this.dfa25 = new Ham4Parser.DFA25(this);
this.dfa23 = new Ham4Parser.DFA23(this);
this.dfa26 = new Ham4Parser.DFA26(this);
this.dfa33 = new Ham4Parser.DFA33(this);
this.dfa34 = new Ham4Parser.DFA34(this);
this.dfa35 = new Ham4Parser.DFA35(this);
this.dfa36 = new Ham4Parser.DFA36(this);
this.dfa49 = new Ham4Parser.DFA49(this);
this.dfa54 = new Ham4Parser.DFA54(this);
this.dfa56 = new Ham4Parser.DFA56(this);
this.dfa57 = new Ham4Parser.DFA57(this);
this.dfa58 = new Ham4Parser.DFA58(this);
this.dfa59 = new Ham4Parser.DFA59(this);
this.dfa60 = new Ham4Parser.DFA60(this);
this.dfa61 = new Ham4Parser.DFA61(this);
this.dfa92 = new Ham4Parser.DFA92(this);
this.dfa93 = new Ham4Parser.DFA93(this);
this.dfa95 = new Ham4Parser.DFA95(this);
this.dfa98 = new Ham4Parser.DFA98(this);
this.dfa97 = new Ham4Parser.DFA97(this);
this.dfa96 = new Ham4Parser.DFA96(this);
this.dfa102 = new Ham4Parser.DFA102(this);
this.dfa103 = new Ham4Parser.DFA103(this);
this.dfa104 = new Ham4Parser.DFA104(this);
this.dfa105 = new Ham4Parser.DFA105(this);
this.dfa106 = new Ham4Parser.DFA106(this);
this.dfa107 = new Ham4Parser.DFA107(this);
this.dfa108 = new Ham4Parser.DFA108(this);
this.dfa111 = new Ham4Parser.DFA111(this);
this.dfa109 = new Ham4Parser.DFA109(this);
this.dfa110 = new Ham4Parser.DFA110(this);
this.dfa112 = new Ham4Parser.DFA112(this);
this.dfa113 = new Ham4Parser.DFA113(this);
this.dfa114 = new Ham4Parser.DFA114(this);
this.dfa115 = new Ham4Parser.DFA115(this);
this.dfa116 = new Ham4Parser.DFA116(this);
this.dfa127 = new Ham4Parser.DFA127(this);
this.dfa128 = new Ham4Parser.DFA128(this);
this.dfa129 = new Ham4Parser.DFA129(this);
this.dfa130 = new Ham4Parser.DFA130(this);
this.dfa131 = new Ham4Parser.DFA131(this);
this.dfa132 = new Ham4Parser.DFA132(this);
this.dfa133 = new Ham4Parser.DFA133(this);
this.dfa134 = new Ham4Parser.DFA134(this);
this.dfa136 = new Ham4Parser.DFA136(this);
this.dfa137 = new Ham4Parser.DFA137(this);
this.dfa157 = new Ham4Parser.DFA157(this);
this.dfa171 = new Ham4Parser.DFA171(this);
this.dfa173 = new Ham4Parser.DFA173(this);
this.dfa180 = new Ham4Parser.DFA180(this);
this.dfa181 = new Ham4Parser.DFA181(this);
this.dfa182 = new Ham4Parser.DFA182(this);
/* @todo only create adaptor if output=AST */
this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
};
org.antlr.lang.augmentObject(Ham4Parser, {
EOF: -1,
WS: 4,
HamTab: 5,
HamLinefeed: 6,
HamPagebreak: 7,
HamReturn: 8,
HamVersion40: 9,
HamSpace: 10,
HamExclaim: 11,
HamQuery: 12,
HamFullstop: 13,
HamComma: 14,
HamPlus: 15,
HamMetaalt: 16,
HamClocku: 17,
HamClockul: 18,
HamClockl: 19,
HamClockdl: 20,
HamClockd: 21,
HamClockdr: 22,
HamClockr: 23,
HamClockur: 24,
HamClockfull: 25,
HamSymmpar: 26,
HamSymmlr: 27,
HamFist: 28,
HamFlathand: 29,
HamFinger2: 30,
HamFinger23: 31,
HamFinger23spread: 32,
HamFinger2345: 33,
HamThumboutmod: 34,
HamThumbacrossmod: 35,
HamPinch12: 36,
HamPinchall: 37,
HamPinch12open: 38,
HamCee12: 39,
HamCeeall: 40,
HamCee12open: 41,
HamThumbopenmod: 42,
HamFingerstraightmod: 43,
HamFingerbendmod: 44,
HamFingerhookedmod: 45,
HamNondominant: 46,
HamDoublebent: 47,
HamDoublehooked: 48,
HamExtfingeru: 49,
HamExtfingerur: 50,
HamExtfingerr: 51,
HamExtfingerdr: 52,
HamExtfingerd: 53,
HamExtfingerdl: 54,
HamExtfingerl: 55,
HamExtfingerul: 56,
HamExtfingerol: 57,
HamExtfingero: 58,
HamExtfingeror: 59,
HamExtfingeril: 60,
HamExtfingeri: 61,
HamExtfingerir: 62,
HamExtfingerui: 63,
HamExtfingerdi: 64,
HamExtfingerdo: 65,
HamExtfingeruo: 66,
HamEarlobe: 67,
HamNostrils: 68,
HamShouldertop: 69,
HamPalmu: 70,
HamPalmur: 71,
HamPalmr: 72,
HamPalmdr: 73,
HamPalmd: 74,
HamPalmdl: 75,
HamPalml: 76,
HamPalmul: 77,
HamReplace: 78,
HamArmextended: 79,
HamBehind: 80,
HamEtc: 81,
HamOrirelative: 82,
HamTongue: 83,
HamTeeth: 84,
HamStomach: 85,
HamNeutralspace: 86,
HamHead: 87,
HamHeadtop: 88,
HamForehead: 89,
HamEyebrows: 90,
HamEyes: 91,
HamNose: 92,
HamEar: 93,
HamCheek: 94,
HamLips: 95,
HamChin: 96,
HamUnderchin: 97,
HamNeck: 98,
HamShoulders: 99,
HamChest: 100,
HamBelowstomach: 101,
HamLrbeside: 102,
HamLrat: 103,
HamUpperarm: 104,
HamElbow: 105,
HamElbowinside: 106,
HamLowerarm: 107,
HamWristback: 108,
HamWristpulse: 109,
HamThumbball: 110,
HamPalm: 111,
HamHandback: 112,
HamThumb: 113,
HamIndexfinger: 114,
HamMiddlefinger: 115,
HamRingfinger: 116,
HamPinky: 117,
HamThumbside: 118,
HamPinkyside: 119,
HamBetween: 120,
HamFingertip: 121,
HamFingernail: 122,
HamFingerpad: 123,
HamFingermidjoint: 124,
HamFingerbase: 125,
HamFingerside: 126,
HamWristtopulse: 127,
HamWristtoback: 128,
HamWristtothumb: 129,
HamWristtopinky: 130,
HamCoreftag: 131,
HamCorefref: 132,
HamNomotion: 133,
HamMoveu: 134,
HamMoveur: 135,
HamMover: 136,
HamMovedr: 137,
HamMoved: 138,
HamMovedl: 139,
HamMovel: 140,
HamMoveul: 141,
HamMoveol: 142,
HamMoveo: 143,
HamMoveor: 144,
HamMoveil: 145,
HamMovei: 146,
HamMoveir: 147,
HamMoveui: 148,
HamMovedi: 149,
HamMovedo: 150,
HamMoveuo: 151,
HamMovecross: 152,
HamMovex: 153,
HamSmallmod: 154,
HamLargemod: 155,
HamArcl: 156,
HamArcu: 157,
HamArcr: 158,
HamArcd: 159,
HamWavy: 160,
HamZigzag: 161,
HamFingerplay: 162,
HamParbegin: 163,
HamParend: 164,
HamCircleo: 165,
HamCirclei: 166,
HamCircled: 167,
HamCircleu: 168,
HamCirclel: 169,
HamCircler: 170,
HamIncreasing: 171,
HamDecreasing: 172,
HamClose: 173,
HamTouch: 174,
HamInterlock: 175,
HamCross: 176,
HamFast: 177,
HamSlow: 178,
HamTense: 179,
HamRest: 180,
HamHalt: 181,
HamRepeatfromstart: 182,
HamRepeatfromstartseveral: 183,
HamRepeatcontinue: 184,
HamRepeatcontinueseveral: 185,
HamSeqbegin: 186,
HamSeqend: 187,
HamAlternatingmotion: 188,
HamRepeatreverse: 189,
HamBrushing: 190,
HamNonipsi: 191,
HamEllipseh: 192,
HamEllipseur: 193,
HamEllipsev: 194,
HamEllipseul: 195,
HamMime: 196,
HamAltbegin: 197,
HamAltend: 198,
HamNodding: 199,
HamSwinging: 200,
HamTwisting: 201,
HamStircw: 202,
HamStirccw: 203,
HamFusionbegin: 204,
HamFusionend: 205,
HamCircleul: 206,
HamCircledr: 207,
HamCircleur: 208,
HamCircledl: 209,
HamCircleol: 210,
HamCircleir: 211,
HamCircleor: 212,
HamCircleil: 213,
HamCircledo: 214,
HamCircleui: 215,
HamCircledi: 216,
HamCircleuo: 217,
HamNbs: 218,
HAMSIGNS: 219,
SIGN2: 220,
SIGN1: 221,
ICFG2: 222,
ICFG1: 223,
NMICLIST: 224,
NMICUNIT: 225,
MICFG2: 226,
MICFG1: 227,
HDCONFIG2: 228,
HDCONFIG1: 229,
SPLITHDCFG2: 230,
HDCFGTAIL2: 231,
HSHAPE2: 232,
HSHAPE1: 233,
BASICHDSHP1: 234,
BASICHDSHP: 235,
HSCLASS: 236,
FIBENDING: 237,
THUMBPOS: 238,
FINGERLIST: 239,
FISHPLIST: 240,
FICRSSLIST: 241,
FSHAPE: 242,
FCROSSING: 243,
THSPECIAL: 244,
EXTFIDIR2: 245,
EXTFIDIR1: 246,
EXTFIDIR: 247,
PALMOR2: 248,
PALMOR1: 249,
LOC2: 250,
LOC1: 251,
LOCTNBODYARM: 252,
LOCTNBODY: 253,
LOCTNHAND: 254,
LOCTNARM: 255,
LEVBODY: 256,
LEVHAND: 257,
LEVARM: 258,
HCONSTLLN: 259,
CNTCTBODY: 260,
CNTCTHAND: 261,
CNTCTOFHAND: 262,
A2TLIST: 263,
A1TLIST: 264,
A1LIST: 265,
ACTION2T: 266,
ACTION1T: 267,
ACTION2: 268,
ACTION1: 269,
PARACT2T: 270,
SEQACT2T: 271,
SPLITACT2LOC2: 272,
SPLITACT2T: 273,
PARACT1T: 274,
SEQACT1T: 275,
NMACT1T: 276,
PARACT1: 277,
REPETITIONS: 278,
SIMPLEMVMT: 279,
STRGHTMVMT: 280,
CRCLRMVMT: 281,
REPLACE: 282,
SPLITREPLACETL: 283,
REPLACETAIL1: 284,
HSFINGERITEM: 285,
LOCBODY: 286,
MOVINGREPETITION: 287,
SEQACT1: 288,
SEQFUSEDACT2T: 289,
SEQFUSEDACT1T: 290,
SEQFUSEDACT1: 291,
CNTCTOHHAND: 292,
CNTCTOHARM: 293
});
(function(){
// public class variables
var EOF= -1,
WS= 4,
HamTab= 5,
HamLinefeed= 6,
HamPagebreak= 7,
HamReturn= 8,
HamVersion40= 9,
HamSpace= 10,
HamExclaim= 11,
HamQuery= 12,
HamFullstop= 13,
HamComma= 14,
HamPlus= 15,
HamMetaalt= 16,
HamClocku= 17,
HamClockul= 18,
HamClockl= 19,
HamClockdl= 20,
HamClockd= 21,
HamClockdr= 22,
HamClockr= 23,
HamClockur= 24,
HamClockfull= 25,
HamSymmpar= 26,
HamSymmlr= 27,
HamFist= 28,
HamFlathand= 29,
HamFinger2= 30,
HamFinger23= 31,
HamFinger23spread= 32,
HamFinger2345= 33,
HamThumboutmod= 34,
HamThumbacrossmod= 35,
HamPinch12= 36,
HamPinchall= 37,
HamPinch12open= 38,
HamCee12= 39,
HamCeeall= 40,
HamCee12open= 41,
HamThumbopenmod= 42,
HamFingerstraightmod= 43,
HamFingerbendmod= 44,
HamFingerhookedmod= 45,
HamNondominant= 46,
HamDoublebent= 47,
HamDoublehooked= 48,
HamExtfingeru= 49,
HamExtfingerur= 50,
HamExtfingerr= 51,
HamExtfingerdr= 52,
HamExtfingerd= 53,
HamExtfingerdl= 54,
HamExtfingerl= 55,
HamExtfingerul= 56,
HamExtfingerol= 57,
HamExtfingero= 58,
HamExtfingeror= 59,
HamExtfingeril= 60,
HamExtfingeri= 61,
HamExtfingerir= 62,
HamExtfingerui= 63,
HamExtfingerdi= 64,
HamExtfingerdo= 65,
HamExtfingeruo= 66,
HamEarlobe= 67,
HamNostrils= 68,
HamShouldertop= 69,
HamPalmu= 70,
HamPalmur= 71,
HamPalmr= 72,
HamPalmdr= 73,
HamPalmd= 74,
HamPalmdl= 75,
HamPalml= 76,
HamPalmul= 77,
HamReplace= 78,
HamArmextended= 79,
HamBehind= 80,
HamEtc= 81,
HamOrirelative= 82,
HamTongue= 83,
HamTeeth= 84,
HamStomach= 85,
HamNeutralspace= 86,
HamHead= 87,
HamHeadtop= 88,
HamForehead= 89,
HamEyebrows= 90,
HamEyes= 91,
HamNose= 92,
HamEar= 93,
HamCheek= 94,
HamLips= 95,
HamChin= 96,
HamUnderchin= 97,
HamNeck= 98,
HamShoulders= 99,
HamChest= 100,
HamBelowstomach= 101,
HamLrbeside= 102,
HamLrat= 103,
HamUpperarm= 104,
HamElbow= 105,
HamElbowinside= 106,
HamLowerarm= 107,
HamWristback= 108,
HamWristpulse= 109,
HamThumbball= 110,
HamPalm= 111,
HamHandback= 112,
HamThumb= 113,
HamIndexfinger= 114,
HamMiddlefinger= 115,
HamRingfinger= 116,
HamPinky= 117,
HamThumbside= 118,
HamPinkyside= 119,
HamBetween= 120,
HamFingertip= 121,
HamFingernail= 122,
HamFingerpad= 123,
HamFingermidjoint= 124,
HamFingerbase= 125,
HamFingerside= 126,
HamWristtopulse= 127,
HamWristtoback= 128,
HamWristtothumb= 129,
HamWristtopinky= 130,
HamCoreftag= 131,
HamCorefref= 132,
HamNomotion= 133,
HamMoveu= 134,
HamMoveur= 135,
HamMover= 136,
HamMovedr= 137,
HamMoved= 138,
HamMovedl= 139,
HamMovel= 140,
HamMoveul= 141,
HamMoveol= 142,
HamMoveo= 143,
HamMoveor= 144,
HamMoveil= 145,
HamMovei= 146,
HamMoveir= 147,
HamMoveui= 148,
HamMovedi= 149,
HamMovedo= 150,
HamMoveuo= 151,
HamMovecross= 152,
HamMovex= 153,
HamSmallmod= 154,
HamLargemod= 155,
HamArcl= 156,
HamArcu= 157,
HamArcr= 158,
HamArcd= 159,
HamWavy= 160,
HamZigzag= 161,
HamFingerplay= 162,
HamParbegin= 163,
HamParend= 164,
HamCircleo= 165,
HamCirclei= 166,
HamCircled= 167,
HamCircleu= 168,
HamCirclel= 169,
HamCircler= 170,
HamIncreasing= 171,
HamDecreasing= 172,
HamClose= 173,
HamTouch= 174,
HamInterlock= 175,
HamCross= 176,
HamFast= 177,
HamSlow= 178,
HamTense= 179,
HamRest= 180,
HamHalt= 181,
HamRepeatfromstart= 182,
HamRepeatfromstartseveral= 183,
HamRepeatcontinue= 184,
HamRepeatcontinueseveral= 185,
HamSeqbegin= 186,
HamSeqend= 187,
HamAlternatingmotion= 188,
HamRepeatreverse= 189,
HamBrushing= 190,
HamNonipsi= 191,
HamEllipseh= 192,
HamEllipseur= 193,
HamEllipsev= 194,
HamEllipseul= 195,
HamMime= 196,
HamAltbegin= 197,
HamAltend= 198,
HamNodding= 199,
HamSwinging= 200,
HamTwisting= 201,
HamStircw= 202,
HamStirccw= 203,
HamFusionbegin= 204,
HamFusionend= 205,
HamCircleul= 206,
HamCircledr= 207,
HamCircleur= 208,
HamCircledl= 209,
HamCircleol= 210,
HamCircleir= 211,
HamCircleor= 212,
HamCircleil= 213,
HamCircledo= 214,
HamCircleui= 215,
HamCircledi= 216,
HamCircleuo= 217,
HamNbs= 218,
HAMSIGNS= 219,
SIGN2= 220,
SIGN1= 221,
ICFG2= 222,
ICFG1= 223,
NMICLIST= 224,
NMICUNIT= 225,
MICFG2= 226,
MICFG1= 227,
HDCONFIG2= 228,
HDCONFIG1= 229,
SPLITHDCFG2= 230,
HDCFGTAIL2= 231,
HSHAPE2= 232,
HSHAPE1= 233,
BASICHDSHP1= 234,
BASICHDSHP= 235,
HSCLASS= 236,
FIBENDING= 237,
THUMBPOS= 238,
FINGERLIST= 239,
FISHPLIST= 240,
FICRSSLIST= 241,
FSHAPE= 242,
FCROSSING= 243,
THSPECIAL= 244,
EXTFIDIR2= 245,
EXTFIDIR1= 246,
EXTFIDIR= 247,
PALMOR2= 248,
PALMOR1= 249,
LOC2= 250,
LOC1= 251,
LOCTNBODYARM= 252,
LOCTNBODY= 253,
LOCTNHAND= 254,
LOCTNARM= 255,
LEVBODY= 256,
LEVHAND= 257,
LEVARM= 258,
HCONSTLLN= 259,
CNTCTBODY= 260,
CNTCTHAND= 261,
CNTCTOFHAND= 262,
A2TLIST= 263,
A1TLIST= 264,
A1LIST= 265,
ACTION2T= 266,
ACTION1T= 267,
ACTION2= 268,
ACTION1= 269,
PARACT2T= 270,
SEQACT2T= 271,
SPLITACT2LOC2= 272,
SPLITACT2T= 273,
PARACT1T= 274,
SEQACT1T= 275,
NMACT1T= 276,
PARACT1= 277,
REPETITIONS= 278,
SIMPLEMVMT= 279,
STRGHTMVMT= 280,
CRCLRMVMT= 281,
REPLACE= 282,
SPLITREPLACETL= 283,
REPLACETAIL1= 284,
HSFINGERITEM= 285,
LOCBODY= 286,
MOVINGREPETITION= 287,
SEQACT1= 288,
SEQFUSEDACT2T= 289,
SEQFUSEDACT1T= 290,
SEQFUSEDACT1= 291,
CNTCTOHHAND= 292,
CNTCTOHARM= 293;
// public instance methods/vars
org.antlr.lang.extend(Ham4Parser, org.antlr.runtime.Parser, {
setTreeAdaptor: function(adaptor) {
this.adaptor = adaptor;
},
getTreeAdaptor: function() {
return this.adaptor;
},
getTokenNames: function() { return Ham4Parser.tokenNames; },
getGrammarFileName: function() { return "Ham4Parser.g"; }
});
org.antlr.lang.augmentObject(Ham4Parser.prototype, {
// inline static return class
hamsinglesign_return: (function() {
Ham4Parser.hamsinglesign_return = function(){};
org.antlr.lang.extend(Ham4Parser.hamsinglesign_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:192:1: hamsinglesign : hamsignseq EOF -> ^( HAMSIGNS ( hamsignseq )? ) ;
// $ANTLR start "hamsinglesign"
hamsinglesign: function() {
var retval = new Ham4Parser.hamsinglesign_return();
retval.start = this.input.LT(1);
var root_0 = null;
var EOF2 = null;
var hamsignseq1 = null;
var EOF2_tree=null;
var stream_EOF=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EOF");
var stream_hamsignseq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule hamsignseq");
try {
// Ham4Parser.g:193:2: ( hamsignseq EOF -> ^( HAMSIGNS ( hamsignseq )? ) )
// Ham4Parser.g:193:6: hamsignseq EOF
this.pushFollow(Ham4Parser.FOLLOW_hamsignseq_in_hamsinglesign735);
hamsignseq1=this.hamsignseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_hamsignseq.add(hamsignseq1.getTree());
EOF2=this.match(this.input,EOF,Ham4Parser.FOLLOW_EOF_in_hamsinglesign745); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_EOF.add(EOF2);
// AST REWRITE
// elements: hamsignseq
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 196:2: -> ^( HAMSIGNS ( hamsignseq )? )
{
// Ham4Parser.g:196:5: ^( HAMSIGNS ( hamsignseq )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HAMSIGNS, "HAMSIGNS"), root_1);
// Ham4Parser.g:196:16: ( hamsignseq )?
if ( stream_hamsignseq.hasNext() ) {
this.adaptor.addChild(root_1, stream_hamsignseq.nextTree());
}
stream_hamsignseq.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hamsignseq_return: (function() {
Ham4Parser.hamsignseq_return = function(){};
org.antlr.lang.extend(Ham4Parser.hamsignseq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:202:1: hamsignseq : ( sign2or1 ( HamPlus sign2or1 )* )? ;
// $ANTLR start "hamsignseq"
hamsignseq: function() {
var retval = new Ham4Parser.hamsignseq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamPlus4 = null;
var sign2or13 = null;
var sign2or15 = null;
var HamPlus4_tree=null;
this.trace("ANTLR Parse: hamsignseq starts "+this.state.backtracking);
try {
// Ham4Parser.g:223:5: ( ( sign2or1 ( HamPlus sign2or1 )* )? )
// Ham4Parser.g:224:9: ( sign2or1 ( HamPlus sign2or1 )* )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:224:9: ( sign2or1 ( HamPlus sign2or1 )* )?
var alt2=2;
var LA2_0 = this.input.LA(1);
if ( ((LA2_0>=HamSymmpar && LA2_0<=HamFinger2345)||(LA2_0>=HamPinch12 && LA2_0<=HamCee12open)||LA2_0==HamNondominant||LA2_0==HamNomotion||LA2_0==HamParbegin||LA2_0==HamSeqbegin) ) {
alt2=1;
}
switch (alt2) {
case 1 :
// Ham4Parser.g:225:13: sign2or1 ( HamPlus sign2or1 )*
this.pushFollow(Ham4Parser.FOLLOW_sign2or1_in_hamsignseq813);
sign2or13=this.sign2or1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign2or13.getTree());
// Ham4Parser.g:226:13: ( HamPlus sign2or1 )*
loop1:
do {
var alt1=2;
var LA1_0 = this.input.LA(1);
if ( (LA1_0==HamPlus) ) {
alt1=1;
}
switch (alt1) {
case 1 :
// Ham4Parser.g:227:17: HamPlus sign2or1
HamPlus4=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_hamsignseq845); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_sign2or1_in_hamsignseq865);
sign2or15=this.sign2or1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign2or15.getTree());
break;
default :
break loop1;
}
} while (true);
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hamsignseq finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sign2or1_return: (function() {
Ham4Parser.sign2or1_return = function(){};
org.antlr.lang.extend(Ham4Parser.sign2or1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:233:1: sign2or1 : ( ( HamNondominant initialconfig1 )=> nondomsign1 | sign2 );
// $ANTLR start "sign2or1"
sign2or1: function() {
var retval = new Ham4Parser.sign2or1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nondomsign16 = null;
var sign27 = null;
this.trace("ANTLR Parse: sign2or1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:252:5: ( ( HamNondominant initialconfig1 )=> nondomsign1 | sign2 )
var alt3=2;
var LA3_0 = this.input.LA(1);
if ( (LA3_0==HamNondominant) ) {
var LA3_1 = this.input.LA(2);
if ( (this.synpred1_Ham4Parser()) ) {
alt3=1;
}
else if ( (true) ) {
alt3=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 3, 1, this.input);
throw nvae;
}
}
else if ( ((LA3_0>=HamSymmpar && LA3_0<=HamFinger2345)||(LA3_0>=HamPinch12 && LA3_0<=HamCee12open)||LA3_0==HamNomotion||LA3_0==HamParbegin||LA3_0==HamSeqbegin) ) {
alt3=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 3, 0, this.input);
throw nvae;
}
switch (alt3) {
case 1 :
// Ham4Parser.g:253:9: ( HamNondominant initialconfig1 )=> nondomsign1
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_nondomsign1_in_sign2or1952);
nondomsign16=this.nondomsign1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, nondomsign16.getTree());
break;
case 2 :
// Ham4Parser.g:257:9: sign2
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_sign2_in_sign2or1968);
sign27=this.sign2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign27.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sign2or1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sign2_return: (function() {
Ham4Parser.sign2_return = function(){};
org.antlr.lang.extend(Ham4Parser.sign2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:260:1: sign2 : ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) ) ;
// $ANTLR start "sign2"
sign2: function() {
var retval = new Ham4Parser.sign2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNomotion13 = null;
var HamNondominant14 = null;
var HamNomotion17 = null;
var symmoperator8 = null;
var initialconfig29 = null;
var a2tstar10 = null;
var initialconfig211 = null;
var a1tstar12 = null;
var initialconfig115 = null;
var a1tstar16 = null;
var initialconfig118 = null;
var a1tstar19 = null;
var HamNomotion13_tree=null;
var HamNondominant14_tree=null;
var HamNomotion17_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_symmoperator=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule symmoperator");
var stream_a2tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a2tstar");
var stream_initialconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig2");
var stream_a1tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tstar");
var stream_initialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig1");
this.trace("ANTLR Parse: sign2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:304:5: ( ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) ) )
// Ham4Parser.g:305:5: ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) )
// Ham4Parser.g:305:5: ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) )
var alt4=4;
switch ( this.input.LA(1) ) {
case HamSymmpar:
case HamSymmlr:
alt4=1;
break;
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
case HamNondominant:
case HamParbegin:
case HamSeqbegin:
alt4=2;
break;
case HamNomotion:
var LA4_6 = this.input.LA(2);
if ( (this.synpred2_Ham4Parser()) ) {
alt4=3;
}
else if ( (true) ) {
alt4=4;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 6, this.input);
throw nvae;
}
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);
throw nvae;
}
switch (alt4) {
case 1 :
// Ham4Parser.g:306:9: symmoperator initialconfig2 a2tstar
this.pushFollow(Ham4Parser.FOLLOW_symmoperator_in_sign21009);
symmoperator8=this.symmoperator();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_symmoperator.add(symmoperator8.getTree());
this.pushFollow(Ham4Parser.FOLLOW_initialconfig2_in_sign21019);
initialconfig29=this.initialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig2.add(initialconfig29.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a2tstar_in_sign21029);
a2tstar10=this.a2tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a2tstar.add(a2tstar10.getTree());
// AST REWRITE
// elements: initialconfig2, symmoperator, a2tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 309:6: -> ^( SIGN2 symmoperator initialconfig2 a2tstar )
{
// Ham4Parser.g:309:9: ^( SIGN2 symmoperator initialconfig2 a2tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_symmoperator.nextTree());
this.adaptor.addChild(root_1, stream_initialconfig2.nextTree());
this.adaptor.addChild(root_1, stream_a2tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:311:9: initialconfig2 a1tstar
this.pushFollow(Ham4Parser.FOLLOW_initialconfig2_in_sign21062);
initialconfig211=this.initialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig2.add(initialconfig211.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21072);
a1tstar12=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar12.getTree());
// AST REWRITE
// elements: initialconfig2, a1tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 313:6: -> ^( SIGN2 initialconfig2 a1tstar )
{
// Ham4Parser.g:313:9: ^( SIGN2 initialconfig2 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_initialconfig2.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:322:9: ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar
HamNomotion13=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_sign21138); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion13);
HamNondominant14=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_sign21148); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant14);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_sign21158);
initialconfig115=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig115.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21168);
a1tstar16=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar16.getTree());
// AST REWRITE
// elements: a1tstar, HamNomotion, HamNondominant, initialconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 328:6: -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar )
{
// Ham4Parser.g:328:9: ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:330:9: HamNomotion initialconfig1 a1tstar
HamNomotion17=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_sign21203); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion17);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_sign21213);
initialconfig118=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig118.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21223);
a1tstar19=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar19.getTree());
// AST REWRITE
// elements: initialconfig1, a1tstar, HamNomotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 333:6: -> ^( SIGN2 HamNomotion initialconfig1 a1tstar )
{
// Ham4Parser.g:333:9: ^( SIGN2 HamNomotion initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sign2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nondomsign1_return: (function() {
Ham4Parser.nondomsign1_return = function(){};
org.antlr.lang.extend(Ham4Parser.nondomsign1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:337:1: nondomsign1 : HamNondominant initialconfig1 a1tstar -> ^( SIGN1 HamNondominant initialconfig1 a1tstar ) ;
// $ANTLR start "nondomsign1"
nondomsign1: function() {
var retval = new Ham4Parser.nondomsign1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNondominant20 = null;
var initialconfig121 = null;
var a1tstar22 = null;
var HamNondominant20_tree=null;
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_initialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig1");
var stream_a1tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tstar");
this.trace("ANTLR Parse: nondomsign1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:355:5: ( HamNondominant initialconfig1 a1tstar -> ^( SIGN1 HamNondominant initialconfig1 a1tstar ) )
// Ham4Parser.g:355:9: HamNondominant initialconfig1 a1tstar
HamNondominant20=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_nondomsign11275); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant20);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_nondomsign11285);
initialconfig121=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig121.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_nondomsign11295);
a1tstar22=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar22.getTree());
// AST REWRITE
// elements: HamNondominant, initialconfig1, a1tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 359:9: -> ^( SIGN1 HamNondominant initialconfig1 a1tstar )
{
// Ham4Parser.g:359:12: ^( SIGN1 HamNondominant initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN1, "SIGN1"), root_1);
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nondomsign1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
symmoperator_return: (function() {
Ham4Parser.symmoperator_return = function(){};
org.antlr.lang.extend(Ham4Parser.symmoperator_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:362:1: symmoperator : ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ;
// $ANTLR start "symmoperator"
symmoperator: function() {
var retval = new Ham4Parser.symmoperator_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set23 = null;
var HamFingerstraightmod24 = null;
var HamLargemod25 = null;
var HamLargemod26 = null;
var HamFingerstraightmod27 = null;
var HamAlternatingmotion28 = null;
var HamNonipsi29 = null;
var set23_tree=null;
var HamFingerstraightmod24_tree=null;
var HamLargemod25_tree=null;
var HamLargemod26_tree=null;
var HamFingerstraightmod27_tree=null;
var HamAlternatingmotion28_tree=null;
var HamNonipsi29_tree=null;
this.trace("ANTLR Parse: symmoperator starts "+this.state.backtracking);
try {
// Ham4Parser.g:389:5: ( ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4Parser.g:389:9: ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )?
root_0 = this.adaptor.nil();
set23=this.input.LT(1);
if ( (this.input.LA(1)>=HamSymmpar && this.input.LA(1)<=HamSymmlr) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set23));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:394:9: ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )?
var alt7=3;
var LA7_0 = this.input.LA(1);
if ( (LA7_0==HamFingerstraightmod) ) {
alt7=1;
}
else if ( (LA7_0==HamLargemod) ) {
alt7=2;
}
switch (alt7) {
case 1 :
// Ham4Parser.g:395:13: HamFingerstraightmod ( HamLargemod )?
HamFingerstraightmod24=this.match(this.input,HamFingerstraightmod,Ham4Parser.FOLLOW_HamFingerstraightmod_in_symmoperator1425); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamFingerstraightmod24_tree = this.adaptor.create(HamFingerstraightmod24);
this.adaptor.addChild(root_0, HamFingerstraightmod24_tree);
}
// Ham4Parser.g:396:13: ( HamLargemod )?
var alt5=2;
var LA5_0 = this.input.LA(1);
if ( (LA5_0==HamLargemod) ) {
alt5=1;
}
switch (alt5) {
case 1 :
// Ham4Parser.g:396:15: HamLargemod
HamLargemod25=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_symmoperator1441); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamLargemod25_tree = this.adaptor.create(HamLargemod25);
this.adaptor.addChild(root_0, HamLargemod25_tree);
}
break;
}
break;
case 2 :
// Ham4Parser.g:398:13: HamLargemod ( HamFingerstraightmod )?
HamLargemod26=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_symmoperator1468); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamLargemod26_tree = this.adaptor.create(HamLargemod26);
this.adaptor.addChild(root_0, HamLargemod26_tree);
}
// Ham4Parser.g:399:13: ( HamFingerstraightmod )?
var alt6=2;
var LA6_0 = this.input.LA(1);
if ( (LA6_0==HamFingerstraightmod) ) {
alt6=1;
}
switch (alt6) {
case 1 :
// Ham4Parser.g:399:15: HamFingerstraightmod
HamFingerstraightmod27=this.match(this.input,HamFingerstraightmod,Ham4Parser.FOLLOW_HamFingerstraightmod_in_symmoperator1484); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamFingerstraightmod27_tree = this.adaptor.create(HamFingerstraightmod27);
this.adaptor.addChild(root_0, HamFingerstraightmod27_tree);
}
break;
}
break;
}
// Ham4Parser.g:401:9: ( HamAlternatingmotion )?
var alt8=2;
var LA8_0 = this.input.LA(1);
if ( (LA8_0==HamAlternatingmotion) ) {
alt8=1;
}
switch (alt8) {
case 1 :
// Ham4Parser.g:401:11: HamAlternatingmotion
HamAlternatingmotion28=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_symmoperator1510); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion28_tree = this.adaptor.create(HamAlternatingmotion28);
this.adaptor.addChild(root_0, HamAlternatingmotion28_tree);
}
break;
}
// Ham4Parser.g:402:9: ( HamNonipsi )?
var alt9=2;
var LA9_0 = this.input.LA(1);
if ( (LA9_0==HamNonipsi) ) {
alt9=1;
}
switch (alt9) {
case 1 :
// Ham4Parser.g:402:11: HamNonipsi
HamNonipsi29=this.match(this.input,HamNonipsi,Ham4Parser.FOLLOW_HamNonipsi_in_symmoperator1525); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNonipsi29_tree = this.adaptor.create(HamNonipsi29);
this.adaptor.addChild(root_0, HamNonipsi29_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: symmoperator finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
initialconfig2_return: (function() {
Ham4Parser.initialconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.initialconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:408:1: initialconfig2 : ( nminitialconfig )? minitialconfig2 -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 ) ;
// $ANTLR start "initialconfig2"
initialconfig2: function() {
var retval = new Ham4Parser.initialconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nminitialconfig30 = null;
var minitialconfig231 = null;
var stream_minitialconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minitialconfig2");
var stream_nminitialconfig=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nminitialconfig");
this.trace("ANTLR Parse: initialconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:425:5: ( ( nminitialconfig )? minitialconfig2 -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 ) )
// Ham4Parser.g:425:9: ( nminitialconfig )? minitialconfig2
// Ham4Parser.g:425:9: ( nminitialconfig )?
var alt10=2;
var LA10_0 = this.input.LA(1);
if ( (LA10_0==HamSeqbegin) ) {
alt10=1;
}
switch (alt10) {
case 1 :
// Ham4Parser.g:425:11: nminitialconfig
this.pushFollow(Ham4Parser.FOLLOW_nminitialconfig_in_initialconfig21562);
nminitialconfig30=this.nminitialconfig();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nminitialconfig.add(nminitialconfig30.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_minitialconfig2_in_initialconfig21575);
minitialconfig231=this.minitialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_minitialconfig2.add(minitialconfig231.getTree());
// AST REWRITE
// elements: minitialconfig2, nminitialconfig
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 428:9: -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 )
{
// Ham4Parser.g:428:12: ^( ICFG2 ( nminitialconfig )? minitialconfig2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ICFG2, "ICFG2"), root_1);
// Ham4Parser.g:428:20: ( nminitialconfig )?
if ( stream_nminitialconfig.hasNext() ) {
this.adaptor.addChild(root_1, stream_nminitialconfig.nextTree());
}
stream_nminitialconfig.reset();
this.adaptor.addChild(root_1, stream_minitialconfig2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: initialconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
initialconfig1_return: (function() {
Ham4Parser.initialconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.initialconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:431:1: initialconfig1 : ( nminitialconfig )? minitialconfig1 -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 ) ;
// $ANTLR start "initialconfig1"
initialconfig1: function() {
var retval = new Ham4Parser.initialconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nminitialconfig32 = null;
var minitialconfig133 = null;
var stream_minitialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minitialconfig1");
var stream_nminitialconfig=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nminitialconfig");
this.trace("ANTLR Parse: initialconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:448:5: ( ( nminitialconfig )? minitialconfig1 -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 ) )
// Ham4Parser.g:448:9: ( nminitialconfig )? minitialconfig1
// Ham4Parser.g:448:9: ( nminitialconfig )?
var alt11=2;
var LA11_0 = this.input.LA(1);
if ( (LA11_0==HamSeqbegin) ) {
alt11=1;
}
switch (alt11) {
case 1 :
// Ham4Parser.g:448:11: nminitialconfig
this.pushFollow(Ham4Parser.FOLLOW_nminitialconfig_in_initialconfig11634);
nminitialconfig32=this.nminitialconfig();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nminitialconfig.add(nminitialconfig32.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_minitialconfig1_in_initialconfig11647);
minitialconfig133=this.minitialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_minitialconfig1.add(minitialconfig133.getTree());
// AST REWRITE
// elements: minitialconfig1, nminitialconfig
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 451:9: -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 )
{
// Ham4Parser.g:451:12: ^( ICFG1 ( nminitialconfig )? minitialconfig1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ICFG1, "ICFG1"), root_1);
// Ham4Parser.g:451:20: ( nminitialconfig )?
if ( stream_nminitialconfig.hasNext() ) {
this.adaptor.addChild(root_1, stream_nminitialconfig.nextTree());
}
stream_nminitialconfig.reset();
this.adaptor.addChild(root_1, stream_minitialconfig1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: initialconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nminitialconfig_return: (function() {
Ham4Parser.nminitialconfig_return = function(){};
org.antlr.lang.extend(Ham4Parser.nminitialconfig_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:454:1: nminitialconfig : ( nmicunit )+ -> ^( NMICLIST ( nmicunit )* ) ;
// $ANTLR start "nminitialconfig"
nminitialconfig: function() {
var retval = new Ham4Parser.nminitialconfig_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nmicunit34 = null;
var stream_nmicunit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nmicunit");
this.trace("ANTLR Parse: nminitialconfig starts "+this.state.backtracking);
try {
// Ham4Parser.g:471:5: ( ( nmicunit )+ -> ^( NMICLIST ( nmicunit )* ) )
// Ham4Parser.g:471:9: ( nmicunit )+
// Ham4Parser.g:471:9: ( nmicunit )+
var cnt12=0;
loop12:
do {
var alt12=2;
var LA12_0 = this.input.LA(1);
if ( (LA12_0==HamSeqbegin) ) {
alt12=1;
}
switch (alt12) {
case 1 :
// Ham4Parser.g:472:13: nmicunit
this.pushFollow(Ham4Parser.FOLLOW_nmicunit_in_nminitialconfig1718);
nmicunit34=this.nmicunit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nmicunit.add(nmicunit34.getTree());
break;
default :
if ( cnt12 >= 1 ) {
break loop12;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(12, this.input);
throw eee;
}
cnt12++;
} while (true);
// AST REWRITE
// elements: nmicunit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 474:9: -> ^( NMICLIST ( nmicunit )* )
{
// Ham4Parser.g:474:12: ^( NMICLIST ( nmicunit )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMICLIST, "NMICLIST"), root_1);
// Ham4Parser.g:474:23: ( nmicunit )*
while ( stream_nmicunit.hasNext() ) {
this.adaptor.addChild(root_1, stream_nmicunit.nextTree());
}
stream_nmicunit.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nminitialconfig finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nmicunit_return: (function() {
Ham4Parser.nmicunit_return = function(){};
org.antlr.lang.extend(Ham4Parser.nmicunit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:477:1: nmicunit : HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 ) ;
// $ANTLR start "nmicunit"
nmicunit: function() {
var retval = new Ham4Parser.nmicunit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin35 = null;
var HamSeqend39 = null;
var levelbody36 = null;
var levelarm37 = null;
var action138 = null;
var HamSeqbegin35_tree=null;
var HamSeqend39_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_levelbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelbody");
var stream_levelarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelarm");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: nmicunit starts "+this.state.backtracking);
try {
// Ham4Parser.g:501:5: ( HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 ) )
// Ham4Parser.g:502:9: HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend
HamSeqbegin35=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_nmicunit1781); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin35);
// Ham4Parser.g:503:9: ( ( levelbody )=> levelbody | levelarm )
var alt13=2;
alt13 = this.dfa13.predict(this.input);
switch (alt13) {
case 1 :
// Ham4Parser.g:504:11: ( levelbody )=> levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_nmicunit1812);
levelbody36=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelbody.add(levelbody36.getTree());
break;
case 2 :
// Ham4Parser.g:506:11: levelarm
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_nmicunit1834);
levelarm37=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelarm.add(levelarm37.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_action1_in_nmicunit1854);
action138=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action138.getTree());
HamSeqend39=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_nmicunit1864); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend39);
// AST REWRITE
// elements: levelbody, action1, levelarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 511:9: -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 )
{
// Ham4Parser.g:511:12: ^( NMICUNIT ( levelbody )? ( levelarm )? action1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMICUNIT, "NMICUNIT"), root_1);
// Ham4Parser.g:511:23: ( levelbody )?
if ( stream_levelbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelbody.nextTree());
}
stream_levelbody.reset();
// Ham4Parser.g:511:34: ( levelarm )?
if ( stream_levelarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelarm.nextTree());
}
stream_levelarm.reset();
this.adaptor.addChild(root_1, stream_action1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nmicunit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
minitialconfig2_return: (function() {
Ham4Parser.minitialconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.minitialconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:515:1: minitialconfig2 : ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) ) ;
// $ANTLR start "minitialconfig2"
minitialconfig2: function() {
var retval = new Ham4Parser.minitialconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin42 = null;
var HamPlus44 = null;
var HamParend46 = null;
var HamPlus47 = null;
var HamParend48 = null;
var loc = null;
var ploc = null;
var handconfig240 = null;
var location241 = null;
var handconfig143 = null;
var location145 = null;
var HamParbegin42_tree=null;
var HamPlus44_tree=null;
var HamParend46_tree=null;
var HamPlus47_tree=null;
var HamParend48_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_location2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
var stream_handconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig2");
this.trace("ANTLR Parse: minitialconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:559:5: ( ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) ) )
// Ham4Parser.g:560:5: ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) )
// Ham4Parser.g:560:5: ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) )
var alt17=2;
var LA17_0 = this.input.LA(1);
if ( ((LA17_0>=HamFist && LA17_0<=HamFinger2345)||(LA17_0>=HamPinch12 && LA17_0<=HamCee12open)) && (this.synpred4_Ham4Parser())) {
alt17=1;
}
else if ( (LA17_0==HamNondominant) && (this.synpred4_Ham4Parser())) {
alt17=1;
}
else if ( (LA17_0==HamParbegin) ) {
var LA17_3 = this.input.LA(2);
if ( (this.synpred4_Ham4Parser()) ) {
alt17=1;
}
else if ( (true) ) {
alt17=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 17, 3, this.input);
throw nvae;
}
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 17, 0, this.input);
throw nvae;
}
switch (alt17) {
case 1 :
// Ham4Parser.g:561:9: ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )?
this.pushFollow(Ham4Parser.FOLLOW_handconfig2_in_minitialconfig21965);
handconfig240=this.handconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig2.add(handconfig240.getTree());
// Ham4Parser.g:564:9: ( ( location2 )=> location2 )?
var alt14=2;
alt14 = this.dfa14.predict(this.input);
switch (alt14) {
case 1 :
// Ham4Parser.g:565:13: ( location2 )=> location2
this.pushFollow(Ham4Parser.FOLLOW_location2_in_minitialconfig22021);
location241=this.location2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2.add(location241.getTree());
break;
}
// AST REWRITE
// elements: location2, handconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 569:6: -> ^( MICFG2 handconfig2 ( location2 )? )
{
// Ham4Parser.g:569:9: ^( MICFG2 handconfig2 ( location2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig2.nextTree());
// Ham4Parser.g:569:30: ( location2 )?
if ( stream_location2.hasNext() ) {
this.adaptor.addChild(root_1, stream_location2.nextTree());
}
stream_location2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:571:9: HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )
HamParbegin42=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_minitialconfig22064); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin42);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_minitialconfig22075);
handconfig143=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig143.getTree());
// Ham4Parser.g:573:9: ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )
var alt16=2;
alt16 = this.dfa16.predict(this.input);
switch (alt16) {
case 1 :
// Ham4Parser.g:574:13: ( HamPlus )=> HamPlus location1 HamParend
HamPlus44=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_minitialconfig22131); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus44);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22146);
location145=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location145.getTree());
HamParend46=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_minitialconfig22160); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend46);
// AST REWRITE
// elements: HamPlus, handconfig1, location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 580:6: -> ^( MICFG2 handconfig1 HamPlus location1 )
{
// Ham4Parser.g:580:9: ^( MICFG2 handconfig1 HamPlus location1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_location1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:582:13: loc= location1 HamPlus (ploc= location1 )? HamParend
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22204);
loc=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(loc.getTree());
HamPlus47=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_minitialconfig22218); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus47);
// Ham4Parser.g:585:13: (ploc= location1 )?
var alt15=2;
alt15 = this.dfa15.predict(this.input);
switch (alt15) {
case 1 :
// Ham4Parser.g:585:15: ploc= location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22237);
ploc=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(ploc.getTree());
break;
}
HamParend48=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_minitialconfig22254); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend48);
// AST REWRITE
// elements: handconfig1, loc, HamPlus, ploc
// token labels: 
// rule labels: loc, ploc, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_loc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token loc",loc!=null?loc.tree:null);
var stream_ploc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token ploc",ploc!=null?ploc.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 587:6: -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? )
{
// Ham4Parser.g:587:9: ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
this.adaptor.addChild(root_1, stream_loc.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
// Ham4Parser.g:587:43: ( $ploc)?
if ( stream_ploc.hasNext() ) {
this.adaptor.addChild(root_1, stream_ploc.nextTree());
}
stream_ploc.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: minitialconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
minitialconfig1_return: (function() {
Ham4Parser.minitialconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.minitialconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:592:1: minitialconfig1 : handconfig1 ( location1 )? -> ^( MICFG1 handconfig1 ( location1 )? ) ;
// $ANTLR start "minitialconfig1"
minitialconfig1: function() {
var retval = new Ham4Parser.minitialconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handconfig149 = null;
var location150 = null;
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
this.trace("ANTLR Parse: minitialconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:610:5: ( handconfig1 ( location1 )? -> ^( MICFG1 handconfig1 ( location1 )? ) )
// Ham4Parser.g:611:9: handconfig1 ( location1 )?
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_minitialconfig12328);
handconfig149=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig149.getTree());
// Ham4Parser.g:612:9: ( location1 )?
var alt18=2;
alt18 = this.dfa18.predict(this.input);
switch (alt18) {
case 1 :
// Ham4Parser.g:612:11: location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig12340);
location150=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location150.getTree());
break;
}
// AST REWRITE
// elements: handconfig1, location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 614:6: -> ^( MICFG1 handconfig1 ( location1 )? )
{
// Ham4Parser.g:614:9: ^( MICFG1 handconfig1 ( location1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG1, "MICFG1"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
// Ham4Parser.g:614:30: ( location1 )?
if ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: minitialconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfig2_return: (function() {
Ham4Parser.handconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:620:1: handconfig2 : ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) ) ;
// $ANTLR start "handconfig2"
handconfig2: function() {
var retval = new Ham4Parser.handconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshape251 = null;
var handconfigtail252 = null;
var handshape253 = null;
var splithandconfig254 = null;
var stream_handshape2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape2");
var stream_handconfigtail2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfigtail2");
var stream_splithandconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splithandconfig2");
this.trace("ANTLR Parse: handconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:649:5: ( ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) ) )
// Ham4Parser.g:650:5: ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) )
// Ham4Parser.g:650:5: ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) )
var alt19=3;
switch ( this.input.LA(1) ) {
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
var LA19_1 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 1, this.input);
throw nvae;
}
break;
case HamNondominant:
var LA19_2 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 2, this.input);
throw nvae;
}
break;
case HamParbegin:
var LA19_3 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else if ( (true) ) {
alt19=3;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 3, this.input);
throw nvae;
}
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 0, this.input);
throw nvae;
}
switch (alt19) {
case 1 :
// Ham4Parser.g:651:9: ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_handconfig22445);
handshape251=this.handshape2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape2.add(handshape251.getTree());
this.pushFollow(Ham4Parser.FOLLOW_handconfigtail2_in_handconfig22455);
handconfigtail252=this.handconfigtail2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfigtail2.add(handconfigtail252.getTree());
// AST REWRITE
// elements: handshape2, handconfigtail2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 655:6: -> ^( HDCONFIG2 handshape2 handconfigtail2 )
{
// Ham4Parser.g:655:9: ^( HDCONFIG2 handshape2 handconfigtail2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_handshape2.nextTree());
this.adaptor.addChild(root_1, stream_handconfigtail2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:657:9: ( handshape2 )=> handshape2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_handconfig22510);
handshape253=this.handshape2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape2.add(handshape253.getTree());
// AST REWRITE
// elements: handshape2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 660:6: -> ^( HDCONFIG2 handshape2 )
{
// Ham4Parser.g:660:9: ^( HDCONFIG2 handshape2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_handshape2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:662:9: splithandconfig2
this.pushFollow(Ham4Parser.FOLLOW_splithandconfig2_in_handconfig22539);
splithandconfig254=this.splithandconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splithandconfig2.add(splithandconfig254.getTree());
// AST REWRITE
// elements: splithandconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 663:6: -> ^( HDCONFIG2 splithandconfig2 )
{
// Ham4Parser.g:663:9: ^( HDCONFIG2 splithandconfig2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_splithandconfig2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfig1_return: (function() {
Ham4Parser.handconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:668:1: handconfig1 : handshape1 ( extfidir1 palmor1 )? -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? ) ;
// $ANTLR start "handconfig1"
handconfig1: function() {
var retval = new Ham4Parser.handconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshape155 = null;
var extfidir156 = null;
var palmor157 = null;
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: handconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:688:5: ( handshape1 ( extfidir1 palmor1 )? -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? ) )
// Ham4Parser.g:688:9: handshape1 ( extfidir1 palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handconfig12588);
handshape155=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape155.getTree());
// Ham4Parser.g:689:9: ( extfidir1 palmor1 )?
var alt20=2;
var LA20_0 = this.input.LA(1);
if ( ((LA20_0>=HamExtfingeru && LA20_0<=HamExtfingeruo)) ) {
alt20=1;
}
switch (alt20) {
case 1 :
// Ham4Parser.g:690:13: extfidir1 palmor1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfig12612);
extfidir156=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir156.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfig12626);
palmor157=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor157.getTree());
break;
}
// AST REWRITE
// elements: handshape1, palmor1, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 694:6: -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? )
{
// Ham4Parser.g:694:9: ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG1, "HDCONFIG1"), root_1);
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
// Ham4Parser.g:694:32: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:694:43: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splithandconfig2_return: (function() {
Ham4Parser.splithandconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splithandconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:699:1: splithandconfig2 : HamParbegin handconfig1 HamPlus handconfig1 HamParend -> ^( SPLITHDCFG2 ( handconfig1 )* ) ;
// $ANTLR start "splithandconfig2"
splithandconfig2: function() {
var retval = new Ham4Parser.splithandconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin58 = null;
var HamPlus60 = null;
var HamParend62 = null;
var handconfig159 = null;
var handconfig161 = null;
var HamParbegin58_tree=null;
var HamPlus60_tree=null;
var HamParend62_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
this.trace("ANTLR Parse: splithandconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:719:5: ( HamParbegin handconfig1 HamPlus handconfig1 HamParend -> ^( SPLITHDCFG2 ( handconfig1 )* ) )
// Ham4Parser.g:719:9: HamParbegin handconfig1 HamPlus handconfig1 HamParend
HamParbegin58=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splithandconfig22696); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin58);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_splithandconfig22707);
handconfig159=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig159.getTree());
HamPlus60=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splithandconfig22717); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus60);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_splithandconfig22728);
handconfig161=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig161.getTree());
HamParend62=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splithandconfig22738); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend62);
// AST REWRITE
// elements: handconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 725:6: -> ^( SPLITHDCFG2 ( handconfig1 )* )
{
// Ham4Parser.g:725:9: ^( SPLITHDCFG2 ( handconfig1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITHDCFG2, "SPLITHDCFG2"), root_1);
// Ham4Parser.g:725:23: ( handconfig1 )*
while ( stream_handconfig1.hasNext() ) {
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
}
stream_handconfig1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splithandconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfigtail2_return: (function() {
Ham4Parser.handconfigtail2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfigtail2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:728:1: handconfigtail2 : ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) ) ;
// $ANTLR start "handconfigtail2"
handconfigtail2: function() {
var retval = new Ham4Parser.handconfigtail2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin65 = null;
var HamPlus66 = null;
var HamParend67 = null;
var efd1 = null;
var por1 = null;
var efd2 = null;
var por2 = null;
var extfidir263 = null;
var palmor264 = null;
var HamParbegin65_tree=null;
var HamPlus66_tree=null;
var HamParend67_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_palmor2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor2");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
var stream_extfidir2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir2");
this.trace("ANTLR Parse: handconfigtail2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:758:5: ( ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) ) )
// Ham4Parser.g:759:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )
// Ham4Parser.g:759:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )
var alt21=2;
alt21 = this.dfa21.predict(this.input);
switch (alt21) {
case 1 :
// Ham4Parser.g:760:9: ( extfidir2 )=> extfidir2 palmor2
this.pushFollow(Ham4Parser.FOLLOW_extfidir2_in_handconfigtail22827);
extfidir263=this.extfidir2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir2.add(extfidir263.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor2_in_handconfigtail22837);
palmor264=this.palmor2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor2.add(palmor264.getTree());
// AST REWRITE
// elements: palmor2, extfidir2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 764:5: -> ^( HDCFGTAIL2 extfidir2 palmor2 )
{
// Ham4Parser.g:764:8: ^( HDCFGTAIL2 extfidir2 palmor2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCFGTAIL2, "HDCFGTAIL2"), root_1);
this.adaptor.addChild(root_1, stream_extfidir2.nextTree());
this.adaptor.addChild(root_1, stream_palmor2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:766:9: HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend
HamParbegin65=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handconfigtail22867); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin65);
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfigtail22880);
efd1=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(efd1.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfigtail22892);
por1=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(por1.getTree());
HamPlus66=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handconfigtail22902); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus66);
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfigtail22915);
efd2=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(efd2.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfigtail22927);
por2=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(por2.getTree());
HamParend67=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handconfigtail22937); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend67);
// AST REWRITE
// elements: efd2, por2, efd1, por1
// token labels: 
// rule labels: efd2, efd1, por1, por2, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_efd2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token efd2",efd2!=null?efd2.tree:null);
var stream_efd1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token efd1",efd1!=null?efd1.tree:null);
var stream_por1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token por1",por1!=null?por1.tree:null);
var stream_por2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token por2",por2!=null?por2.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 773:5: -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2)
{
// Ham4Parser.g:773:8: ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCFGTAIL2, "HDCFGTAIL2"), root_1);
this.adaptor.addChild(root_1, stream_efd1.nextTree());
this.adaptor.addChild(root_1, stream_por1.nextTree());
this.adaptor.addChild(root_1, stream_efd2.nextTree());
this.adaptor.addChild(root_1, stream_por2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfigtail2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshape2_return: (function() {
Ham4Parser.handshape2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshape2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:780:1: handshape2 : ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) ) ;
// $ANTLR start "handshape2"
handshape2: function() {
var retval = new Ham4Parser.handshape2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin69 = null;
var HamPlus70 = null;
var HamParend71 = null;
var hs1 = null;
var hs2 = null;
var handshape168 = null;
var HamParbegin69_tree=null;
var HamPlus70_tree=null;
var HamParend71_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
this.trace("ANTLR Parse: handshape2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:805:5: ( ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) ) )
// Ham4Parser.g:806:5: ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) )
// Ham4Parser.g:806:5: ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) )
var alt22=2;
var LA22_0 = this.input.LA(1);
if ( ((LA22_0>=HamFist && LA22_0<=HamFinger2345)||(LA22_0>=HamPinch12 && LA22_0<=HamCee12open)||LA22_0==HamNondominant) ) {
alt22=1;
}
else if ( (LA22_0==HamParbegin) ) {
alt22=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 22, 0, this.input);
throw nvae;
}
switch (alt22) {
case 1 :
// Ham4Parser.g:807:9: handshape1
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23010);
handshape168=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape168.getTree());
// AST REWRITE
// elements: handshape1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 808:6: -> ^( HSHAPE2 handshape1 )
{
// Ham4Parser.g:808:9: ^( HSHAPE2 handshape1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE2, "HSHAPE2"), root_1);
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:810:9: HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend
HamParbegin69=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handshape23039); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin69);
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23054);
hs1=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(hs1.getTree());
HamPlus70=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handshape23064); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus70);
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23079);
hs2=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(hs2.getTree());
HamParend71=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handshape23089); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend71);
// AST REWRITE
// elements: hs2, hs1
// token labels: 
// rule labels: hs2, hs1, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_hs2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token hs2",hs2!=null?hs2.tree:null);
var stream_hs1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token hs1",hs1!=null?hs1.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 815:6: -> ^( HSHAPE2 $hs1 $hs2)
{
// Ham4Parser.g:815:9: ^( HSHAPE2 $hs1 $hs2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE2, "HSHAPE2"), root_1);
this.adaptor.addChild(root_1, stream_hs1.nextTree());
this.adaptor.addChild(root_1, stream_hs2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshape2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshape1_return: (function() {
Ham4Parser.handshape1_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshape1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:819:1: handshape1 : basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist ) -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? ) ;
// $ANTLR start "handshape1"
handshape1: function() {
var retval = new Ham4Parser.handshape1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var basichandshape172 = null;
var cautiousfingerlist73 = null;
var fingershapelist74 = null;
var fingercrossinglist75 = null;
var thumbbetweenexplicit76 = null;
var cautiousfingerlist77 = null;
var fingershapelist78 = null;
var fingercrossinglist79 = null;
var thumbspecial80 = null;
var fingerlist81 = null;
var fingershapelist82 = null;
var fingercrossinglist83 = null;
var thumbbetweendefault84 = null;
var thumbextra85 = null;
var fingerlist86 = null;
var fingershapelist87 = null;
var fingercrossinglist88 = null;
var stream_thumbbetweenexplicit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbbetweenexplicit");
var stream_cautiousfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule cautiousfingerlist");
var stream_thumbspecial=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbspecial");
var stream_thumbbetweendefault=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbbetweendefault");
var stream_basichandshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule basichandshape1");
var stream_fingershapelist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingershapelist");
var stream_fingercrossinglist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingercrossinglist");
var stream_fingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerlist");
var stream_thumbextra=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbextra");
this.trace("ANTLR Parse: handshape1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:867:5: ( basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist ) -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? ) )
// Ham4Parser.g:867:7: basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )
this.pushFollow(Ham4Parser.FOLLOW_basichandshape1_in_handshape13140);
basichandshape172=this.basichandshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape1.add(basichandshape172.getTree());
// Ham4Parser.g:868:9: ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )
var alt25=4;
alt25 = this.dfa25.predict(this.input);
switch (alt25) {
case 1 :
// Ham4Parser.g:869:13: ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit
this.pushFollow(Ham4Parser.FOLLOW_cautiousfingerlist_in_handshape13205);
cautiousfingerlist73=this.cautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_cautiousfingerlist.add(cautiousfingerlist73.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13219);
fingershapelist74=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist74.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13233);
fingercrossinglist75=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist75.getTree());
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweenexplicit_in_handshape13247);
thumbbetweenexplicit76=this.thumbbetweenexplicit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbbetweenexplicit.add(thumbbetweenexplicit76.getTree());
break;
case 2 :
// Ham4Parser.g:877:13: ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )?
this.pushFollow(Ham4Parser.FOLLOW_cautiousfingerlist_in_handshape13325);
cautiousfingerlist77=this.cautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_cautiousfingerlist.add(cautiousfingerlist77.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13339);
fingershapelist78=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist78.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13353);
fingercrossinglist79=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist79.getTree());
// Ham4Parser.g:882:13: ( ( thumbspecial )=> thumbspecial )?
var alt23=2;
alt23 = this.dfa23.predict(this.input);
switch (alt23) {
case 1 :
// Ham4Parser.g:882:15: ( thumbspecial )=> thumbspecial
this.pushFollow(Ham4Parser.FOLLOW_thumbspecial_in_handshape13377);
thumbspecial80=this.thumbspecial();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbspecial.add(thumbspecial80.getTree());
break;
}
break;
case 3 :
// Ham4Parser.g:885:13: ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra )
this.pushFollow(Ham4Parser.FOLLOW_fingerlist_in_handshape13458);
fingerlist81=this.fingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerlist.add(fingerlist81.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13472);
fingershapelist82=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist82.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13486);
fingercrossinglist83=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist83.getTree());
// Ham4Parser.g:890:13: ( thumbbetweendefault | thumbextra )
var alt24=2;
var LA24_0 = this.input.LA(1);
if ( (LA24_0==HamBetween) ) {
alt24=1;
}
else if ( (LA24_0==HamThumb||(LA24_0>=HamFingertip && LA24_0<=HamFingerside)) ) {
alt24=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);
throw nvae;
}
switch (alt24) {
case 1 :
// Ham4Parser.g:890:15: thumbbetweendefault
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_handshape13502);
thumbbetweendefault84=this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbbetweendefault.add(thumbbetweendefault84.getTree());
break;
case 2 :
// Ham4Parser.g:890:37: thumbextra
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_handshape13506);
thumbextra85=this.thumbextra();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbextra.add(thumbextra85.getTree());
break;
}
break;
case 4 :
// Ham4Parser.g:893:13: fingerlist fingershapelist fingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_fingerlist_in_handshape13539);
fingerlist86=this.fingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerlist.add(fingerlist86.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13553);
fingershapelist87=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist87.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13567);
fingercrossinglist88=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist88.getTree());
break;
}
// AST REWRITE
// elements: thumbextra, fingerlist, thumbbetweenexplicit, thumbspecial, fingercrossinglist, thumbbetweendefault, cautiousfingerlist, basichandshape1, fingershapelist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 900:2: -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? )
{
// Ham4Parser.g:900:5: ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE1, "HSHAPE1"), root_1);
this.adaptor.addChild(root_1, stream_basichandshape1.nextTree());
// Ham4Parser.g:900:31: ( cautiousfingerlist )?
if ( stream_cautiousfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_cautiousfingerlist.nextTree());
}
stream_cautiousfingerlist.reset();
// Ham4Parser.g:900:51: ( fingerlist )?
if ( stream_fingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingerlist.nextTree());
}
stream_fingerlist.reset();
// Ham4Parser.g:900:63: ( fingershapelist )?
if ( stream_fingershapelist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingershapelist.nextTree());
}
stream_fingershapelist.reset();
// Ham4Parser.g:900:80: ( fingercrossinglist )?
if ( stream_fingercrossinglist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingercrossinglist.nextTree());
}
stream_fingercrossinglist.reset();
// Ham4Parser.g:901:4: ( thumbbetweenexplicit )?
if ( stream_thumbbetweenexplicit.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbbetweenexplicit.nextTree());
}
stream_thumbbetweenexplicit.reset();
// Ham4Parser.g:901:26: ( thumbspecial )?
if ( stream_thumbspecial.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbspecial.nextTree());
}
stream_thumbspecial.reset();
// Ham4Parser.g:901:40: ( thumbbetweendefault )?
if ( stream_thumbbetweendefault.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbbetweendefault.nextTree());
}
stream_thumbbetweendefault.reset();
// Ham4Parser.g:901:61: ( thumbextra )?
if ( stream_thumbextra.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbextra.nextTree());
}
stream_thumbextra.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshape1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
basichandshape1_return: (function() {
Ham4Parser.basichandshape1_return = function(){};
org.antlr.lang.extend(Ham4Parser.basichandshape1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:904:1: basichandshape1 : basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )? -> ^( BASICHDSHP1 ( basichandshape )* ) ;
// $ANTLR start "basichandshape1"
basichandshape1: function() {
var retval = new Ham4Parser.basichandshape1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween90 = null;
var basichandshape89 = null;
var basichandshape91 = null;
var HamBetween90_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_basichandshape=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule basichandshape");
this.trace("ANTLR Parse: basichandshape1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:925:5: ( basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )? -> ^( BASICHDSHP1 ( basichandshape )* ) )
// Ham4Parser.g:925:9: basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?
this.pushFollow(Ham4Parser.FOLLOW_basichandshape_in_basichandshape13654);
basichandshape89=this.basichandshape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape.add(basichandshape89.getTree());
// Ham4Parser.g:926:9: ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?
var alt26=2;
alt26 = this.dfa26.predict(this.input);
switch (alt26) {
case 1 :
// Ham4Parser.g:927:13: ( HamBetween handshapeclass )=> HamBetween basichandshape
HamBetween90=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_basichandshape13719); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween90);
this.pushFollow(Ham4Parser.FOLLOW_basichandshape_in_basichandshape13734);
basichandshape91=this.basichandshape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape.add(basichandshape91.getTree());
break;
}
// AST REWRITE
// elements: basichandshape
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 932:6: -> ^( BASICHDSHP1 ( basichandshape )* )
{
// Ham4Parser.g:932:9: ^( BASICHDSHP1 ( basichandshape )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(BASICHDSHP1, "BASICHDSHP1"), root_1);
// Ham4Parser.g:932:23: ( basichandshape )*
while ( stream_basichandshape.hasNext() ) {
this.adaptor.addChild(root_1, stream_basichandshape.nextTree());
}
stream_basichandshape.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: basichandshape1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
basichandshape_return: (function() {
Ham4Parser.basichandshape_return = function(){};
org.antlr.lang.extend(Ham4Parser.basichandshape_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:935:1: basichandshape : ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )? -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? ) ;
// $ANTLR start "basichandshape"
basichandshape: function() {
var retval = new Ham4Parser.basichandshape_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNondominant93 = null;
var HamEtc94 = null;
var handshapeclass92 = null;
var handbendandthumb95 = null;
var HamNondominant93_tree=null;
var HamEtc94_tree=null;
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_handshapeclass=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshapeclass");
var stream_handbendandthumb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handbendandthumb");
this.trace("ANTLR Parse: basichandshape starts "+this.state.backtracking);
try {
// Ham4Parser.g:957:5: ( ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )? -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? ) )
// Ham4Parser.g:957:9: ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )?
// Ham4Parser.g:957:9: ( handshapeclass | HamNondominant )
var alt27=2;
var LA27_0 = this.input.LA(1);
if ( ((LA27_0>=HamFist && LA27_0<=HamFinger2345)||(LA27_0>=HamPinch12 && LA27_0<=HamCee12open)) ) {
alt27=1;
}
else if ( (LA27_0==HamNondominant) ) {
alt27=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 27, 0, this.input);
throw nvae;
}
switch (alt27) {
case 1 :
// Ham4Parser.g:958:13: handshapeclass
this.pushFollow(Ham4Parser.FOLLOW_handshapeclass_in_basichandshape3802);
handshapeclass92=this.handshapeclass();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshapeclass.add(handshapeclass92.getTree());
break;
case 2 :
// Ham4Parser.g:960:13: HamNondominant
HamNondominant93=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_basichandshape3826); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant93);
break;
}
// Ham4Parser.g:962:9: ( HamEtc )?
var alt28=2;
var LA28_0 = this.input.LA(1);
if ( (LA28_0==HamEtc) ) {
alt28=1;
}
switch (alt28) {
case 1 :
// Ham4Parser.g:962:11: HamEtc
HamEtc94=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_basichandshape3848); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc94);
break;
}
// Ham4Parser.g:963:9: ( handbendandthumb )?
var alt29=2;
var LA29_0 = this.input.LA(1);
if ( ((LA29_0>=HamThumboutmod && LA29_0<=HamThumbacrossmod)||(LA29_0>=HamThumbopenmod && LA29_0<=HamFingerhookedmod)||(LA29_0>=HamDoublebent && LA29_0<=HamDoublehooked)) ) {
alt29=1;
}
switch (alt29) {
case 1 :
// Ham4Parser.g:963:9: handbendandthumb
this.pushFollow(Ham4Parser.FOLLOW_handbendandthumb_in_basichandshape3861);
handbendandthumb95=this.handbendandthumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handbendandthumb.add(handbendandthumb95.getTree());
break;
}
// AST REWRITE
// elements: HamNondominant, handbendandthumb, handshapeclass, HamEtc
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 965:9: -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? )
{
// Ham4Parser.g:965:12: ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(BASICHDSHP, "BASICHDSHP"), root_1);
// Ham4Parser.g:965:25: ( handshapeclass )?
if ( stream_handshapeclass.hasNext() ) {
this.adaptor.addChild(root_1, stream_handshapeclass.nextTree());
}
stream_handshapeclass.reset();
// Ham4Parser.g:965:41: ( HamNondominant )?
if ( stream_HamNondominant.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
}
stream_HamNondominant.reset();
// Ham4Parser.g:965:57: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:965:65: ( handbendandthumb )?
if ( stream_handbendandthumb.hasNext() ) {
this.adaptor.addChild(root_1, stream_handbendandthumb.nextTree());
}
stream_handbendandthumb.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: basichandshape finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handbendandthumb_return: (function() {
Ham4Parser.handbendandthumb_return = function(){};
org.antlr.lang.extend(Ham4Parser.handbendandthumb_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:968:1: handbendandthumb : ( thumbpos ( fingerbending )? | fingerbending ( thumbpos )? );
// $ANTLR start "handbendandthumb"
handbendandthumb: function() {
var retval = new Ham4Parser.handbendandthumb_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbpos96 = null;
var fingerbending97 = null;
var fingerbending98 = null;
var thumbpos99 = null;
this.trace("ANTLR Parse: handbendandthumb starts "+this.state.backtracking);
try {
// Ham4Parser.g:987:5: ( thumbpos ( fingerbending )? | fingerbending ( thumbpos )? )
var alt32=2;
var LA32_0 = this.input.LA(1);
if ( ((LA32_0>=HamThumboutmod && LA32_0<=HamThumbacrossmod)||LA32_0==HamThumbopenmod) ) {
alt32=1;
}
else if ( ((LA32_0>=HamFingerstraightmod && LA32_0<=HamFingerhookedmod)||(LA32_0>=HamDoublebent && LA32_0<=HamDoublehooked)) ) {
alt32=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 32, 0, this.input);
throw nvae;
}
switch (alt32) {
case 1 :
// Ham4Parser.g:988:9: thumbpos ( fingerbending )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbpos_in_handbendandthumb3932);
thumbpos96=this.thumbpos();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbpos96.getTree());
// Ham4Parser.g:989:9: ( fingerbending )?
var alt30=2;
var LA30_0 = this.input.LA(1);
if ( ((LA30_0>=HamFingerstraightmod && LA30_0<=HamFingerhookedmod)||(LA30_0>=HamDoublebent && LA30_0<=HamDoublehooked)) ) {
alt30=1;
}
switch (alt30) {
case 1 :
// Ham4Parser.g:989:11: fingerbending
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_handbendandthumb3944);
fingerbending97=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerbending97.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:991:9: fingerbending ( thumbpos )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_handbendandthumb3963);
fingerbending98=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerbending98.getTree());
// Ham4Parser.g:992:9: ( thumbpos )?
var alt31=2;
var LA31_0 = this.input.LA(1);
if ( ((LA31_0>=HamThumboutmod && LA31_0<=HamThumbacrossmod)||LA31_0==HamThumbopenmod) ) {
alt31=1;
}
switch (alt31) {
case 1 :
// Ham4Parser.g:992:11: thumbpos
this.pushFollow(Ham4Parser.FOLLOW_thumbpos_in_handbendandthumb3975);
thumbpos99=this.thumbpos();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbpos99.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handbendandthumb finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerlist_return: (function() {
Ham4Parser.fingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:995:1: fingerlist : recfingerlist -> ^( FINGERLIST ( recfingerlist )? ) ;
// $ANTLR start "fingerlist"
fingerlist: function() {
var retval = new Ham4Parser.fingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingerlist100 = null;
var stream_recfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingerlist");
this.trace("ANTLR Parse: fingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1010:5: ( recfingerlist -> ^( FINGERLIST ( recfingerlist )? ) )
// Ham4Parser.g:1010:9: recfingerlist
this.pushFollow(Ham4Parser.FOLLOW_recfingerlist_in_fingerlist4007);
recfingerlist100=this.recfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingerlist.add(recfingerlist100.getTree());
// AST REWRITE
// elements: recfingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1011:5: -> ^( FINGERLIST ( recfingerlist )? )
{
// Ham4Parser.g:1011:8: ^( FINGERLIST ( recfingerlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FINGERLIST, "FINGERLIST"), root_1);
// Ham4Parser.g:1011:21: ( recfingerlist )?
if ( stream_recfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingerlist.nextTree());
}
stream_recfingerlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingerlist_return: (function() {
Ham4Parser.recfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1014:1: recfingerlist : ( ( hsfingeritem )=> hsfingeritem recfingerlist )? ;
// $ANTLR start "recfingerlist"
recfingerlist: function() {
var retval = new Ham4Parser.recfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var hsfingeritem101 = null;
var recfingerlist102 = null;
this.trace("ANTLR Parse: recfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1034:5: ( ( ( hsfingeritem )=> hsfingeritem recfingerlist )? )
// Ham4Parser.g:1035:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1035:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?
var alt33=2;
alt33 = this.dfa33.predict(this.input);
switch (alt33) {
case 1 :
// Ham4Parser.g:1036:13: ( hsfingeritem )=> hsfingeritem recfingerlist
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_recfingerlist4116);
hsfingeritem101=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem101.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingerlist_in_recfingerlist4130);
recfingerlist102=this.recfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingerlist102.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
cautiousfingerlist_return: (function() {
Ham4Parser.cautiousfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.cautiousfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1043:1: cautiousfingerlist : reccautiousfingerlist -> ^( FINGERLIST ( reccautiousfingerlist )? ) ;
// $ANTLR start "cautiousfingerlist"
cautiousfingerlist: function() {
var retval = new Ham4Parser.cautiousfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var reccautiousfingerlist103 = null;
var stream_reccautiousfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule reccautiousfingerlist");
this.trace("ANTLR Parse: cautiousfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1058:5: ( reccautiousfingerlist -> ^( FINGERLIST ( reccautiousfingerlist )? ) )
// Ham4Parser.g:1058:9: reccautiousfingerlist
this.pushFollow(Ham4Parser.FOLLOW_reccautiousfingerlist_in_cautiousfingerlist4170);
reccautiousfingerlist103=this.reccautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_reccautiousfingerlist.add(reccautiousfingerlist103.getTree());
// AST REWRITE
// elements: reccautiousfingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1059:5: -> ^( FINGERLIST ( reccautiousfingerlist )? )
{
// Ham4Parser.g:1059:8: ^( FINGERLIST ( reccautiousfingerlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FINGERLIST, "FINGERLIST"), root_1);
// Ham4Parser.g:1059:21: ( reccautiousfingerlist )?
if ( stream_reccautiousfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_reccautiousfingerlist.nextTree());
}
stream_reccautiousfingerlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: cautiousfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
reccautiousfingerlist_return: (function() {
Ham4Parser.reccautiousfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.reccautiousfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1062:1: reccautiousfingerlist : ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )? ;
// $ANTLR start "reccautiousfingerlist"
reccautiousfingerlist: function() {
var retval = new Ham4Parser.reccautiousfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var hsfingeritem104 = null;
var reccautiousfingerlist105 = null;
this.trace("ANTLR Parse: reccautiousfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1082:5: ( ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )? )
// Ham4Parser.g:1083:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1083:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?
var alt34=2;
alt34 = this.dfa34.predict(this.input);
switch (alt34) {
case 1 :
// Ham4Parser.g:1084:13: ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_reccautiousfingerlist4273);
hsfingeritem104=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem104.getTree());
this.pushFollow(Ham4Parser.FOLLOW_reccautiousfingerlist_in_reccautiousfingerlist4287);
reccautiousfingerlist105=this.reccautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, reccautiousfingerlist105.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: reccautiousfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingershapelist_return: (function() {
Ham4Parser.fingershapelist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingershapelist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1091:1: fingershapelist : recfingershapelist -> ^( FISHPLIST ( recfingershapelist )? ) ;
// $ANTLR start "fingershapelist"
fingershapelist: function() {
var retval = new Ham4Parser.fingershapelist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingershapelist106 = null;
var stream_recfingershapelist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingershapelist");
this.trace("ANTLR Parse: fingershapelist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1106:5: ( recfingershapelist -> ^( FISHPLIST ( recfingershapelist )? ) )
// Ham4Parser.g:1106:9: recfingershapelist
this.pushFollow(Ham4Parser.FOLLOW_recfingershapelist_in_fingershapelist4327);
recfingershapelist106=this.recfingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingershapelist.add(recfingershapelist106.getTree());
// AST REWRITE
// elements: recfingershapelist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1107:5: -> ^( FISHPLIST ( recfingershapelist )? )
{
// Ham4Parser.g:1107:8: ^( FISHPLIST ( recfingershapelist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FISHPLIST, "FISHPLIST"), root_1);
// Ham4Parser.g:1107:20: ( recfingershapelist )?
if ( stream_recfingershapelist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingershapelist.nextTree());
}
stream_recfingershapelist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingershapelist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingershapelist_return: (function() {
Ham4Parser.recfingershapelist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingershapelist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1110:1: recfingershapelist : ( ( fingershape )=> fingershape recfingershapelist )? ;
// $ANTLR start "recfingershapelist"
recfingershapelist: function() {
var retval = new Ham4Parser.recfingershapelist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingershape107 = null;
var recfingershapelist108 = null;
this.trace("ANTLR Parse: recfingershapelist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1130:5: ( ( ( fingershape )=> fingershape recfingershapelist )? )
// Ham4Parser.g:1131:9: ( ( fingershape )=> fingershape recfingershapelist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1131:9: ( ( fingershape )=> fingershape recfingershapelist )?
var alt35=2;
alt35 = this.dfa35.predict(this.input);
switch (alt35) {
case 1 :
// Ham4Parser.g:1132:13: ( fingershape )=> fingershape recfingershapelist
this.pushFollow(Ham4Parser.FOLLOW_fingershape_in_recfingershapelist4431);
fingershape107=this.fingershape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingershape107.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingershapelist_in_recfingershapelist4445);
recfingershapelist108=this.recfingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingershapelist108.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingershapelist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingercrossinglist_return: (function() {
Ham4Parser.fingercrossinglist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingercrossinglist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1139:1: fingercrossinglist : recfingercrossinglist -> ^( FICRSSLIST ( recfingercrossinglist )? ) ;
// $ANTLR start "fingercrossinglist"
fingercrossinglist: function() {
var retval = new Ham4Parser.fingercrossinglist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingercrossinglist109 = null;
var stream_recfingercrossinglist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingercrossinglist");
this.trace("ANTLR Parse: fingercrossinglist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1154:5: ( recfingercrossinglist -> ^( FICRSSLIST ( recfingercrossinglist )? ) )
// Ham4Parser.g:1154:9: recfingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_recfingercrossinglist_in_fingercrossinglist4485);
recfingercrossinglist109=this.recfingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingercrossinglist.add(recfingercrossinglist109.getTree());
// AST REWRITE
// elements: recfingercrossinglist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1155:5: -> ^( FICRSSLIST ( recfingercrossinglist )? )
{
// Ham4Parser.g:1155:8: ^( FICRSSLIST ( recfingercrossinglist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FICRSSLIST, "FICRSSLIST"), root_1);
// Ham4Parser.g:1155:21: ( recfingercrossinglist )?
if ( stream_recfingercrossinglist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingercrossinglist.nextTree());
}
stream_recfingercrossinglist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingercrossinglist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingercrossinglist_return: (function() {
Ham4Parser.recfingercrossinglist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingercrossinglist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1158:1: recfingercrossinglist : ( ( fingercrossing )=> fingercrossing recfingercrossinglist )? ;
// $ANTLR start "recfingercrossinglist"
recfingercrossinglist: function() {
var retval = new Ham4Parser.recfingercrossinglist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingercrossing110 = null;
var recfingercrossinglist111 = null;
this.trace("ANTLR Parse: recfingercrossinglist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1178:5: ( ( ( fingercrossing )=> fingercrossing recfingercrossinglist )? )
// Ham4Parser.g:1179:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1179:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?
var alt36=2;
alt36 = this.dfa36.predict(this.input);
switch (alt36) {
case 1 :
// Ham4Parser.g:1180:13: ( fingercrossing )=> fingercrossing recfingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_fingercrossing_in_recfingercrossinglist4586);
fingercrossing110=this.fingercrossing();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingercrossing110.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingercrossinglist_in_recfingercrossinglist4600);
recfingercrossinglist111=this.recfingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingercrossinglist111.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingercrossinglist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hsfingeritem_return: (function() {
Ham4Parser.hsfingeritem_return = function(){};
org.antlr.lang.extend(Ham4Parser.hsfingeritem_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1187:1: hsfingeritem : finger ( HamLargemod )? -> ^( HSFINGERITEM finger ( HamLargemod )? ) ;
// $ANTLR start "hsfingeritem"
hsfingeritem: function() {
var retval = new Ham4Parser.hsfingeritem_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamLargemod113 = null;
var finger112 = null;
var HamLargemod113_tree=null;
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_finger=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule finger");
this.trace("ANTLR Parse: hsfingeritem starts "+this.state.backtracking);
try {
// Ham4Parser.g:1204:5: ( finger ( HamLargemod )? -> ^( HSFINGERITEM finger ( HamLargemod )? ) )
// Ham4Parser.g:1204:9: finger ( HamLargemod )?
this.pushFollow(Ham4Parser.FOLLOW_finger_in_hsfingeritem4656);
finger112=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger112.getTree());
// Ham4Parser.g:1205:9: ( HamLargemod )?
var alt37=2;
var LA37_0 = this.input.LA(1);
if ( (LA37_0==HamLargemod) ) {
alt37=1;
}
switch (alt37) {
case 1 :
// Ham4Parser.g:1205:11: HamLargemod
HamLargemod113=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_hsfingeritem4668); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod113);
break;
}
// AST REWRITE
// elements: finger, HamLargemod
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1207:9: -> ^( HSFINGERITEM finger ( HamLargemod )? )
{
// Ham4Parser.g:1207:12: ^( HSFINGERITEM finger ( HamLargemod )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSFINGERITEM, "HSFINGERITEM"), root_1);
this.adaptor.addChild(root_1, stream_finger.nextTree());
// Ham4Parser.g:1207:34: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hsfingeritem finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
digit_return: (function() {
Ham4Parser.digit_return = function(){};
org.antlr.lang.extend(Ham4Parser.digit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1210:1: digit : ( thumb | finger );
// $ANTLR start "digit"
digit: function() {
var retval = new Ham4Parser.digit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb114 = null;
var finger115 = null;
this.trace("ANTLR Parse: digit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1225:5: ( thumb | finger )
var alt38=2;
var LA38_0 = this.input.LA(1);
if ( (LA38_0==HamThumb) ) {
alt38=1;
}
else if ( ((LA38_0>=HamIndexfinger && LA38_0<=HamPinky)) ) {
alt38=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 38, 0, this.input);
throw nvae;
}
switch (alt38) {
case 1 :
// Ham4Parser.g:1225:9: thumb
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_digit4728);
thumb114=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumb114.getTree());
break;
case 2 :
// Ham4Parser.g:1226:9: finger
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_finger_in_digit4738);
finger115=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, finger115.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: digit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hsdigit_return: (function() {
Ham4Parser.hsdigit_return = function(){};
org.antlr.lang.extend(Ham4Parser.hsdigit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1229:1: hsdigit : ( thumb | hsfingeritem );
// $ANTLR start "hsdigit"
hsdigit: function() {
var retval = new Ham4Parser.hsdigit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb116 = null;
var hsfingeritem117 = null;
this.trace("ANTLR Parse: hsdigit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1244:5: ( thumb | hsfingeritem )
var alt39=2;
var LA39_0 = this.input.LA(1);
if ( (LA39_0==HamThumb) ) {
alt39=1;
}
else if ( ((LA39_0>=HamIndexfinger && LA39_0<=HamPinky)) ) {
alt39=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 39, 0, this.input);
throw nvae;
}
switch (alt39) {
case 1 :
// Ham4Parser.g:1244:9: thumb
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_hsdigit4788);
thumb116=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumb116.getTree());
break;
case 2 :
// Ham4Parser.g:1245:9: hsfingeritem
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_hsdigit4798);
hsfingeritem117=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem117.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hsdigit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingershape_return: (function() {
Ham4Parser.fingershape_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingershape_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1248:1: fingershape : digit fingerbending -> ^( FSHAPE digit fingerbending ) ;
// $ANTLR start "fingershape"
fingershape: function() {
var retval = new Ham4Parser.fingershape_return();
retval.start = this.input.LT(1);
var root_0 = null;
var digit118 = null;
var fingerbending119 = null;
var stream_fingerbending=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerbending");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: fingershape starts "+this.state.backtracking);
try {
// Ham4Parser.g:1265:5: ( digit fingerbending -> ^( FSHAPE digit fingerbending ) )
// Ham4Parser.g:1265:9: digit fingerbending
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingershape4827);
digit118=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(digit118.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_fingershape4837);
fingerbending119=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerbending.add(fingerbending119.getTree());
// AST REWRITE
// elements: fingerbending, digit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1268:9: -> ^( FSHAPE digit fingerbending )
{
// Ham4Parser.g:1268:12: ^( FSHAPE digit fingerbending )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FSHAPE, "FSHAPE"), root_1);
this.adaptor.addChild(root_1, stream_digit.nextTree());
this.adaptor.addChild(root_1, stream_fingerbending.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingershape finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingercrossing_return: (function() {
Ham4Parser.fingercrossing_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingercrossing_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1271:1: fingercrossing : d1= digit fingerpart d2= digit -> ^( FCROSSING $d1 fingerpart $d2) ;
// $ANTLR start "fingercrossing"
fingercrossing: function() {
var retval = new Ham4Parser.fingercrossing_return();
retval.start = this.input.LT(1);
var root_0 = null;
var d1 = null;
var d2 = null;
var fingerpart120 = null;
var stream_fingerpart=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerpart");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: fingercrossing starts "+this.state.backtracking);
try {
// Ham4Parser.g:1289:5: (d1= digit fingerpart d2= digit -> ^( FCROSSING $d1 fingerpart $d2) )
// Ham4Parser.g:1289:9: d1= digit fingerpart d2= digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingercrossing4897);
d1=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(d1.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_fingercrossing4907);
fingerpart120=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerpart.add(fingerpart120.getTree());
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingercrossing4921);
d2=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(d2.getTree());
// AST REWRITE
// elements: d2, d1, fingerpart
// token labels: 
// rule labels: d1, d2, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_d1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token d1",d1!=null?d1.tree:null);
var stream_d2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token d2",d2!=null?d2.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1293:9: -> ^( FCROSSING $d1 fingerpart $d2)
{
// Ham4Parser.g:1293:12: ^( FCROSSING $d1 fingerpart $d2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FCROSSING, "FCROSSING"), root_1);
this.adaptor.addChild(root_1, stream_d1.nextTree());
this.adaptor.addChild(root_1, stream_fingerpart.nextTree());
this.adaptor.addChild(root_1, stream_d2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingercrossing finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbspecial_return: (function() {
Ham4Parser.thumbspecial_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbspecial_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1296:1: thumbspecial : ( thumbbetween | thumbextra );
// $ANTLR start "thumbspecial"
thumbspecial: function() {
var retval = new Ham4Parser.thumbspecial_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbbetween121 = null;
var thumbextra122 = null;
this.trace("ANTLR Parse: thumbspecial starts "+this.state.backtracking);
try {
// Ham4Parser.g:1311:5: ( thumbbetween | thumbextra )
var alt40=2;
var LA40_0 = this.input.LA(1);
if ( ((LA40_0>=HamIndexfinger && LA40_0<=HamPinky)||LA40_0==HamBetween) ) {
alt40=1;
}
else if ( (LA40_0==HamThumb||(LA40_0>=HamFingertip && LA40_0<=HamFingerside)) ) {
alt40=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 40, 0, this.input);
throw nvae;
}
switch (alt40) {
case 1 :
// Ham4Parser.g:1311:9: thumbbetween
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetween_in_thumbspecial4981);
thumbbetween121=this.thumbbetween();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetween121.getTree());
break;
case 2 :
// Ham4Parser.g:1312:9: thumbextra
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_thumbspecial4991);
thumbextra122=this.thumbextra();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbextra122.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbspecial finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetween_return: (function() {
Ham4Parser.thumbbetween_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetween_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1315:1: thumbbetween : ( thumbbetweenexplicit | thumbbetweendefault );
// $ANTLR start "thumbbetween"
thumbbetween: function() {
var retval = new Ham4Parser.thumbbetween_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbbetweenexplicit123 = null;
var thumbbetweendefault124 = null;
this.trace("ANTLR Parse: thumbbetween starts "+this.state.backtracking);
try {
// Ham4Parser.g:1330:5: ( thumbbetweenexplicit | thumbbetweendefault )
var alt41=2;
var LA41_0 = this.input.LA(1);
if ( ((LA41_0>=HamIndexfinger && LA41_0<=HamPinky)) ) {
alt41=1;
}
else if ( (LA41_0==HamBetween) ) {
alt41=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);
throw nvae;
}
switch (alt41) {
case 1 :
// Ham4Parser.g:1330:9: thumbbetweenexplicit
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweenexplicit_in_thumbbetween5020);
thumbbetweenexplicit123=this.thumbbetweenexplicit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetweenexplicit123.getTree());
break;
case 2 :
// Ham4Parser.g:1331:9: thumbbetweendefault
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_thumbbetween5030);
thumbbetweendefault124=this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetweendefault124.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetween finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetweenexplicit_return: (function() {
Ham4Parser.thumbbetweenexplicit_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetweenexplicit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1334:1: thumbbetweenexplicit : finger HamBetween finger -> ^( THSPECIAL ^( HamBetween ( finger )* ) ) ;
// $ANTLR start "thumbbetweenexplicit"
thumbbetweenexplicit: function() {
var retval = new Ham4Parser.thumbbetweenexplicit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween126 = null;
var finger125 = null;
var finger127 = null;
var HamBetween126_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_finger=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule finger");
this.trace("ANTLR Parse: thumbbetweenexplicit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1352:5: ( finger HamBetween finger -> ^( THSPECIAL ^( HamBetween ( finger )* ) ) )
// Ham4Parser.g:1352:9: finger HamBetween finger
this.pushFollow(Ham4Parser.FOLLOW_finger_in_thumbbetweenexplicit5059);
finger125=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger125.getTree());
HamBetween126=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_thumbbetweenexplicit5069); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween126);
this.pushFollow(Ham4Parser.FOLLOW_finger_in_thumbbetweenexplicit5080);
finger127=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger127.getTree());
// AST REWRITE
// elements: HamBetween, finger
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1356:9: -> ^( THSPECIAL ^( HamBetween ( finger )* ) )
{
// Ham4Parser.g:1356:12: ^( THSPECIAL ^( HamBetween ( finger )* ) )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
// Ham4Parser.g:1356:24: ^( HamBetween ( finger )* )
{
var root_2 = this.adaptor.nil();
root_2 = this.adaptor.becomeRoot(stream_HamBetween.nextNode(), root_2);
// Ham4Parser.g:1356:37: ( finger )*
while ( stream_finger.hasNext() ) {
this.adaptor.addChild(root_2, stream_finger.nextTree());
}
stream_finger.reset();
this.adaptor.addChild(root_1, root_2);
}
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetweenexplicit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetweendefault_return: (function() {
Ham4Parser.thumbbetweendefault_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetweendefault_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1359:1: thumbbetweendefault : HamBetween -> ^( THSPECIAL HamBetween ) ;
// $ANTLR start "thumbbetweendefault"
thumbbetweendefault: function() {
var retval = new Ham4Parser.thumbbetweendefault_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween128 = null;
var HamBetween128_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
this.trace("ANTLR Parse: thumbbetweendefault starts "+this.state.backtracking);
try {
// Ham4Parser.g:1375:5: ( HamBetween -> ^( THSPECIAL HamBetween ) )
// Ham4Parser.g:1375:9: HamBetween
HamBetween128=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_thumbbetweendefault5139); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween128);
// AST REWRITE
// elements: HamBetween
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1377:9: -> ^( THSPECIAL HamBetween )
{
// Ham4Parser.g:1377:12: ^( THSPECIAL HamBetween )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
this.adaptor.addChild(root_1, stream_HamBetween.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetweendefault finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbextra_return: (function() {
Ham4Parser.thumbextra_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbextra_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1380:1: thumbextra : ( thumb | fingerpart ) -> ^( THSPECIAL ( thumb )? ( fingerpart )? ) ;
// $ANTLR start "thumbextra"
thumbextra: function() {
var retval = new Ham4Parser.thumbextra_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb129 = null;
var fingerpart130 = null;
var stream_fingerpart=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerpart");
var stream_thumb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumb");
this.trace("ANTLR Parse: thumbextra starts "+this.state.backtracking);
try {
// Ham4Parser.g:1400:5: ( ( thumb | fingerpart ) -> ^( THSPECIAL ( thumb )? ( fingerpart )? ) )
// Ham4Parser.g:1401:5: ( thumb | fingerpart )
// Ham4Parser.g:1401:5: ( thumb | fingerpart )
var alt42=2;
var LA42_0 = this.input.LA(1);
if ( (LA42_0==HamThumb) ) {
alt42=1;
}
else if ( ((LA42_0>=HamFingertip && LA42_0<=HamFingerside)) ) {
alt42=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 42, 0, this.input);
throw nvae;
}
switch (alt42) {
case 1 :
// Ham4Parser.g:1402:9: thumb
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_thumbextra5205);
thumb129=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumb.add(thumb129.getTree());
break;
case 2 :
// Ham4Parser.g:1404:9: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_thumbextra5221);
fingerpart130=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerpart.add(fingerpart130.getTree());
break;
}
// AST REWRITE
// elements: fingerpart, thumb
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1406:5: -> ^( THSPECIAL ( thumb )? ( fingerpart )? )
{
// Ham4Parser.g:1406:8: ^( THSPECIAL ( thumb )? ( fingerpart )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
// Ham4Parser.g:1406:20: ( thumb )?
if ( stream_thumb.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumb.nextTree());
}
stream_thumb.reset();
// Ham4Parser.g:1406:27: ( fingerpart )?
if ( stream_fingerpart.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingerpart.nextTree());
}
stream_fingerpart.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbextra finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir2_return: (function() {
Ham4Parser.extfidir2_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1412:1: extfidir2 : ( extfidir1 | splitextfidir2 ) -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? ) ;
// $ANTLR start "extfidir2"
extfidir2: function() {
var retval = new Ham4Parser.extfidir2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidir1131 = null;
var splitextfidir2132 = null;
var stream_splitextfidir2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitextfidir2");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: extfidir2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1432:5: ( ( extfidir1 | splitextfidir2 ) -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? ) )
// Ham4Parser.g:1433:5: ( extfidir1 | splitextfidir2 )
// Ham4Parser.g:1433:5: ( extfidir1 | splitextfidir2 )
var alt43=2;
var LA43_0 = this.input.LA(1);
if ( ((LA43_0>=HamExtfingeru && LA43_0<=HamExtfingeruo)) ) {
alt43=1;
}
else if ( (LA43_0==HamParbegin) ) {
alt43=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 43, 0, this.input);
throw nvae;
}
switch (alt43) {
case 1 :
// Ham4Parser.g:1434:9: extfidir1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_extfidir25287);
extfidir1131=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1131.getTree());
break;
case 2 :
// Ham4Parser.g:1436:9: splitextfidir2
this.pushFollow(Ham4Parser.FOLLOW_splitextfidir2_in_extfidir25303);
splitextfidir2132=this.splitextfidir2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitextfidir2.add(splitextfidir2132.getTree());
break;
}
// AST REWRITE
// elements: splitextfidir2, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1438:5: -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? )
{
// Ham4Parser.g:1438:8: ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR2, "EXTFIDIR2"), root_1);
// Ham4Parser.g:1438:20: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:1438:31: ( splitextfidir2 )?
if ( stream_splitextfidir2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitextfidir2.nextTree());
}
stream_splitextfidir2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidir2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitextfidir2_return: (function() {
Ham4Parser.splitextfidir2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitextfidir2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1441:1: splitextfidir2 : HamParbegin extfidir1 HamPlus extfidir1 HamParend ;
// $ANTLR start "splitextfidir2"
splitextfidir2: function() {
var retval = new Ham4Parser.splitextfidir2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin133 = null;
var HamPlus135 = null;
var HamParend137 = null;
var extfidir1134 = null;
var extfidir1136 = null;
var HamParbegin133_tree=null;
var HamPlus135_tree=null;
var HamParend137_tree=null;
this.trace("ANTLR Parse: splitextfidir2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1459:5: ( HamParbegin extfidir1 HamPlus extfidir1 HamParend )
// Ham4Parser.g:1459:9: HamParbegin extfidir1 HamPlus extfidir1 HamParend
root_0 = this.adaptor.nil();
HamParbegin133=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitextfidir25354); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_splitextfidir25366);
extfidir1134=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, extfidir1134.getTree());
HamPlus135=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitextfidir25376); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_splitextfidir25388);
extfidir1136=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, extfidir1136.getTree());
HamParend137=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitextfidir25398); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitextfidir2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir1_return: (function() {
Ham4Parser.extfidir1_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1466:1: extfidir1 : extfidir ( HamBetween extfidir )? ( HamOrirelative )? -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* ) ;
// $ANTLR start "extfidir1"
extfidir1: function() {
var retval = new Ham4Parser.extfidir1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween139 = null;
var HamOrirelative141 = null;
var extfidir138 = null;
var extfidir140 = null;
var HamBetween139_tree=null;
var HamOrirelative141_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_HamOrirelative=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamOrirelative");
var stream_extfidir=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir");
this.trace("ANTLR Parse: extfidir1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1488:5: ( extfidir ( HamBetween extfidir )? ( HamOrirelative )? -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* ) )
// Ham4Parser.g:1488:9: extfidir ( HamBetween extfidir )? ( HamOrirelative )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir_in_extfidir15429);
extfidir138=this.extfidir();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir.add(extfidir138.getTree());
// Ham4Parser.g:1489:9: ( HamBetween extfidir )?
var alt44=2;
var LA44_0 = this.input.LA(1);
if ( (LA44_0==HamBetween) ) {
alt44=1;
}
switch (alt44) {
case 1 :
// Ham4Parser.g:1490:13: HamBetween extfidir
HamBetween139=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_extfidir15453); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween139);
this.pushFollow(Ham4Parser.FOLLOW_extfidir_in_extfidir15467);
extfidir140=this.extfidir();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir.add(extfidir140.getTree());
break;
}
// Ham4Parser.g:1493:9: ( HamOrirelative )?
var alt45=2;
var LA45_0 = this.input.LA(1);
if ( (LA45_0==HamOrirelative) ) {
alt45=1;
}
switch (alt45) {
case 1 :
// Ham4Parser.g:1494:13: HamOrirelative
HamOrirelative141=this.match(this.input,HamOrirelative,Ham4Parser.FOLLOW_HamOrirelative_in_extfidir15502); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamOrirelative.add(HamOrirelative141);
break;
}
// AST REWRITE
// elements: extfidir, HamOrirelative
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1496:6: -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* )
{
// Ham4Parser.g:1496:9: ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR1, "EXTFIDIR1"), root_1);
// Ham4Parser.g:1496:21: ( extfidir )*
while ( stream_extfidir.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir.nextTree());
}
stream_extfidir.reset();
// Ham4Parser.g:1496:31: ( HamOrirelative )*
while ( stream_HamOrirelative.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamOrirelative.nextNode());
}
stream_HamOrirelative.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidir1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor2_return: (function() {
Ham4Parser.palmor2_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1502:1: palmor2 : ( palmor1 | splitpalmor2 ) -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? ) ;
// $ANTLR start "palmor2"
palmor2: function() {
var retval = new Ham4Parser.palmor2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var palmor1142 = null;
var splitpalmor2143 = null;
var stream_splitpalmor2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitpalmor2");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
this.trace("ANTLR Parse: palmor2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1522:5: ( ( palmor1 | splitpalmor2 ) -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? ) )
// Ham4Parser.g:1523:5: ( palmor1 | splitpalmor2 )
// Ham4Parser.g:1523:5: ( palmor1 | splitpalmor2 )
var alt46=2;
var LA46_0 = this.input.LA(1);
if ( ((LA46_0>=HamPalmu && LA46_0<=HamPalmul)) ) {
alt46=1;
}
else if ( (LA46_0==HamParbegin) ) {
alt46=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 46, 0, this.input);
throw nvae;
}
switch (alt46) {
case 1 :
// Ham4Parser.g:1524:9: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_palmor25574);
palmor1142=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1142.getTree());
break;
case 2 :
// Ham4Parser.g:1526:9: splitpalmor2
this.pushFollow(Ham4Parser.FOLLOW_splitpalmor2_in_palmor25590);
splitpalmor2143=this.splitpalmor2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitpalmor2.add(splitpalmor2143.getTree());
break;
}
// AST REWRITE
// elements: palmor1, splitpalmor2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1528:5: -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? )
{
// Ham4Parser.g:1528:8: ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PALMOR2, "PALMOR2"), root_1);
// Ham4Parser.g:1528:18: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
// Ham4Parser.g:1528:27: ( splitpalmor2 )?
if ( stream_splitpalmor2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitpalmor2.nextTree());
}
stream_splitpalmor2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitpalmor2_return: (function() {
Ham4Parser.splitpalmor2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitpalmor2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1531:1: splitpalmor2 : HamParbegin palmor1 HamPlus palmor1 HamParend ;
// $ANTLR start "splitpalmor2"
splitpalmor2: function() {
var retval = new Ham4Parser.splitpalmor2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin144 = null;
var HamPlus146 = null;
var HamParend148 = null;
var palmor1145 = null;
var palmor1147 = null;
var HamParbegin144_tree=null;
var HamPlus146_tree=null;
var HamParend148_tree=null;
this.trace("ANTLR Parse: splitpalmor2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1549:5: ( HamParbegin palmor1 HamPlus palmor1 HamParend )
// Ham4Parser.g:1549:9: HamParbegin palmor1 HamPlus palmor1 HamParend
root_0 = this.adaptor.nil();
HamParbegin144=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitpalmor25641); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_splitpalmor25653);
palmor1145=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, palmor1145.getTree());
HamPlus146=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitpalmor25663); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_splitpalmor25675);
palmor1147=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, palmor1147.getTree());
HamParend148=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitpalmor25685); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitpalmor2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor1_return: (function() {
Ham4Parser.palmor1_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1556:1: palmor1 : palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )? -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* ) ;
// $ANTLR start "palmor1"
palmor1: function() {
var retval = new Ham4Parser.palmor1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween150 = null;
var HamEtc152 = null;
var HamOrirelative153 = null;
var palmor149 = null;
var palmor151 = null;
var HamBetween150_tree=null;
var HamEtc152_tree=null;
var HamOrirelative153_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_HamOrirelative=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamOrirelative");
var stream_palmor=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor");
this.trace("ANTLR Parse: palmor1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1580:5: ( palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )? -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* ) )
// Ham4Parser.g:1580:9: palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )?
this.pushFollow(Ham4Parser.FOLLOW_palmor_in_palmor15716);
palmor149=this.palmor();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor.add(palmor149.getTree());
// Ham4Parser.g:1581:9: ( HamBetween palmor | HamEtc )?
var alt47=3;
var LA47_0 = this.input.LA(1);
if ( (LA47_0==HamBetween) ) {
alt47=1;
}
else if ( (LA47_0==HamEtc) ) {
alt47=2;
}
switch (alt47) {
case 1 :
// Ham4Parser.g:1582:13: HamBetween palmor
HamBetween150=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_palmor15740); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween150);
this.pushFollow(Ham4Parser.FOLLOW_palmor_in_palmor15754);
palmor151=this.palmor();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor.add(palmor151.getTree());
break;
case 2 :
// Ham4Parser.g:1585:7: HamEtc
HamEtc152=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_palmor15772); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc152);
break;
}
// Ham4Parser.g:1587:9: ( HamOrirelative )?
var alt48=2;
var LA48_0 = this.input.LA(1);
if ( (LA48_0==HamOrirelative) ) {
alt48=1;
}
switch (alt48) {
case 1 :
// Ham4Parser.g:1588:13: HamOrirelative
HamOrirelative153=this.match(this.input,HamOrirelative,Ham4Parser.FOLLOW_HamOrirelative_in_palmor15807); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamOrirelative.add(HamOrirelative153);
break;
}
// AST REWRITE
// elements: palmor, HamOrirelative, HamEtc
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1590:6: -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* )
{
// Ham4Parser.g:1590:9: ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PALMOR1, "PALMOR1"), root_1);
// Ham4Parser.g:1590:19: ( palmor )*
while ( stream_palmor.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor.nextTree());
}
stream_palmor.reset();
// Ham4Parser.g:1590:27: ( HamEtc )*
while ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:1590:35: ( HamOrirelative )*
while ( stream_HamOrirelative.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamOrirelative.nextNode());
}
stream_HamOrirelative.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location2_return: (function() {
Ham4Parser.location2_return = function(){};
org.antlr.lang.extend(Ham4Parser.location2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1596:1: location2 : ( location1as2 | location2not1 ) ;
// $ANTLR start "location2"
location2: function() {
var retval = new Ham4Parser.location2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var location1as2154 = null;
var location2not1155 = null;
this.trace("ANTLR Parse: location2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1615:5: ( ( location1as2 | location2not1 ) )
// Ham4Parser.g:1616:5: ( location1as2 | location2not1 )
root_0 = this.adaptor.nil();
// Ham4Parser.g:1616:5: ( location1as2 | location2not1 )
var alt49=2;
alt49 = this.dfa49.predict(this.input);
switch (alt49) {
case 1 :
// Ham4Parser.g:1617:9: location1as2
this.pushFollow(Ham4Parser.FOLLOW_location1as2_in_location25882);
location1as2154=this.location1as2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location1as2154.getTree());
break;
case 2 :
// Ham4Parser.g:1619:9: location2not1
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_location25898);
location2not1155=this.location2not1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location2not1155.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location1as2_return: (function() {
Ham4Parser.location1as2_return = function(){};
org.antlr.lang.extend(Ham4Parser.location1as2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1623:1: location1as2 : location1 -> ^( LOC2 location1 ) ;
// $ANTLR start "location1as2"
location1as2: function() {
var retval = new Ham4Parser.location1as2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var location1156 = null;
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
this.trace("ANTLR Parse: location1as2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1638:5: ( location1 -> ^( LOC2 location1 ) )
// Ham4Parser.g:1638:9: location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location1as25933);
location1156=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1156.getTree());
// AST REWRITE
// elements: location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1639:6: -> ^( LOC2 location1 )
{
// Ham4Parser.g:1639:9: ^( LOC2 location1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
this.adaptor.addChild(root_1, stream_location1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location1as2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location2not1_return: (function() {
Ham4Parser.location2not1_return = function(){};
org.antlr.lang.extend(Ham4Parser.location2not1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1642:1: location2not1 : ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) ) ;
// $ANTLR start "location2not1"
location2not1: function() {
var retval = new Ham4Parser.location2not1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNeutralspace158 = null;
var HamArmextended159 = null;
var HamParbegin161 = null;
var HamPlus163 = null;
var HamParend165 = null;
var handconstellation157 = null;
var locationbody160 = null;
var location1162 = null;
var location1164 = null;
var HamNeutralspace158_tree=null;
var HamArmextended159_tree=null;
var HamParbegin161_tree=null;
var HamPlus163_tree=null;
var HamParend165_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_HamNeutralspace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNeutralspace");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_locationbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbody");
var stream_handconstellation=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconstellation");
this.trace("ANTLR Parse: location2not1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1675:5: ( ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) ) )
// Ham4Parser.g:1676:5: ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) )
// Ham4Parser.g:1676:5: ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) )
var alt53=2;
var LA53_0 = this.input.LA(1);
if ( (LA53_0==HamParbegin) ) {
var LA53_1 = this.input.LA(2);
if ( (this.synpred19_Ham4Parser()) ) {
alt53=1;
}
else if ( (true) ) {
alt53=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 53, 1, this.input);
throw nvae;
}
}
else if ( ((LA53_0>=HamClose && LA53_0<=HamTouch)) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else if ( ((LA53_0>=HamInterlock && LA53_0<=HamCross)) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else if ( (LA53_0==HamSeqbegin) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 53, 0, this.input);
throw nvae;
}
switch (alt53) {
case 1 :
// Ham4Parser.g:1677:9: ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? )
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_location2not16011);
handconstellation157=this.handconstellation();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconstellation.add(handconstellation157.getTree());
// Ham4Parser.g:1680:9: ( HamNeutralspace ( HamArmextended )? | ( locationbody )? )
var alt52=2;
var LA52_0 = this.input.LA(1);
if ( (LA52_0==HamNeutralspace) ) {
alt52=1;
}
else if ( (LA52_0==EOF||LA52_0==HamPlus||(LA52_0>=HamEarlobe && LA52_0<=HamShouldertop)||LA52_0==HamReplace||(LA52_0>=HamTongue && LA52_0<=HamStomach)||(LA52_0>=HamHead && LA52_0<=HamLrat)||(LA52_0>=HamNomotion && LA52_0<=HamMovex)||(LA52_0>=HamFingerplay && LA52_0<=HamCircler)||(LA52_0>=HamRepeatfromstart && LA52_0<=HamRepeatreverse)||(LA52_0>=HamNodding && LA52_0<=HamCircleuo)) ) {
alt52=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 52, 0, this.input);
throw nvae;
}
switch (alt52) {
case 1 :
// Ham4Parser.g:1681:13: HamNeutralspace ( HamArmextended )?
HamNeutralspace158=this.match(this.input,HamNeutralspace,Ham4Parser.FOLLOW_HamNeutralspace_in_location2not16035); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNeutralspace.add(HamNeutralspace158);
// Ham4Parser.g:1682:13: ( HamArmextended )?
var alt50=2;
var LA50_0 = this.input.LA(1);
if ( (LA50_0==HamArmextended) ) {
alt50=1;
}
switch (alt50) {
case 1 :
// Ham4Parser.g:1682:15: HamArmextended
HamArmextended159=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_location2not16051); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended159);
break;
}
break;
case 2 :
// Ham4Parser.g:1684:13: ( locationbody )?
// Ham4Parser.g:1684:13: ( locationbody )?
var alt51=2;
var LA51_0 = this.input.LA(1);
if ( ((LA51_0>=HamEarlobe && LA51_0<=HamShouldertop)||(LA51_0>=HamTongue && LA51_0<=HamStomach)||(LA51_0>=HamHead && LA51_0<=HamLrat)) ) {
alt51=1;
}
switch (alt51) {
case 1 :
// Ham4Parser.g:1684:15: locationbody
this.pushFollow(Ham4Parser.FOLLOW_locationbody_in_location2not16080);
locationbody160=this.locationbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbody.add(locationbody160.getTree());
break;
}
break;
}
// AST REWRITE
// elements: HamArmextended, locationbody, handconstellation
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1686:6: -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? )
{
// Ham4Parser.g:1686:9: ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
this.adaptor.addChild(root_1, stream_handconstellation.nextTree());
// Ham4Parser.g:1686:34: ( HamArmextended )?
if ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:1686:50: ( locationbody )?
if ( stream_locationbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbody.nextTree());
}
stream_locationbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:1688:9: HamParbegin location1 HamPlus location1 HamParend
HamParbegin161=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_location2not16128); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin161);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location2not16138);
location1162=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1162.getTree());
HamPlus163=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_location2not16148); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus163);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location2not16158);
location1164=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1164.getTree());
HamParend165=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_location2not16168); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend165);
// AST REWRITE
// elements: location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1693:6: -> ^( LOC2 ( location1 )* )
{
// Ham4Parser.g:1693:9: ^( LOC2 ( location1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
// Ham4Parser.g:1693:16: ( location1 )*
while ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location2not1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location1_return: (function() {
Ham4Parser.location1_return = function(){};
org.antlr.lang.extend(Ham4Parser.location1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1697:1: location1 : ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm ) -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? ) ;
// $ANTLR start "location1"
location1: function() {
var retval = new Ham4Parser.location1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var locationindexuse166 = null;
var locationhand167 = null;
var locationbodyarm168 = null;
var stream_locationindexuse=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationindexuse");
var stream_locationhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationhand");
var stream_locationbodyarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbodyarm");
this.trace("ANTLR Parse: location1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1723:5: ( ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm ) -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? ) )
// Ham4Parser.g:1724:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )
// Ham4Parser.g:1724:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )
var alt54=3;
alt54 = this.dfa54.predict(this.input);
switch (alt54) {
case 1 :
// Ham4Parser.g:1725:9: ( locationindexuse )=> locationindexuse
this.pushFollow(Ham4Parser.FOLLOW_locationindexuse_in_location16273);
locationindexuse166=this.locationindexuse();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationindexuse.add(locationindexuse166.getTree());
break;
case 2 :
// Ham4Parser.g:1729:9: ( levelhand )=> locationhand
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_location16313);
locationhand167=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand167.getTree());
break;
case 3 :
// Ham4Parser.g:1733:9: locationbodyarm
this.pushFollow(Ham4Parser.FOLLOW_locationbodyarm_in_location16329);
locationbodyarm168=this.locationbodyarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbodyarm.add(locationbodyarm168.getTree());
break;
}
// AST REWRITE
// elements: locationindexuse, locationbodyarm, locationhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1735:5: -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? )
{
// Ham4Parser.g:1735:8: ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC1, "LOC1"), root_1);
// Ham4Parser.g:1735:15: ( locationindexuse )?
if ( stream_locationindexuse.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationindexuse.nextTree());
}
stream_locationindexuse.reset();
// Ham4Parser.g:1735:33: ( locationhand )?
if ( stream_locationhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationhand.nextTree());
}
stream_locationhand.reset();
// Ham4Parser.g:1735:47: ( locationbodyarm )?
if ( stream_locationbodyarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbodyarm.nextTree());
}
stream_locationbodyarm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationindexdefine_return: (function() {
Ham4Parser.locationindexdefine_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationindexdefine_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1738:1: locationindexdefine : digit HamCoreftag ;
// $ANTLR start "locationindexdefine"
locationindexdefine: function() {
var retval = new Ham4Parser.locationindexdefine_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamCoreftag170 = null;
var digit169 = null;
var HamCoreftag170_tree=null;
this.trace("ANTLR Parse: locationindexdefine starts "+this.state.backtracking);
try {
// Ham4Parser.g:1754:5: ( digit HamCoreftag )
// Ham4Parser.g:1755:9: digit HamCoreftag
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_digit_in_locationindexdefine6389);
digit169=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit169.getTree());
HamCoreftag170=this.match(this.input,HamCoreftag,Ham4Parser.FOLLOW_HamCoreftag_in_locationindexdefine6399); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationindexdefine finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationindexuse_return: (function() {
Ham4Parser.locationindexuse_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationindexuse_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1759:1: locationindexuse : digit HamCorefref ;
// $ANTLR start "locationindexuse"
locationindexuse: function() {
var retval = new Ham4Parser.locationindexuse_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamCorefref172 = null;
var digit171 = null;
var HamCorefref172_tree=null;
this.trace("ANTLR Parse: locationindexuse starts "+this.state.backtracking);
try {
// Ham4Parser.g:1775:5: ( digit HamCorefref )
// Ham4Parser.g:1776:9: digit HamCorefref
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_digit_in_locationindexuse6436);
digit171=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit171.getTree());
HamCorefref172=this.match(this.input,HamCorefref,Ham4Parser.FOLLOW_HamCorefref_in_locationindexuse6446); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationindexuse finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationbodyarm_return: (function() {
Ham4Parser.locationbodyarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationbodyarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1780:1: locationbodyarm : ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm ) -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* ) ;
// $ANTLR start "locationbodyarm"
locationbodyarm: function() {
var retval = new Ham4Parser.locationbodyarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNeutralspace173 = null;
var HamArmextended174 = null;
var locationbody175 = null;
var locationarm176 = null;
var HamNeutralspace173_tree=null;
var HamArmextended174_tree=null;
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_HamNeutralspace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNeutralspace");
var stream_locationbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbody");
var stream_locationarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationarm");
this.trace("ANTLR Parse: locationbodyarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1805:5: ( ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm ) -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* ) )
// Ham4Parser.g:1806:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )
// Ham4Parser.g:1806:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )
var alt56=3;
alt56 = this.dfa56.predict(this.input);
switch (alt56) {
case 1 :
// Ham4Parser.g:1807:9: HamNeutralspace ( HamArmextended )?
HamNeutralspace173=this.match(this.input,HamNeutralspace,Ham4Parser.FOLLOW_HamNeutralspace_in_locationbodyarm6489); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNeutralspace.add(HamNeutralspace173);
// Ham4Parser.g:1808:9: ( HamArmextended )?
var alt55=2;
var LA55_0 = this.input.LA(1);
if ( (LA55_0==HamArmextended) ) {
alt55=1;
}
switch (alt55) {
case 1 :
// Ham4Parser.g:1808:11: HamArmextended
HamArmextended174=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_locationbodyarm6501); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended174);
break;
}
break;
case 2 :
// Ham4Parser.g:1810:9: ( levelbody )=> locationbody
this.pushFollow(Ham4Parser.FOLLOW_locationbody_in_locationbodyarm6544);
locationbody175=this.locationbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbody.add(locationbody175.getTree());
break;
case 3 :
// Ham4Parser.g:1814:9: locationarm
this.pushFollow(Ham4Parser.FOLLOW_locationarm_in_locationbodyarm6560);
locationarm176=this.locationarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationarm.add(locationarm176.getTree());
break;
}
// AST REWRITE
// elements: HamArmextended, locationarm, locationbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1816:5: -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* )
{
// Ham4Parser.g:1816:8: ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNBODYARM, "LOCTNBODYARM"), root_1);
// Ham4Parser.g:1816:23: ( HamArmextended )*
while ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:1816:39: ( locationbody )*
while ( stream_locationbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbody.nextTree());
}
stream_locationbody.reset();
// Ham4Parser.g:1816:53: ( locationarm )*
while ( stream_locationarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationarm.nextTree());
}
stream_locationarm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationbodyarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationbody_return: (function() {
Ham4Parser.locationbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1819:1: locationbody : levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? ) ;
// $ANTLR start "locationbody"
locationbody: function() {
var retval = new Ham4Parser.locationbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBehind178 = null;
var levelcomplexbody177 = null;
var contactbody179 = null;
var HamBehind178_tree=null;
var stream_HamBehind=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBehind");
var stream_levelcomplexbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexbody");
var stream_contactbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactbody");
this.trace("ANTLR Parse: locationbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1837:5: ( levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? ) )
// Ham4Parser.g:1837:9: levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexbody_in_locationbody6614);
levelcomplexbody177=this.levelcomplexbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexbody.add(levelcomplexbody177.getTree());
// Ham4Parser.g:1838:9: ( HamBehind )?
var alt57=2;
alt57 = this.dfa57.predict(this.input);
switch (alt57) {
case 1 :
// Ham4Parser.g:1838:11: HamBehind
HamBehind178=this.match(this.input,HamBehind,Ham4Parser.FOLLOW_HamBehind_in_locationbody6626); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBehind.add(HamBehind178);
break;
}
// Ham4Parser.g:1839:9: ( ( contactbody )=> contactbody )?
var alt58=2;
alt58 = this.dfa58.predict(this.input);
switch (alt58) {
case 1 :
// Ham4Parser.g:1839:11: ( contactbody )=> contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_locationbody6649);
contactbody179=this.contactbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactbody.add(contactbody179.getTree());
break;
}
// AST REWRITE
// elements: HamBehind, levelcomplexbody, contactbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1841:7: -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? )
{
// Ham4Parser.g:1841:10: ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNBODY, "LOCTNBODY"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexbody.nextTree());
// Ham4Parser.g:1841:39: ( HamBehind )?
if ( stream_HamBehind.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamBehind.nextNode());
}
stream_HamBehind.reset();
// Ham4Parser.g:1841:50: ( contactbody )?
if ( stream_contactbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactbody.nextTree());
}
stream_contactbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationhand_return: (function() {
Ham4Parser.locationhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1844:1: locationhand : levelcomplexhand ( ( contacthand )=> contacthand )? -> ^( LOCTNHAND levelcomplexhand ( contacthand )? ) ;
// $ANTLR start "locationhand"
locationhand: function() {
var retval = new Ham4Parser.locationhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexhand180 = null;
var contacthand181 = null;
var stream_levelcomplexhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexhand");
var stream_contacthand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contacthand");
this.trace("ANTLR Parse: locationhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:1861:5: ( levelcomplexhand ( ( contacthand )=> contacthand )? -> ^( LOCTNHAND levelcomplexhand ( contacthand )? ) )
// Ham4Parser.g:1861:9: levelcomplexhand ( ( contacthand )=> contacthand )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexhand_in_locationhand6710);
levelcomplexhand180=this.levelcomplexhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexhand.add(levelcomplexhand180.getTree());
// Ham4Parser.g:1862:9: ( ( contacthand )=> contacthand )?
var alt59=2;
alt59 = this.dfa59.predict(this.input);
switch (alt59) {
case 1 :
// Ham4Parser.g:1862:11: ( contacthand )=> contacthand
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_locationhand6728);
contacthand181=this.contacthand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contacthand.add(contacthand181.getTree());
break;
}
// AST REWRITE
// elements: levelcomplexhand, contacthand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1864:7: -> ^( LOCTNHAND levelcomplexhand ( contacthand )? )
{
// Ham4Parser.g:1864:10: ^( LOCTNHAND levelcomplexhand ( contacthand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNHAND, "LOCTNHAND"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexhand.nextTree());
// Ham4Parser.g:1864:39: ( contacthand )?
if ( stream_contacthand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contacthand.nextTree());
}
stream_contacthand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationarm_return: (function() {
Ham4Parser.locationarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1867:1: locationarm : levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? ) ;
// $ANTLR start "locationarm"
locationarm: function() {
var retval = new Ham4Parser.locationarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBehind183 = null;
var levelcomplexarm182 = null;
var contactbody184 = null;
var HamBehind183_tree=null;
var stream_HamBehind=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBehind");
var stream_contactbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactbody");
var stream_levelcomplexarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexarm");
this.trace("ANTLR Parse: locationarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1885:5: ( levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? ) )
// Ham4Parser.g:1885:9: levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexarm_in_locationarm6786);
levelcomplexarm182=this.levelcomplexarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexarm.add(levelcomplexarm182.getTree());
// Ham4Parser.g:1886:9: ( HamBehind )?
var alt60=2;
alt60 = this.dfa60.predict(this.input);
switch (alt60) {
case 1 :
// Ham4Parser.g:1886:11: HamBehind
HamBehind183=this.match(this.input,HamBehind,Ham4Parser.FOLLOW_HamBehind_in_locationarm6798); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBehind.add(HamBehind183);
break;
}
// Ham4Parser.g:1887:9: ( ( contactbody )=> contactbody )?
var alt61=2;
alt61 = this.dfa61.predict(this.input);
switch (alt61) {
case 1 :
// Ham4Parser.g:1887:11: ( contactbody )=> contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_locationarm6821);
contactbody184=this.contactbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactbody.add(contactbody184.getTree());
break;
}
// AST REWRITE
// elements: levelcomplexarm, contactbody, HamBehind
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1889:7: -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? )
{
// Ham4Parser.g:1889:10: ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNARM, "LOCTNARM"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexarm.nextTree());
// Ham4Parser.g:1889:37: ( HamBehind )?
if ( stream_HamBehind.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamBehind.nextNode());
}
stream_HamBehind.reset();
// Ham4Parser.g:1889:48: ( contactbody )?
if ( stream_contactbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactbody.nextTree());
}
stream_contactbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexbody_return: (function() {
Ham4Parser.levelcomplexbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1892:1: levelcomplexbody : levelbody ( HamBetween levelbody )? ;
// $ANTLR start "levelcomplexbody"
levelcomplexbody: function() {
var retval = new Ham4Parser.levelcomplexbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween186 = null;
var levelbody185 = null;
var levelbody187 = null;
var HamBetween186_tree=null;
this.trace("ANTLR Parse: levelcomplexbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1910:5: ( levelbody ( HamBetween levelbody )? )
// Ham4Parser.g:1910:9: levelbody ( HamBetween levelbody )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_levelcomplexbody6882);
levelbody185=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelbody185.getTree());
// Ham4Parser.g:1911:9: ( HamBetween levelbody )?
var alt62=2;
var LA62_0 = this.input.LA(1);
if ( (LA62_0==HamBetween) ) {
alt62=1;
}
switch (alt62) {
case 1 :
// Ham4Parser.g:1912:13: HamBetween levelbody
HamBetween186=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexbody6906); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_levelcomplexbody6922);
levelbody187=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelbody187.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexhand_return: (function() {
Ham4Parser.levelcomplexhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1917:1: levelcomplexhand : levelhand ( HamBetween levelhand )? ;
// $ANTLR start "levelcomplexhand"
levelcomplexhand: function() {
var retval = new Ham4Parser.levelcomplexhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween189 = null;
var levelhand188 = null;
var levelhand190 = null;
var HamBetween189_tree=null;
this.trace("ANTLR Parse: levelcomplexhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:1935:5: ( levelhand ( HamBetween levelhand )? )
// Ham4Parser.g:1935:9: levelhand ( HamBetween levelhand )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_levelcomplexhand6962);
levelhand188=this.levelhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelhand188.getTree());
// Ham4Parser.g:1936:9: ( HamBetween levelhand )?
var alt63=2;
var LA63_0 = this.input.LA(1);
if ( (LA63_0==HamBetween) ) {
alt63=1;
}
switch (alt63) {
case 1 :
// Ham4Parser.g:1937:13: HamBetween levelhand
HamBetween189=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexhand6986); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_levelcomplexhand7002);
levelhand190=this.levelhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelhand190.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexarm_return: (function() {
Ham4Parser.levelcomplexarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1942:1: levelcomplexarm : levelarm ( HamBetween levelarm )? ;
// $ANTLR start "levelcomplexarm"
levelcomplexarm: function() {
var retval = new Ham4Parser.levelcomplexarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween192 = null;
var levelarm191 = null;
var levelarm193 = null;
var HamBetween192_tree=null;
this.trace("ANTLR Parse: levelcomplexarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1960:5: ( levelarm ( HamBetween levelarm )? )
// Ham4Parser.g:1960:9: levelarm ( HamBetween levelarm )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_levelcomplexarm7042);
levelarm191=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelarm191.getTree());
// Ham4Parser.g:1961:9: ( HamBetween levelarm )?
var alt64=2;
var LA64_0 = this.input.LA(1);
if ( (LA64_0==HamBetween) ) {
alt64=1;
}
switch (alt64) {
case 1 :
// Ham4Parser.g:1962:13: HamBetween levelarm
HamBetween192=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexarm7066); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_levelcomplexarm7082);
levelarm193=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelarm193.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelbody_return: (function() {
Ham4Parser.levelbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1967:1: levelbody : ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) ) ;
// $ANTLR start "levelbody"
levelbody: function() {
var retval = new Ham4Parser.levelbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamEtc195 = null;
var HamEtc198 = null;
var HamEtc202 = null;
var HamEtc204 = null;
var locbody194 = null;
var side196 = null;
var locsided197 = null;
var side199 = null;
var side200 = null;
var locbody201 = null;
var locsided203 = null;
var HamEtc195_tree=null;
var HamEtc198_tree=null;
var HamEtc202_tree=null;
var HamEtc204_tree=null;
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_locsided=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locsided");
var stream_locbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locbody");
this.trace("ANTLR Parse: levelbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:2002:5: ( ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) ) )
// Ham4Parser.g:2003:5: ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) )
// Ham4Parser.g:2003:5: ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) )
var alt72=3;
switch ( this.input.LA(1) ) {
case HamNostrils:
case HamShouldertop:
case HamTongue:
case HamTeeth:
case HamStomach:
case HamHead:
case HamHeadtop:
case HamForehead:
case HamEyebrows:
case HamEyes:
case HamNose:
case HamLips:
case HamChin:
case HamUnderchin:
case HamNeck:
case HamShoulders:
case HamChest:
case HamBelowstomach:
alt72=1;
break;
case HamEarlobe:
case HamEar:
case HamCheek:
alt72=2;
break;
case HamLrbeside:
case HamLrat:
alt72=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 72, 0, this.input);
throw nvae;
}
switch (alt72) {
case 1 :
// Ham4Parser.g:2004:9: locbody ( HamEtc )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locbody_in_levelbody7134);
locbody194=this.locbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbody.add(locbody194.getTree());
// Ham4Parser.g:2005:9: ( HamEtc )?
var alt65=2;
var LA65_0 = this.input.LA(1);
if ( (LA65_0==HamEtc) ) {
alt65=1;
}
switch (alt65) {
case 1 :
// Ham4Parser.g:2005:11: HamEtc
HamEtc195=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7146); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc195);
break;
}
// Ham4Parser.g:2006:9: ( side )?
var alt66=2;
var LA66_0 = this.input.LA(1);
if ( ((LA66_0>=HamLrbeside && LA66_0<=HamLrat)) ) {
alt66=1;
}
switch (alt66) {
case 1 :
// Ham4Parser.g:2006:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7161);
side196=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side196.getTree());
break;
}
// AST REWRITE
// elements: locbody, HamEtc, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2007:6: -> ^( LEVBODY locbody ( HamEtc )? ( side )? )
{
// Ham4Parser.g:2007:9: ^( LEVBODY locbody ( HamEtc )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_locbody.nextTree());
// Ham4Parser.g:2007:27: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2007:35: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2009:9: locsided ( HamEtc )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locsided_in_levelbody7199);
locsided197=this.locsided();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locsided.add(locsided197.getTree());
// Ham4Parser.g:2010:9: ( HamEtc )?
var alt67=2;
var LA67_0 = this.input.LA(1);
if ( (LA67_0==HamEtc) ) {
alt67=1;
}
switch (alt67) {
case 1 :
// Ham4Parser.g:2010:11: HamEtc
HamEtc198=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7211); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc198);
break;
}
// Ham4Parser.g:2011:9: ( side )?
var alt68=2;
var LA68_0 = this.input.LA(1);
if ( ((LA68_0>=HamLrbeside && LA68_0<=HamLrat)) ) {
alt68=1;
}
switch (alt68) {
case 1 :
// Ham4Parser.g:2011:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7226);
side199=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side199.getTree());
break;
}
// AST REWRITE
// elements: locsided, HamEtc, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2012:6: -> ^( LEVBODY locsided ( HamEtc )? ( side )? )
{
// Ham4Parser.g:2012:9: ^( LEVBODY locsided ( HamEtc )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_locsided.nextTree());
// Ham4Parser.g:2012:28: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2012:36: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2014:9: side ( locbody ( HamEtc )? | locsided ( HamEtc )? )
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7264);
side200=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side200.getTree());
// Ham4Parser.g:2015:9: ( locbody ( HamEtc )? | locsided ( HamEtc )? )
var alt71=2;
var LA71_0 = this.input.LA(1);
if ( ((LA71_0>=HamNostrils && LA71_0<=HamShouldertop)||(LA71_0>=HamTongue && LA71_0<=HamStomach)||(LA71_0>=HamHead && LA71_0<=HamNose)||(LA71_0>=HamLips && LA71_0<=HamBelowstomach)) ) {
alt71=1;
}
else if ( (LA71_0==HamEarlobe||(LA71_0>=HamEar && LA71_0<=HamCheek)) ) {
alt71=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 71, 0, this.input);
throw nvae;
}
switch (alt71) {
case 1 :
// Ham4Parser.g:2016:13: locbody ( HamEtc )?
this.pushFollow(Ham4Parser.FOLLOW_locbody_in_levelbody7288);
locbody201=this.locbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbody.add(locbody201.getTree());
// Ham4Parser.g:2017:13: ( HamEtc )?
var alt69=2;
var LA69_0 = this.input.LA(1);
if ( (LA69_0==HamEtc) ) {
alt69=1;
}
switch (alt69) {
case 1 :
// Ham4Parser.g:2017:15: HamEtc
HamEtc202=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7304); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc202);
break;
}
break;
case 2 :
// Ham4Parser.g:2019:13: locsided ( HamEtc )?
this.pushFollow(Ham4Parser.FOLLOW_locsided_in_levelbody7331);
locsided203=this.locsided();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locsided.add(locsided203.getTree());
// Ham4Parser.g:2020:13: ( HamEtc )?
var alt70=2;
var LA70_0 = this.input.LA(1);
if ( (LA70_0==HamEtc) ) {
alt70=1;
}
switch (alt70) {
case 1 :
// Ham4Parser.g:2020:15: HamEtc
HamEtc204=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7347); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc204);
break;
}
break;
}
// AST REWRITE
// elements: locbody, side, HamEtc, locsided
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2022:6: -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? )
{
// Ham4Parser.g:2022:9: ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
// Ham4Parser.g:2022:24: ( locbody )?
if ( stream_locbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locbody.nextTree());
}
stream_locbody.reset();
// Ham4Parser.g:2022:33: ( locsided )?
if ( stream_locsided.hasNext() ) {
this.adaptor.addChild(root_1, stream_locsided.nextTree());
}
stream_locsided.reset();
// Ham4Parser.g:2022:43: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelhand_return: (function() {
Ham4Parser.levelhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2026:1: levelhand : ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) ) ;
// $ANTLR start "levelhand"
levelhand: function() {
var retval = new Ham4Parser.levelhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var lochand205 = null;
var dorsalorpalmar206 = null;
var side207 = null;
var side208 = null;
var lochand209 = null;
var dorsalorpalmar210 = null;
var stream_lochand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule lochand");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_dorsalorpalmar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dorsalorpalmar");
this.trace("ANTLR Parse: levelhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2051:5: ( ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) ) )
// Ham4Parser.g:2052:5: ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) )
// Ham4Parser.g:2052:5: ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) )
var alt76=2;
var LA76_0 = this.input.LA(1);
if ( ((LA76_0>=HamWristback && LA76_0<=HamPinkyside)||(LA76_0>=HamFingertip && LA76_0<=HamFingerside)) ) {
alt76=1;
}
else if ( ((LA76_0>=HamLrbeside && LA76_0<=HamLrat)) ) {
alt76=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 76, 0, this.input);
throw nvae;
}
switch (alt76) {
case 1 :
// Ham4Parser.g:2053:9: lochand ( dorsalorpalmar )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_lochand_in_levelhand7429);
lochand205=this.lochand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_lochand.add(lochand205.getTree());
// Ham4Parser.g:2054:9: ( dorsalorpalmar )?
var alt73=2;
var LA73_0 = this.input.LA(1);
if ( ((LA73_0>=HamPalm && LA73_0<=HamHandback)) ) {
alt73=1;
}
switch (alt73) {
case 1 :
// Ham4Parser.g:2054:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelhand7441);
dorsalorpalmar206=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar206.getTree());
break;
}
// Ham4Parser.g:2055:9: ( side )?
var alt74=2;
var LA74_0 = this.input.LA(1);
if ( ((LA74_0>=HamLrbeside && LA74_0<=HamLrat)) ) {
alt74=1;
}
switch (alt74) {
case 1 :
// Ham4Parser.g:2055:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelhand7456);
side207=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side207.getTree());
break;
}
// AST REWRITE
// elements: dorsalorpalmar, lochand, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2056:5: -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? )
{
// Ham4Parser.g:2056:8: ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVHAND, "LEVHAND"), root_1);
this.adaptor.addChild(root_1, stream_lochand.nextTree());
// Ham4Parser.g:2056:26: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
// Ham4Parser.g:2056:42: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2058:9: side lochand ( dorsalorpalmar )?
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelhand7496);
side208=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side208.getTree());
this.pushFollow(Ham4Parser.FOLLOW_lochand_in_levelhand7506);
lochand209=this.lochand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_lochand.add(lochand209.getTree());
// Ham4Parser.g:2060:9: ( dorsalorpalmar )?
var alt75=2;
var LA75_0 = this.input.LA(1);
if ( ((LA75_0>=HamPalm && LA75_0<=HamHandback)) ) {
alt75=1;
}
switch (alt75) {
case 1 :
// Ham4Parser.g:2060:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelhand7518);
dorsalorpalmar210=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar210.getTree());
break;
}
// AST REWRITE
// elements: side, lochand, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2061:5: -> ^( LEVHAND side lochand ( dorsalorpalmar )? )
{
// Ham4Parser.g:2061:8: ^( LEVHAND side lochand ( dorsalorpalmar )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVHAND, "LEVHAND"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
this.adaptor.addChild(root_1, stream_lochand.nextTree());
// Ham4Parser.g:2061:31: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelarm_return: (function() {
Ham4Parser.levelarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2065:1: levelarm : ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) ) ;
// $ANTLR start "levelarm"
levelarm: function() {
var retval = new Ham4Parser.levelarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamEtc212 = null;
var HamEtc217 = null;
var locarm211 = null;
var dorsalorpalmar213 = null;
var side214 = null;
var side215 = null;
var locarm216 = null;
var dorsalorpalmar218 = null;
var HamEtc212_tree=null;
var HamEtc217_tree=null;
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_dorsalorpalmar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dorsalorpalmar");
var stream_locarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locarm");
this.trace("ANTLR Parse: levelarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:2092:5: ( ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) ) )
// Ham4Parser.g:2093:5: ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) )
// Ham4Parser.g:2093:5: ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) )
var alt82=2;
var LA82_0 = this.input.LA(1);
if ( ((LA82_0>=HamUpperarm && LA82_0<=HamLowerarm)) ) {
alt82=1;
}
else if ( ((LA82_0>=HamLrbeside && LA82_0<=HamLrat)) ) {
alt82=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 82, 0, this.input);
throw nvae;
}
switch (alt82) {
case 1 :
// Ham4Parser.g:2094:9: locarm ( HamEtc )? ( dorsalorpalmar )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locarm_in_levelarm7585);
locarm211=this.locarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locarm.add(locarm211.getTree());
// Ham4Parser.g:2095:9: ( HamEtc )?
var alt77=2;
var LA77_0 = this.input.LA(1);
if ( (LA77_0==HamEtc) ) {
alt77=1;
}
switch (alt77) {
case 1 :
// Ham4Parser.g:2095:11: HamEtc
HamEtc212=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelarm7597); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc212);
break;
}
// Ham4Parser.g:2096:9: ( dorsalorpalmar )?
var alt78=2;
var LA78_0 = this.input.LA(1);
if ( ((LA78_0>=HamPalm && LA78_0<=HamHandback)) ) {
alt78=1;
}
switch (alt78) {
case 1 :
// Ham4Parser.g:2096:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelarm7612);
dorsalorpalmar213=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar213.getTree());
break;
}
// Ham4Parser.g:2097:9: ( side )?
var alt79=2;
var LA79_0 = this.input.LA(1);
if ( ((LA79_0>=HamLrbeside && LA79_0<=HamLrat)) ) {
alt79=1;
}
switch (alt79) {
case 1 :
// Ham4Parser.g:2097:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelarm7627);
side214=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side214.getTree());
break;
}
// AST REWRITE
// elements: side, locarm, HamEtc, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2098:6: -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? )
{
// Ham4Parser.g:2098:9: ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVARM, "LEVARM"), root_1);
this.adaptor.addChild(root_1, stream_locarm.nextTree());
// Ham4Parser.g:2098:25: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2098:33: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
// Ham4Parser.g:2098:49: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2100:9: side locarm ( HamEtc )? ( dorsalorpalmar )?
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelarm7668);
side215=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side215.getTree());
this.pushFollow(Ham4Parser.FOLLOW_locarm_in_levelarm7678);
locarm216=this.locarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locarm.add(locarm216.getTree());
// Ham4Parser.g:2102:9: ( HamEtc )?
var alt80=2;
var LA80_0 = this.input.LA(1);
if ( (LA80_0==HamEtc) ) {
alt80=1;
}
switch (alt80) {
case 1 :
// Ham4Parser.g:2102:11: HamEtc
HamEtc217=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelarm7690); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc217);
break;
}
// Ham4Parser.g:2103:9: ( dorsalorpalmar )?
var alt81=2;
var LA81_0 = this.input.LA(1);
if ( ((LA81_0>=HamPalm && LA81_0<=HamHandback)) ) {
alt81=1;
}
switch (alt81) {
case 1 :
// Ham4Parser.g:2103:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelarm7705);
dorsalorpalmar218=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar218.getTree());
break;
}
// AST REWRITE
// elements: locarm, HamEtc, side, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2104:6: -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? )
{
// Ham4Parser.g:2104:9: ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVARM, "LEVARM"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
this.adaptor.addChild(root_1, stream_locarm.nextTree());
// Ham4Parser.g:2104:30: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2104:38: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactbody_return: (function() {
Ham4Parser.contactbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2108:1: contactbody : ( pcontact | HamArmextended | contactofhand ) -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? ) ;
// $ANTLR start "contactbody"
contactbody: function() {
var retval = new Ham4Parser.contactbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamArmextended220 = null;
var pcontact219 = null;
var contactofhand221 = null;
var HamArmextended220_tree=null;
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactofhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactofhand");
this.trace("ANTLR Parse: contactbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:2130:5: ( ( pcontact | HamArmextended | contactofhand ) -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? ) )
// Ham4Parser.g:2131:5: ( pcontact | HamArmextended | contactofhand )
// Ham4Parser.g:2131:5: ( pcontact | HamArmextended | contactofhand )
var alt83=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt83=1;
break;
case HamArmextended:
alt83=2;
break;
case HamSeqbegin:
alt83=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 83, 0, this.input);
throw nvae;
}
switch (alt83) {
case 1 :
// Ham4Parser.g:2132:9: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contactbody7776);
pcontact219=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact219.getTree());
break;
case 2 :
// Ham4Parser.g:2134:9: HamArmextended
HamArmextended220=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_contactbody7792); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended220);
break;
case 3 :
// Ham4Parser.g:2136:9: contactofhand
this.pushFollow(Ham4Parser.FOLLOW_contactofhand_in_contactbody7808);
contactofhand221=this.contactofhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactofhand.add(contactofhand221.getTree());
break;
}
// AST REWRITE
// elements: contactofhand, HamArmextended, pcontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2138:5: -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? )
{
// Ham4Parser.g:2138:8: ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTBODY, "CNTCTBODY"), root_1);
// Ham4Parser.g:2138:20: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2138:30: ( HamArmextended )?
if ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:2138:46: ( contactofhand )?
if ( stream_contactofhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactofhand.nextTree());
}
stream_contactofhand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contacthand_return: (function() {
Ham4Parser.contacthand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contacthand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2141:1: contacthand : ( pcontact | ccontact | contactofhand ) -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? ) ;
// $ANTLR start "contacthand"
contacthand: function() {
var retval = new Ham4Parser.contacthand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var pcontact222 = null;
var ccontact223 = null;
var contactofhand224 = null;
var stream_ccontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ccontact");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactofhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactofhand");
this.trace("ANTLR Parse: contacthand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2163:5: ( ( pcontact | ccontact | contactofhand ) -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? ) )
// Ham4Parser.g:2164:5: ( pcontact | ccontact | contactofhand )
// Ham4Parser.g:2164:5: ( pcontact | ccontact | contactofhand )
var alt84=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt84=1;
break;
case HamInterlock:
case HamCross:
alt84=2;
break;
case HamSeqbegin:
alt84=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 84, 0, this.input);
throw nvae;
}
switch (alt84) {
case 1 :
// Ham4Parser.g:2165:9: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contacthand7874);
pcontact222=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact222.getTree());
break;
case 2 :
// Ham4Parser.g:2167:9: ccontact
this.pushFollow(Ham4Parser.FOLLOW_ccontact_in_contacthand7890);
ccontact223=this.ccontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ccontact.add(ccontact223.getTree());
break;
case 3 :
// Ham4Parser.g:2169:9: contactofhand
this.pushFollow(Ham4Parser.FOLLOW_contactofhand_in_contacthand7906);
contactofhand224=this.contactofhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactofhand.add(contactofhand224.getTree());
break;
}
// AST REWRITE
// elements: pcontact, contactofhand, ccontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2171:5: -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? )
{
// Ham4Parser.g:2171:8: ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTHAND, "CNTCTHAND"), root_1);
// Ham4Parser.g:2171:20: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2171:30: ( ccontact )?
if ( stream_ccontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_ccontact.nextTree());
}
stream_ccontact.reset();
// Ham4Parser.g:2171:40: ( contactofhand )?
if ( stream_contactofhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactofhand.nextTree());
}
stream_contactofhand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contacthand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconstellation_return: (function() {
Ham4Parser.handconstellation_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconstellation_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2174:1: handconstellation : ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand -> ^( HCONSTLLN ( locationhand )* contacthand ) ;
// $ANTLR start "handconstellation"
handconstellation: function() {
var retval = new Ham4Parser.handconstellation_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin225 = null;
var HamPlus227 = null;
var HamParend229 = null;
var locationhand226 = null;
var locationhand228 = null;
var contacthand230 = null;
var HamParbegin225_tree=null;
var HamPlus227_tree=null;
var HamParend229_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_contacthand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contacthand");
var stream_locationhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationhand");
this.trace("ANTLR Parse: handconstellation starts "+this.state.backtracking);
try {
// Ham4Parser.g:2197:5: ( ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand -> ^( HCONSTLLN ( locationhand )* contacthand ) )
// Ham4Parser.g:2197:9: ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand
// Ham4Parser.g:2197:9: ( HamParbegin locationhand HamPlus locationhand HamParend )?
var alt85=2;
var LA85_0 = this.input.LA(1);
if ( (LA85_0==HamParbegin) ) {
alt85=1;
}
switch (alt85) {
case 1 :
// Ham4Parser.g:2198:13: HamParbegin locationhand HamPlus locationhand HamParend
HamParbegin225=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handconstellation7974); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin225);
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_handconstellation7989);
locationhand226=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand226.getTree());
HamPlus227=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handconstellation8003); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus227);
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_handconstellation8018);
locationhand228=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand228.getTree());
HamParend229=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handconstellation8032); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend229);
break;
}
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_handconstellation8054);
contacthand230=this.contacthand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contacthand.add(contacthand230.getTree());
// AST REWRITE
// elements: contacthand, locationhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2206:6: -> ^( HCONSTLLN ( locationhand )* contacthand )
{
// Ham4Parser.g:2206:9: ^( HCONSTLLN ( locationhand )* contacthand )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HCONSTLLN, "HCONSTLLN"), root_1);
// Ham4Parser.g:2206:21: ( locationhand )*
while ( stream_locationhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationhand.nextTree());
}
stream_locationhand.reset();
this.adaptor.addChild(root_1, stream_contacthand.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconstellation finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactofhand_return: (function() {
Ham4Parser.contactofhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactofhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2209:1: contactofhand : HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? ) ;
// $ANTLR start "contactofhand"
contactofhand: function() {
var retval = new Ham4Parser.contactofhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin231 = null;
var HamSeqend236 = null;
var pcontact232 = null;
var ccontact233 = null;
var contactohhand234 = null;
var contactoharm235 = null;
var HamSeqbegin231_tree=null;
var HamSeqend236_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_contactoharm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactoharm");
var stream_ccontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ccontact");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactohhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactohhand");
this.trace("ANTLR Parse: contactofhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2238:5: ( HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? ) )
// Ham4Parser.g:2238:9: HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend
HamSeqbegin231=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_contactofhand8108); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin231);
// Ham4Parser.g:2239:9: ( pcontact | ccontact )
var alt86=2;
var LA86_0 = this.input.LA(1);
if ( ((LA86_0>=HamClose && LA86_0<=HamTouch)) ) {
alt86=1;
}
else if ( ((LA86_0>=HamInterlock && LA86_0<=HamCross)) ) {
alt86=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 86, 0, this.input);
throw nvae;
}
switch (alt86) {
case 1 :
// Ham4Parser.g:2240:13: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contactofhand8133);
pcontact232=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact232.getTree());
break;
case 2 :
// Ham4Parser.g:2242:13: ccontact
this.pushFollow(Ham4Parser.FOLLOW_ccontact_in_contactofhand8157);
ccontact233=this.ccontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ccontact.add(ccontact233.getTree());
break;
}
// Ham4Parser.g:2244:9: ( ( levelhand )=> contactohhand | contactoharm )
var alt87=2;
var LA87_0 = this.input.LA(1);
if ( ((LA87_0>=HamWristback && LA87_0<=HamHandback)||(LA87_0>=HamThumbside && LA87_0<=HamPinkyside)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamFingertip && LA87_0<=HamFingerside)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( (LA87_0==HamThumb) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamIndexfinger && LA87_0<=HamPinky)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamLrbeside && LA87_0<=HamLrat)) ) {
var LA87_5 = this.input.LA(2);
if ( (this.synpred26_Ham4Parser()) ) {
alt87=1;
}
else if ( (true) ) {
alt87=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 87, 5, this.input);
throw nvae;
}
}
else if ( ((LA87_0>=HamUpperarm && LA87_0<=HamLowerarm)) ) {
alt87=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 87, 0, this.input);
throw nvae;
}
switch (alt87) {
case 1 :
// Ham4Parser.g:2245:13: ( levelhand )=> contactohhand
this.pushFollow(Ham4Parser.FOLLOW_contactohhand_in_contactofhand8223);
contactohhand234=this.contactohhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactohhand.add(contactohhand234.getTree());
break;
case 2 :
// Ham4Parser.g:2249:13: contactoharm
this.pushFollow(Ham4Parser.FOLLOW_contactoharm_in_contactofhand8247);
contactoharm235=this.contactoharm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactoharm.add(contactoharm235.getTree());
break;
}
HamSeqend236=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_contactofhand8267); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend236);
// AST REWRITE
// elements: pcontact, contactohhand, contactoharm, ccontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2253:6: -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? )
{
// Ham4Parser.g:2253:9: ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOFHAND, "CNTCTOFHAND"), root_1);
// Ham4Parser.g:2253:23: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2253:33: ( ccontact )?
if ( stream_ccontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_ccontact.nextTree());
}
stream_ccontact.reset();
// Ham4Parser.g:2253:43: ( contactohhand )?
if ( stream_contactohhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactohhand.nextTree());
}
stream_contactohhand.reset();
// Ham4Parser.g:2253:58: ( contactoharm )?
if ( stream_contactoharm.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactoharm.nextTree());
}
stream_contactoharm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactofhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactohhand_return: (function() {
Ham4Parser.contactohhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactohhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2256:1: contactohhand : levelcomplexhand -> ^( CNTCTOHHAND levelcomplexhand ) ;
// $ANTLR start "contactohhand"
contactohhand: function() {
var retval = new Ham4Parser.contactohhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexhand237 = null;
var stream_levelcomplexhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexhand");
this.trace("ANTLR Parse: contactohhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2272:5: ( levelcomplexhand -> ^( CNTCTOHHAND levelcomplexhand ) )
// Ham4Parser.g:2272:9: levelcomplexhand
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexhand_in_contactohhand8329);
levelcomplexhand237=this.levelcomplexhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexhand.add(levelcomplexhand237.getTree());
// AST REWRITE
// elements: levelcomplexhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2274:6: -> ^( CNTCTOHHAND levelcomplexhand )
{
// Ham4Parser.g:2274:9: ^( CNTCTOHHAND levelcomplexhand )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOHHAND, "CNTCTOHHAND"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexhand.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactohhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactoharm_return: (function() {
Ham4Parser.contactoharm_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactoharm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2277:1: contactoharm : levelcomplexarm -> ^( CNTCTOHARM levelcomplexarm ) ;
// $ANTLR start "contactoharm"
contactoharm: function() {
var retval = new Ham4Parser.contactoharm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexarm238 = null;
var stream_levelcomplexarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexarm");
this.trace("ANTLR Parse: contactoharm starts "+this.state.backtracking);
try {
// Ham4Parser.g:2293:5: ( levelcomplexarm -> ^( CNTCTOHARM levelcomplexarm ) )
// Ham4Parser.g:2293:9: levelcomplexarm
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexarm_in_contactoharm8380);
levelcomplexarm238=this.levelcomplexarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexarm.add(levelcomplexarm238.getTree());
// AST REWRITE
// elements: levelcomplexarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2295:6: -> ^( CNTCTOHARM levelcomplexarm )
{
// Ham4Parser.g:2295:9: ^( CNTCTOHARM levelcomplexarm )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOHARM, "CNTCTOHARM"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexarm.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactoharm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
lochand_return: (function() {
Ham4Parser.lochand_return = function(){};
org.antlr.lang.extend(Ham4Parser.lochand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2298:1: lochand : ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? ) ;
// $ANTLR start "lochand"
lochand: function() {
var retval = new Ham4Parser.lochand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handpart239 = null;
var fingerpart240 = null;
var digit241 = null;
var digit242 = null;
var fingerpart243 = null;
this.trace("ANTLR Parse: lochand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2321:5: ( ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? ) )
// Ham4Parser.g:2322:5: ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? )
root_0 = this.adaptor.nil();
// Ham4Parser.g:2322:5: ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? )
var alt91=3;
switch ( this.input.LA(1) ) {
case HamWristback:
case HamWristpulse:
case HamThumbball:
case HamPalm:
case HamHandback:
case HamThumbside:
case HamPinkyside:
alt91=1;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt91=2;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt91=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 91, 0, this.input);
throw nvae;
}
switch (alt91) {
case 1 :
// Ham4Parser.g:2323:9: handpart
this.pushFollow(Ham4Parser.FOLLOW_handpart_in_lochand8443);
handpart239=this.handpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, handpart239.getTree());
break;
case 2 :
// Ham4Parser.g:2325:9: fingerpart ( digit )*
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_lochand8459);
fingerpart240=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerpart240.getTree());
// Ham4Parser.g:2326:9: ( digit )*
loop88:
do {
var alt88=2;
var LA88_0 = this.input.LA(1);
if ( ((LA88_0>=HamThumb && LA88_0<=HamPinky)) ) {
alt88=1;
}
switch (alt88) {
case 1 :
// Ham4Parser.g:2326:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_lochand8471);
digit241=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit241.getTree());
break;
default :
break loop88;
}
} while (true);
break;
case 3 :
// Ham4Parser.g:2328:9: ( digit )+ ( fingerpart )?
// Ham4Parser.g:2328:9: ( digit )+
var cnt89=0;
loop89:
do {
var alt89=2;
var LA89_0 = this.input.LA(1);
if ( ((LA89_0>=HamThumb && LA89_0<=HamPinky)) ) {
alt89=1;
}
switch (alt89) {
case 1 :
// Ham4Parser.g:2328:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_lochand8492);
digit242=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit242.getTree());
break;
default :
if ( cnt89 >= 1 ) {
break loop89;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(89, this.input);
throw eee;
}
cnt89++;
} while (true);
// Ham4Parser.g:2329:9: ( fingerpart )?
var alt90=2;
var LA90_0 = this.input.LA(1);
if ( ((LA90_0>=HamFingertip && LA90_0<=HamFingerside)) ) {
alt90=1;
}
switch (alt90) {
case 1 :
// Ham4Parser.g:2329:11: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_lochand8507);
fingerpart243=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerpart243.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: lochand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a2tstar_return: (function() {
Ham4Parser.a2tstar_return = function(){};
org.antlr.lang.extend(Ham4Parser.a2tstar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2336:1: a2tstar : a2tlist -> ^( A2TLIST ( a2tlist )? ) ;
// $ANTLR start "a2tstar"
a2tstar: function() {
var retval = new Ham4Parser.a2tstar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var a2tlist244 = null;
var stream_a2tlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a2tlist");
this.trace("ANTLR Parse: a2tstar starts "+this.state.backtracking);
try {
// Ham4Parser.g:2352:5: ( a2tlist -> ^( A2TLIST ( a2tlist )? ) )
// Ham4Parser.g:2352:9: a2tlist
this.pushFollow(Ham4Parser.FOLLOW_a2tlist_in_a2tstar8548);
a2tlist244=this.a2tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a2tlist.add(a2tlist244.getTree());
// AST REWRITE
// elements: a2tlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2354:6: -> ^( A2TLIST ( a2tlist )? )
{
// Ham4Parser.g:2354:9: ^( A2TLIST ( a2tlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(A2TLIST, "A2TLIST"), root_1);
// Ham4Parser.g:2354:19: ( a2tlist )?
if ( stream_a2tlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_a2tlist.nextTree());
}
stream_a2tlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a2tstar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a1tstar_return: (function() {
Ham4Parser.a1tstar_return = function(){};
org.antlr.lang.extend(Ham4Parser.a1tstar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2357:1: a1tstar : a1tlist -> ^( A1TLIST ( a1tlist )? ) ;
// $ANTLR start "a1tstar"
a1tstar: function() {
var retval = new Ham4Parser.a1tstar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var a1tlist245 = null;
var stream_a1tlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tlist");
this.trace("ANTLR Parse: a1tstar starts "+this.state.backtracking);
try {
// Ham4Parser.g:2373:5: ( a1tlist -> ^( A1TLIST ( a1tlist )? ) )
// Ham4Parser.g:2373:9: a1tlist
this.pushFollow(Ham4Parser.FOLLOW_a1tlist_in_a1tstar8600);
a1tlist245=this.a1tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tlist.add(a1tlist245.getTree());
// AST REWRITE
// elements: a1tlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2375:6: -> ^( A1TLIST ( a1tlist )? )
{
// Ham4Parser.g:2375:9: ^( A1TLIST ( a1tlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(A1TLIST, "A1TLIST"), root_1);
// Ham4Parser.g:2375:19: ( a1tlist )?
if ( stream_a1tlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_a1tlist.nextTree());
}
stream_a1tlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a1tstar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a2tlist_return: (function() {
Ham4Parser.a2tlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.a2tlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2378:1: a2tlist : ( action2t a2tlist )? ;
// $ANTLR start "a2tlist"
a2tlist: function() {
var retval = new Ham4Parser.a2tlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action2t246 = null;
var a2tlist247 = null;
this.trace("ANTLR Parse: a2tlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:2396:5: ( ( action2t a2tlist )? )
// Ham4Parser.g:2397:9: ( action2t a2tlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2397:9: ( action2t a2tlist )?
var alt92=2;
alt92 = this.dfa92.predict(this.input);
switch (alt92) {
case 1 :
// Ham4Parser.g:2398:13: action2t a2tlist
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_a2tlist8672);
action2t246=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action2t246.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a2tlist_in_a2tlist8686);
a2tlist247=this.a2tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, a2tlist247.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a2tlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a1tlist_return: (function() {
Ham4Parser.a1tlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.a1tlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2403:1: a1tlist : ( action1t a1tlist )? ;
// $ANTLR start "a1tlist"
a1tlist: function() {
var retval = new Ham4Parser.a1tlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1t248 = null;
var a1tlist249 = null;
this.trace("ANTLR Parse: a1tlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:2421:5: ( ( action1t a1tlist )? )
// Ham4Parser.g:2422:9: ( action1t a1tlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2422:9: ( action1t a1tlist )?
var alt93=2;
alt93 = this.dfa93.predict(this.input);
switch (alt93) {
case 1 :
// Ham4Parser.g:2423:13: action1t a1tlist
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_a1tlist8746);
action1t248=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1t248.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tlist_in_a1tlist8760);
a1tlist249=this.a1tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, a1tlist249.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a1tlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action2t_return: (function() {
Ham4Parser.action2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.action2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2428:1: action2t : ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) ) ;
// $ANTLR start "action2t"
action2t: function() {
var retval = new Ham4Parser.action2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1250 = null;
var location2not1251 = null;
var repetitionsoption252 = null;
var action1t253 = null;
var splitaction2loc2254 = null;
var splitaction2t255 = null;
var paraction2t256 = null;
var seqaction2t257 = null;
var seqfusedaction2t258 = null;
var repetitionsoption259 = null;
var stream_seqfusedaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction2t");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
var stream_seqaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqaction2t");
var stream_location2not1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2not1");
var stream_repetitionsoption=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetitionsoption");
var stream_splitaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitaction2t");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
var stream_paraction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction2t");
var stream_splitaction2loc2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitaction2loc2");
this.trace("ANTLR Parse: action2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2474:5: ( ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) ) )
// Ham4Parser.g:2475:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )
// Ham4Parser.g:2475:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )
var alt95=3;
alt95 = this.dfa95.predict(this.input);
switch (alt95) {
case 1 :
// Ham4Parser.g:2476:9: ( action1 location2not1 )=> action1 location2not1 repetitionsoption
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action2t8838);
action1250=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1250.getTree());
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_action2t8848);
location2not1251=this.location2not1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2not1.add(location2not1251.getTree());
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action2t8858);
repetitionsoption252=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption252.getTree());
// AST REWRITE
// elements: action1, repetitionsoption, location2not1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2481:6: -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? )
{
// Ham4Parser.g:2481:9: ^( ACTION2T action1 location2not1 ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
this.adaptor.addChild(root_1, stream_action1.nextTree());
this.adaptor.addChild(root_1, stream_location2not1.nextTree());
// Ham4Parser.g:2481:42: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2483:9: ( action1t )=> action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_action2t8916);
action1t253=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t253.getTree());
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2486:6: -> ^( ACTION2T action1t )
{
// Ham4Parser.g:2486:9: ^( ACTION2T action1t )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
this.adaptor.addChild(root_1, stream_action1t.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2488:9: ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption
// Ham4Parser.g:2488:9: ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t )
var alt94=5;
switch ( this.input.LA(1) ) {
case HamParbegin:
var LA94_1 = this.input.LA(2);
if ( (this.synpred29_Ham4Parser()) ) {
alt94=1;
}
else if ( (this.synpred30_Ham4Parser()) ) {
alt94=2;
}
else if ( (true) ) {
alt94=3;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 1, this.input);
throw nvae;
}
break;
case HamSeqbegin:
alt94=4;
break;
case HamFusionbegin:
alt94=5;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 0, this.input);
throw nvae;
}
switch (alt94) {
case 1 :
// Ham4Parser.g:2489:13: ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2
this.pushFollow(Ham4Parser.FOLLOW_splitaction2loc2_in_action2t9025);
splitaction2loc2254=this.splitaction2loc2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitaction2loc2.add(splitaction2loc2254.getTree());
break;
case 2 :
// Ham4Parser.g:2494:13: ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t
this.pushFollow(Ham4Parser.FOLLOW_splitaction2t_in_action2t9090);
splitaction2t255=this.splitaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitaction2t.add(splitaction2t255.getTree());
break;
case 3 :
// Ham4Parser.g:2498:13: paraction2t
this.pushFollow(Ham4Parser.FOLLOW_paraction2t_in_action2t9114);
paraction2t256=this.paraction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction2t.add(paraction2t256.getTree());
break;
case 4 :
// Ham4Parser.g:2500:13: seqaction2t
this.pushFollow(Ham4Parser.FOLLOW_seqaction2t_in_action2t9138);
seqaction2t257=this.seqaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqaction2t.add(seqaction2t257.getTree());
break;
case 5 :
// Ham4Parser.g:2502:13: seqfusedaction2t
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction2t_in_action2t9162);
seqfusedaction2t258=this.seqfusedaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction2t.add(seqfusedaction2t258.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action2t9182);
repetitionsoption259=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption259.getTree());
// AST REWRITE
// elements: paraction2t, seqaction2t, splitaction2loc2, seqfusedaction2t, repetitionsoption, splitaction2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2505:6: -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? )
{
// Ham4Parser.g:2505:9: ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
// Ham4Parser.g:2505:20: ( splitaction2loc2 )?
if ( stream_splitaction2loc2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitaction2loc2.nextTree());
}
stream_splitaction2loc2.reset();
// Ham4Parser.g:2505:38: ( splitaction2t )?
if ( stream_splitaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitaction2t.nextTree());
}
stream_splitaction2t.reset();
// Ham4Parser.g:2505:53: ( paraction2t )?
if ( stream_paraction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_paraction2t.nextTree());
}
stream_paraction2t.reset();
// Ham4Parser.g:2505:66: ( seqaction2t )?
if ( stream_seqaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqaction2t.nextTree());
}
stream_seqaction2t.reset();
// Ham4Parser.g:2505:79: ( seqfusedaction2t )?
if ( stream_seqfusedaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqfusedaction2t.nextTree());
}
stream_seqfusedaction2t.reset();
// Ham4Parser.g:2505:97: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1t_return: (function() {
Ham4Parser.action1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2509:1: action1t : ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? ) ;
// $ANTLR start "action1t"
action1t: function() {
var retval = new Ham4Parser.action1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamLargemod263 = null;
var action1260 = null;
var handconstellation261 = null;
var location1262 = null;
var paraction1t264 = null;
var seqnmoraction1t265 = null;
var seqfusedaction1t266 = null;
var repetitionsoption267 = null;
var HamLargemod263_tree=null;
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_seqfusedaction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction1t");
var stream_repetitionsoption=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetitionsoption");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
var stream_seqnmoraction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqnmoraction1t");
var stream_handconstellation=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconstellation");
var stream_paraction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction1t");
this.trace("ANTLR Parse: action1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2552:5: ( ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? ) )
// Ham4Parser.g:2553:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption
// Ham4Parser.g:2553:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t )
var alt98=4;
alt98 = this.dfa98.predict(this.input);
switch (alt98) {
case 1 :
// Ham4Parser.g:2554:13: ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? )
// Ham4Parser.g:2556:13: ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? )
// Ham4Parser.g:2557:17: action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action1t9316);
action1260=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1260.getTree());
// Ham4Parser.g:2558:17: ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?
var alt97=3;
alt97 = this.dfa97.predict(this.input);
switch (alt97) {
case 1 :
// Ham4Parser.g:2559:21: ( handconstellation )=> handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_action1t9404);
handconstellation261=this.handconstellation();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconstellation.add(handconstellation261.getTree());
break;
case 2 :
// Ham4Parser.g:2563:21: location1 ( HamLargemod )?
this.pushFollow(Ham4Parser.FOLLOW_location1_in_action1t9444);
location1262=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1262.getTree());
// Ham4Parser.g:2564:21: ( HamLargemod )?
var alt96=2;
alt96 = this.dfa96.predict(this.input);
switch (alt96) {
case 1 :
// Ham4Parser.g:2564:23: HamLargemod
HamLargemod263=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_action1t9468); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod263);
break;
}
break;
}
break;
case 2 :
// Ham4Parser.g:2568:13: paraction1t
this.pushFollow(Ham4Parser.FOLLOW_paraction1t_in_action1t9528);
paraction1t264=this.paraction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction1t.add(paraction1t264.getTree());
break;
case 3 :
// Ham4Parser.g:2570:13: seqnmoraction1t
this.pushFollow(Ham4Parser.FOLLOW_seqnmoraction1t_in_action1t9552);
seqnmoraction1t265=this.seqnmoraction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqnmoraction1t.add(seqnmoraction1t265.getTree());
break;
case 4 :
// Ham4Parser.g:2572:13: seqfusedaction1t
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction1t_in_action1t9577);
seqfusedaction1t266=this.seqfusedaction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction1t.add(seqfusedaction1t266.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action1t9597);
repetitionsoption267=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption267.getTree());
// AST REWRITE
// elements: location1, paraction1t, seqfusedaction1t, handconstellation, HamLargemod, action1, seqnmoraction1t, repetitionsoption
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2576:6: -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? )
{
// Ham4Parser.g:2576:9: ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1T, "ACTION1T"), root_1);
// Ham4Parser.g:2577:9: ( action1 )?
if ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
// Ham4Parser.g:2577:18: ( handconstellation )?
if ( stream_handconstellation.hasNext() ) {
this.adaptor.addChild(root_1, stream_handconstellation.nextTree());
}
stream_handconstellation.reset();
// Ham4Parser.g:2577:37: ( location1 )?
if ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
// Ham4Parser.g:2577:48: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
// Ham4Parser.g:2578:9: ( paraction1t )?
if ( stream_paraction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_paraction1t.nextTree());
}
stream_paraction1t.reset();
// Ham4Parser.g:2579:21: ( seqnmoraction1t )?
if ( stream_seqnmoraction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqnmoraction1t.nextTree());
}
stream_seqnmoraction1t.reset();
// Ham4Parser.g:2580:9: ( seqfusedaction1t )?
if ( stream_seqfusedaction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqfusedaction1t.nextTree());
}
stream_seqfusedaction1t.reset();
// Ham4Parser.g:2581:8: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1_return: (function() {
Ham4Parser.action1_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2584:1: action1 : ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) ) ;
// $ANTLR start "action1"
action1: function() {
var retval = new Ham4Parser.action1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNomotion268 = null;
var HamLargemod271 = null;
var simplemovement269 = null;
var modifier270 = null;
var specialfingerplaymovement272 = null;
var paraction1273 = null;
var seqaction1274 = null;
var seqfusedaction1275 = null;
var HamNomotion268_tree=null;
var HamLargemod271_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_specialfingerplaymovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule specialfingerplaymovement");
var stream_modifier=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule modifier");
var stream_seqaction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqaction1");
var stream_simplemovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule simplemovement");
var stream_paraction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction1");
var stream_seqfusedaction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction1");
this.trace("ANTLR Parse: action1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2623:5: ( ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) ) )
// Ham4Parser.g:2624:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )
// Ham4Parser.g:2624:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )
var alt102=6;
alt102 = this.dfa102.predict(this.input);
switch (alt102) {
case 1 :
// Ham4Parser.g:2625:9: HamNomotion
HamNomotion268=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_action19733); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion268);
// AST REWRITE
// elements: HamNomotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2626:6: -> ^( ACTION1 HamNomotion )
{
// Ham4Parser.g:2626:9: ^( ACTION1 HamNomotion )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2628:9: simplemovement ( ( modifier )+ ( HamLargemod )? )?
this.pushFollow(Ham4Parser.FOLLOW_simplemovement_in_action19762);
simplemovement269=this.simplemovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_simplemovement.add(simplemovement269.getTree());
// Ham4Parser.g:2629:9: ( ( modifier )+ ( HamLargemod )? )?
var alt101=2;
var LA101_0 = this.input.LA(1);
if ( ((LA101_0>=HamFast && LA101_0<=HamHalt)) ) {
alt101=1;
}
switch (alt101) {
case 1 :
// Ham4Parser.g:2630:13: ( modifier )+ ( HamLargemod )?
// Ham4Parser.g:2630:13: ( modifier )+
var cnt99=0;
loop99:
do {
var alt99=2;
var LA99_0 = this.input.LA(1);
if ( ((LA99_0>=HamFast && LA99_0<=HamHalt)) ) {
alt99=1;
}
switch (alt99) {
case 1 :
// Ham4Parser.g:2630:15: modifier
this.pushFollow(Ham4Parser.FOLLOW_modifier_in_action19788);
modifier270=this.modifier();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_modifier.add(modifier270.getTree());
break;
default :
if ( cnt99 >= 1 ) {
break loop99;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(99, this.input);
throw eee;
}
cnt99++;
} while (true);
// Ham4Parser.g:2631:13: ( HamLargemod )?
var alt100=2;
var LA100_0 = this.input.LA(1);
if ( (LA100_0==HamLargemod) ) {
alt100=1;
}
switch (alt100) {
case 1 :
// Ham4Parser.g:2631:15: HamLargemod
HamLargemod271=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_action19807); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod271);
break;
}
break;
}
// AST REWRITE
// elements: simplemovement, modifier, HamLargemod
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2633:6: -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? )
{
// Ham4Parser.g:2633:9: ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_simplemovement.nextTree());
// Ham4Parser.g:2633:34: ( modifier )*
while ( stream_modifier.hasNext() ) {
this.adaptor.addChild(root_1, stream_modifier.nextTree());
}
stream_modifier.reset();
// Ham4Parser.g:2633:44: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2635:9: ( HamSeqbegin digit )=> specialfingerplaymovement
this.pushFollow(Ham4Parser.FOLLOW_specialfingerplaymovement_in_action19882);
specialfingerplaymovement272=this.specialfingerplaymovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_specialfingerplaymovement.add(specialfingerplaymovement272.getTree());
// AST REWRITE
// elements: specialfingerplaymovement
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2638:6: -> ^( ACTION1 specialfingerplaymovement )
{
// Ham4Parser.g:2638:9: ^( ACTION1 specialfingerplaymovement )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_specialfingerplaymovement.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:2640:9: paraction1
this.pushFollow(Ham4Parser.FOLLOW_paraction1_in_action19911);
paraction1273=this.paraction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction1.add(paraction1273.getTree());
// AST REWRITE
// elements: paraction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2641:6: -> ^( ACTION1 paraction1 )
{
// Ham4Parser.g:2641:9: ^( ACTION1 paraction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_paraction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 5 :
// Ham4Parser.g:2643:9: seqaction1
this.pushFollow(Ham4Parser.FOLLOW_seqaction1_in_action19940);
seqaction1274=this.seqaction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqaction1.add(seqaction1274.getTree());
// AST REWRITE
// elements: seqaction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2644:6: -> ^( ACTION1 seqaction1 )
{
// Ham4Parser.g:2644:9: ^( ACTION1 seqaction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_seqaction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 6 :
// Ham4Parser.g:2646:9: seqfusedaction1
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction1_in_action19969);
seqfusedaction1275=this.seqfusedaction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction1.add(seqfusedaction1275.getTree());
// AST REWRITE
// elements: seqfusedaction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2647:6: -> ^( ACTION1 seqfusedaction1 )
{
// Ham4Parser.g:2647:9: ^( ACTION1 seqfusedaction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_seqfusedaction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1seq_return: (function() {
Ham4Parser.action1seq_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1seq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2654:1: action1seq : ( action1 )+ ;
// $ANTLR start "action1seq"
action1seq: function() {
var retval = new Ham4Parser.action1seq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1276 = null;
try {
// Ham4Parser.g:2655:2: ( ( action1 )+ )
// Ham4Parser.g:2655:4: ( action1 )+
root_0 = this.adaptor.nil();
// Ham4Parser.g:2655:4: ( action1 )+
var cnt103=0;
loop103:
do {
var alt103=2;
alt103 = this.dfa103.predict(this.input);
switch (alt103) {
case 1 :
// Ham4Parser.g:2655:4: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action1seq10005);
action1276=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1276.getTree());
break;
default :
if ( cnt103 >= 1 ) {
break loop103;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(103, this.input);
throw eee;
}
cnt103++;
} while (true);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1tseq_return: (function() {
Ham4Parser.action1tseq_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1tseq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2658:1: action1tseq : ( action1t )+ ;
// $ANTLR start "action1tseq"
action1tseq: function() {
var retval = new Ham4Parser.action1tseq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1t277 = null;
try {
// Ham4Parser.g:2659:2: ( ( action1t )+ )
// Ham4Parser.g:2659:4: ( action1t )+
root_0 = this.adaptor.nil();
// Ham4Parser.g:2659:4: ( action1t )+
var cnt104=0;
loop104:
do {
var alt104=2;
alt104 = this.dfa104.predict(this.input);
switch (alt104) {
case 1 :
// Ham4Parser.g:2659:4: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_action1tseq10017);
action1t277=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1t277.getTree());
break;
default :
if ( cnt104 >= 1 ) {
break loop104;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(104, this.input);
throw eee;
}
cnt104++;
} while (true);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction2t_return: (function() {
Ham4Parser.paraction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2662:1: paraction2t : HamParbegin ( action2t )+ HamParend -> ^( PARACT2T ( action2t )* ) ;
// $ANTLR start "paraction2t"
paraction2t: function() {
var retval = new Ham4Parser.paraction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin278 = null;
var HamParend280 = null;
var action2t279 = null;
var HamParbegin278_tree=null;
var HamParend280_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: paraction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2680:5: ( HamParbegin ( action2t )+ HamParend -> ^( PARACT2T ( action2t )* ) )
// Ham4Parser.g:2680:9: HamParbegin ( action2t )+ HamParend
HamParbegin278=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction2t10044); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin278);
// Ham4Parser.g:2681:9: ( action2t )+
var cnt105=0;
loop105:
do {
var alt105=2;
alt105 = this.dfa105.predict(this.input);
switch (alt105) {
case 1 :
// Ham4Parser.g:2681:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_paraction2t10057);
action2t279=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t279.getTree());
break;
default :
if ( cnt105 >= 1 ) {
break loop105;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(105, this.input);
throw eee;
}
cnt105++;
} while (true);
HamParend280=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction2t10070); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend280);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2684:6: -> ^( PARACT2T ( action2t )* )
{
// Ham4Parser.g:2684:9: ^( PARACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT2T, "PARACT2T"), root_1);
// Ham4Parser.g:2684:20: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqaction2t_return: (function() {
Ham4Parser.seqaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2687:1: seqaction2t : HamSeqbegin ( action2t )+ HamSeqend -> ^( SEQACT2T ( action2t )* ) ;
// $ANTLR start "seqaction2t"
seqaction2t: function() {
var retval = new Ham4Parser.seqaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin281 = null;
var HamSeqend283 = null;
var action2t282 = null;
var HamSeqbegin281_tree=null;
var HamSeqend283_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: seqaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2705:5: ( HamSeqbegin ( action2t )+ HamSeqend -> ^( SEQACT2T ( action2t )* ) )
// Ham4Parser.g:2705:9: HamSeqbegin ( action2t )+ HamSeqend
HamSeqbegin281=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqaction2t10123); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin281);
// Ham4Parser.g:2706:9: ( action2t )+
var cnt106=0;
loop106:
do {
var alt106=2;
alt106 = this.dfa106.predict(this.input);
switch (alt106) {
case 1 :
// Ham4Parser.g:2706:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_seqaction2t10136);
action2t282=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t282.getTree());
break;
default :
if ( cnt106 >= 1 ) {
break loop106;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(106, this.input);
throw eee;
}
cnt106++;
} while (true);
HamSeqend283=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqaction2t10149); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend283);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2709:6: -> ^( SEQACT2T ( action2t )* )
{
// Ham4Parser.g:2709:9: ^( SEQACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT2T, "SEQACT2T"), root_1);
// Ham4Parser.g:2709:20: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction2t_return: (function() {
Ham4Parser.seqfusedaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2712:1: seqfusedaction2t : HamFusionbegin ( action2t )+ HamFusionend -> ^( SEQFUSEDACT2T ( action2t )* ) ;
// $ANTLR start "seqfusedaction2t"
seqfusedaction2t: function() {
var retval = new Ham4Parser.seqfusedaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin284 = null;
var HamFusionend286 = null;
var action2t285 = null;
var HamFusionbegin284_tree=null;
var HamFusionend286_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: seqfusedaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2730:5: ( HamFusionbegin ( action2t )+ HamFusionend -> ^( SEQFUSEDACT2T ( action2t )* ) )
// Ham4Parser.g:2730:9: HamFusionbegin ( action2t )+ HamFusionend
HamFusionbegin284=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction2t10202); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin284);
// Ham4Parser.g:2731:9: ( action2t )+
var cnt107=0;
loop107:
do {
var alt107=2;
alt107 = this.dfa107.predict(this.input);
switch (alt107) {
case 1 :
// Ham4Parser.g:2731:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_seqfusedaction2t10215);
action2t285=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t285.getTree());
break;
default :
if ( cnt107 >= 1 ) {
break loop107;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(107, this.input);
throw eee;
}
cnt107++;
} while (true);
HamFusionend286=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction2t10228); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend286);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2734:6: -> ^( SEQFUSEDACT2T ( action2t )* )
{
// Ham4Parser.g:2734:9: ^( SEQFUSEDACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT2T, "SEQFUSEDACT2T"), root_1);
// Ham4Parser.g:2734:25: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitaction2loc2_return: (function() {
Ham4Parser.splitaction2loc2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitaction2loc2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2737:1: splitaction2loc2 : HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2 -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 ) ;
// $ANTLR start "splitaction2loc2"
splitaction2loc2: function() {
var retval = new Ham4Parser.splitaction2loc2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin287 = null;
var HamPlus288 = null;
var HamParend289 = null;
var acta = null;
var actb = null;
var location2290 = null;
var HamParbegin287_tree=null;
var HamPlus288_tree=null;
var HamParend289_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1seq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1seq");
var stream_location2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2");
this.trace("ANTLR Parse: splitaction2loc2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2758:5: ( HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2 -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 ) )
// Ham4Parser.g:2758:9: HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2
HamParbegin287=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitaction2loc210281); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin287);
this.pushFollow(Ham4Parser.FOLLOW_action1seq_in_splitaction2loc210294);
acta=this.action1seq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1seq.add(acta.getTree());
HamPlus288=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitaction2loc210304); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus288);
this.pushFollow(Ham4Parser.FOLLOW_action1seq_in_splitaction2loc210316);
actb=this.action1seq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1seq.add(actb.getTree());
HamParend289=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitaction2loc210326); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend289);
this.pushFollow(Ham4Parser.FOLLOW_location2_in_splitaction2loc210337);
location2290=this.location2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2.add(location2290.getTree());
// AST REWRITE
// elements: actb, location2, acta, HamPlus
// token labels: 
// rule labels: acta, actb, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_acta=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token acta",acta!=null?acta.tree:null);
var stream_actb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token actb",actb!=null?actb.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2765:6: -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 )
{
// Ham4Parser.g:2765:9: ^( SPLITACT2LOC2 $acta HamPlus $actb location2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITACT2LOC2, "SPLITACT2LOC2"), root_1);
this.adaptor.addChild(root_1, stream_acta.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_actb.nextTree());
this.adaptor.addChild(root_1, stream_location2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitaction2loc2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitaction2t_return: (function() {
Ham4Parser.splitaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2768:1: splitaction2t : HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend -> ^( SPLITACT2T $acta HamPlus $actb) ;
// $ANTLR start "splitaction2t"
splitaction2t: function() {
var retval = new Ham4Parser.splitaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin291 = null;
var HamPlus292 = null;
var HamParend293 = null;
var acta = null;
var actb = null;
var HamParbegin291_tree=null;
var HamPlus292_tree=null;
var HamParend293_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1tseq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1tseq");
this.trace("ANTLR Parse: splitaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2788:5: ( HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend -> ^( SPLITACT2T $acta HamPlus $actb) )
// Ham4Parser.g:2788:9: HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend
HamParbegin291=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitaction2t10396); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin291);
this.pushFollow(Ham4Parser.FOLLOW_action1tseq_in_splitaction2t10409);
acta=this.action1tseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1tseq.add(acta.getTree());
HamPlus292=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitaction2t10419); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus292);
this.pushFollow(Ham4Parser.FOLLOW_action1tseq_in_splitaction2t10431);
actb=this.action1tseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1tseq.add(actb.getTree());
HamParend293=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitaction2t10441); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend293);
// AST REWRITE
// elements: acta, actb, HamPlus
// token labels: 
// rule labels: acta, actb, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_acta=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token acta",acta!=null?acta.tree:null);
var stream_actb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token actb",actb!=null?actb.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2794:6: -> ^( SPLITACT2T $acta HamPlus $actb)
{
// Ham4Parser.g:2794:9: ^( SPLITACT2T $acta HamPlus $actb)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITACT2T, "SPLITACT2T"), root_1);
this.adaptor.addChild(root_1, stream_acta.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_actb.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction1t_return: (function() {
Ham4Parser.paraction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2797:1: paraction1t : HamParbegin ( action1t )+ HamParend -> ^( PARACT1T ( action1t )* ) ;
// $ANTLR start "paraction1t"
paraction1t: function() {
var retval = new Ham4Parser.paraction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin294 = null;
var HamParend296 = null;
var action1t295 = null;
var HamParbegin294_tree=null;
var HamParend296_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
this.trace("ANTLR Parse: paraction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2816:5: ( HamParbegin ( action1t )+ HamParend -> ^( PARACT1T ( action1t )* ) )
// Ham4Parser.g:2817:9: HamParbegin ( action1t )+ HamParend
HamParbegin294=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction1t10505); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin294);
// Ham4Parser.g:2818:9: ( action1t )+
var cnt108=0;
loop108:
do {
var alt108=2;
alt108 = this.dfa108.predict(this.input);
switch (alt108) {
case 1 :
// Ham4Parser.g:2818:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_paraction1t10518);
action1t295=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t295.getTree());
break;
default :
if ( cnt108 >= 1 ) {
break loop108;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(108, this.input);
throw eee;
}
cnt108++;
} while (true);
HamParend296=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction1t10531); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend296);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2821:6: -> ^( PARACT1T ( action1t )* )
{
// Ham4Parser.g:2821:9: ^( PARACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT1T, "PARACT1T"), root_1);
// Ham4Parser.g:2821:20: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqnmoraction1t_return: (function() {
Ham4Parser.seqnmoraction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqnmoraction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2824:1: seqnmoraction1t : HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend ;
// $ANTLR start "seqnmoraction1t"
seqnmoraction1t: function() {
var retval = new Ham4Parser.seqnmoraction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin297 = null;
var HamSeqend302 = null;
var levelbody298 = null;
var levelarm299 = null;
var action1t300 = null;
var action1t301 = null;
var HamSeqbegin297_tree=null;
var HamSeqend302_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
var stream_levelbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelbody");
var stream_levelarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelarm");
this.trace("ANTLR Parse: seqnmoraction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2853:5: ( HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend )
// Ham4Parser.g:2854:9: HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend
HamSeqbegin297=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqnmoraction1t10590); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin297);
// Ham4Parser.g:2855:9: ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) )
var alt111=2;
alt111 = this.dfa111.predict(this.input);
switch (alt111) {
case 1 :
// Ham4Parser.g:2856:4: ( ( levelbody )=> levelbody | levelarm ) action1t
// Ham4Parser.g:2856:4: ( ( levelbody )=> levelbody | levelarm )
var alt109=2;
alt109 = this.dfa109.predict(this.input);
switch (alt109) {
case 1 :
// Ham4Parser.g:2857:6: ( levelbody )=> levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_seqnmoraction1t10621);
levelbody298=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelbody.add(levelbody298.getTree());
break;
case 2 :
// Ham4Parser.g:2859:6: levelarm
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_seqnmoraction1t10633);
levelarm299=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelarm.add(levelarm299.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqnmoraction1t10643);
action1t300=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t300.getTree());
// AST REWRITE
// elements: levelarm, levelbody, action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2862:6: -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t )
{
// Ham4Parser.g:2862:9: ^( NMACT1T ( levelbody )* ( levelarm )* action1t )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMACT1T, "NMACT1T"), root_1);
// Ham4Parser.g:2862:19: ( levelbody )*
while ( stream_levelbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelbody.nextTree());
}
stream_levelbody.reset();
// Ham4Parser.g:2862:30: ( levelarm )*
while ( stream_levelarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelarm.nextTree());
}
stream_levelarm.reset();
this.adaptor.addChild(root_1, stream_action1t.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2864:10: ( action1t )+
// Ham4Parser.g:2864:10: ( action1t )+
var cnt110=0;
loop110:
do {
var alt110=2;
alt110 = this.dfa110.predict(this.input);
switch (alt110) {
case 1 :
// Ham4Parser.g:2864:12: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqnmoraction1t10679);
action1t301=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t301.getTree());
break;
default :
if ( cnt110 >= 1 ) {
break loop110;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(110, this.input);
throw eee;
}
cnt110++;
} while (true);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2865:6: -> ^( SEQACT1T ( action1t )* )
{
// Ham4Parser.g:2865:9: ^( SEQACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT1T, "SEQACT1T"), root_1);
// Ham4Parser.g:2865:20: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
HamSeqend302=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqnmoraction1t10716); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend302);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqnmoraction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction1t_return: (function() {
Ham4Parser.seqfusedaction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2871:1: seqfusedaction1t : HamFusionbegin ( action1t )+ HamFusionend -> ^( SEQFUSEDACT1T ( action1t )* ) ;
// $ANTLR start "seqfusedaction1t"
seqfusedaction1t: function() {
var retval = new Ham4Parser.seqfusedaction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin303 = null;
var HamFusionend305 = null;
var action1t304 = null;
var HamFusionbegin303_tree=null;
var HamFusionend305_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
this.trace("ANTLR Parse: seqfusedaction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2890:5: ( HamFusionbegin ( action1t )+ HamFusionend -> ^( SEQFUSEDACT1T ( action1t )* ) )
// Ham4Parser.g:2891:9: HamFusionbegin ( action1t )+ HamFusionend
HamFusionbegin303=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction1t10761); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin303);
// Ham4Parser.g:2892:9: ( action1t )+
var cnt112=0;
loop112:
do {
var alt112=2;
alt112 = this.dfa112.predict(this.input);
switch (alt112) {
case 1 :
// Ham4Parser.g:2892:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqfusedaction1t10774);
action1t304=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t304.getTree());
break;
default :
if ( cnt112 >= 1 ) {
break loop112;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(112, this.input);
throw eee;
}
cnt112++;
} while (true);
HamFusionend305=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction1t10787); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend305);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2895:5: -> ^( SEQFUSEDACT1T ( action1t )* )
{
// Ham4Parser.g:2895:8: ^( SEQFUSEDACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT1T, "SEQFUSEDACT1T"), root_1);
// Ham4Parser.g:2895:24: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction1_return: (function() {
Ham4Parser.paraction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2898:1: paraction1 : HamParbegin ( action1 )+ HamParend -> ^( PARACT1 ( action1 )* ) ;
// $ANTLR start "paraction1"
paraction1: function() {
var retval = new Ham4Parser.paraction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin306 = null;
var HamParend308 = null;
var action1307 = null;
var HamParbegin306_tree=null;
var HamParend308_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: paraction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2917:5: ( HamParbegin ( action1 )+ HamParend -> ^( PARACT1 ( action1 )* ) )
// Ham4Parser.g:2918:9: HamParbegin ( action1 )+ HamParend
HamParbegin306=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction110845); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin306);
// Ham4Parser.g:2919:9: ( action1 )+
var cnt113=0;
loop113:
do {
var alt113=2;
alt113 = this.dfa113.predict(this.input);
switch (alt113) {
case 1 :
// Ham4Parser.g:2919:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_paraction110858);
action1307=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1307.getTree());
break;
default :
if ( cnt113 >= 1 ) {
break loop113;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(113, this.input);
throw eee;
}
cnt113++;
} while (true);
HamParend308=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction110871); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend308);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2922:5: -> ^( PARACT1 ( action1 )* )
{
// Ham4Parser.g:2922:8: ^( PARACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT1, "PARACT1"), root_1);
// Ham4Parser.g:2922:18: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqaction1_return: (function() {
Ham4Parser.seqaction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqaction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2925:1: seqaction1 : HamSeqbegin ( action1 )+ HamSeqend -> ^( SEQACT1 ( action1 )* ) ;
// $ANTLR start "seqaction1"
seqaction1: function() {
var retval = new Ham4Parser.seqaction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin309 = null;
var HamSeqend311 = null;
var action1310 = null;
var HamSeqbegin309_tree=null;
var HamSeqend311_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: seqaction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2944:5: ( HamSeqbegin ( action1 )+ HamSeqend -> ^( SEQACT1 ( action1 )* ) )
// Ham4Parser.g:2945:9: HamSeqbegin ( action1 )+ HamSeqend
HamSeqbegin309=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqaction110929); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin309);
// Ham4Parser.g:2946:9: ( action1 )+
var cnt114=0;
loop114:
do {
var alt114=2;
alt114 = this.dfa114.predict(this.input);
switch (alt114) {
case 1 :
// Ham4Parser.g:2946:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_seqaction110942);
action1310=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1310.getTree());
break;
default :
if ( cnt114 >= 1 ) {
break loop114;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(114, this.input);
throw eee;
}
cnt114++;
} while (true);
HamSeqend311=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqaction110955); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend311);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2949:5: -> ^( SEQACT1 ( action1 )* )
{
// Ham4Parser.g:2949:8: ^( SEQACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT1, "SEQACT1"), root_1);
// Ham4Parser.g:2949:18: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqaction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction1_return: (function() {
Ham4Parser.seqfusedaction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2952:1: seqfusedaction1 : HamFusionbegin ( action1 )+ HamFusionend -> ^( SEQFUSEDACT1 ( action1 )* ) ;
// $ANTLR start "seqfusedaction1"
seqfusedaction1: function() {
var retval = new Ham4Parser.seqfusedaction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin312 = null;
var HamFusionend314 = null;
var action1313 = null;
var HamFusionbegin312_tree=null;
var HamFusionend314_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: seqfusedaction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2971:5: ( HamFusionbegin ( action1 )+ HamFusionend -> ^( SEQFUSEDACT1 ( action1 )* ) )
// Ham4Parser.g:2972:9: HamFusionbegin ( action1 )+ HamFusionend
HamFusionbegin312=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction111013); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin312);
// Ham4Parser.g:2973:9: ( action1 )+
var cnt115=0;
loop115:
do {
var alt115=2;
alt115 = this.dfa115.predict(this.input);
switch (alt115) {
case 1 :
// Ham4Parser.g:2973:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_seqfusedaction111026);
action1313=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1313.getTree());
break;
default :
if ( cnt115 >= 1 ) {
break loop115;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(115, this.input);
throw eee;
}
cnt115++;
} while (true);
HamFusionend314=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction111039); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend314);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2976:5: -> ^( SEQFUSEDACT1 ( action1 )* )
{
// Ham4Parser.g:2976:8: ^( SEQFUSEDACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT1, "SEQFUSEDACT1"), root_1);
// Ham4Parser.g:2976:23: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetitionsoption_return: (function() {
Ham4Parser.repetitionsoption_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetitionsoption_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2979:1: repetitionsoption : ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )? ;
// $ANTLR start "repetitionsoption"
repetitionsoption: function() {
var retval = new Ham4Parser.repetitionsoption_return();
retval.start = this.input.LT(1);
var root_0 = null;
var repetitions315 = null;
this.trace("ANTLR Parse: repetitionsoption starts "+this.state.backtracking);
try {
// Ham4Parser.g:2998:5: ( ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )? )
// Ham4Parser.g:2999:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2999:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?
var alt116=2;
alt116 = this.dfa116.predict(this.input);
switch (alt116) {
case 1 :
// Ham4Parser.g:3000:13: ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions
this.pushFollow(Ham4Parser.FOLLOW_repetitions_in_repetitionsoption11154);
repetitions315=this.repetitions();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, repetitions315.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetitionsoption finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetitions_return: (function() {
Ham4Parser.repetitions_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetitions_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3006:1: repetitions : ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) ) ;
// $ANTLR start "repetitions"
repetitions: function() {
var retval = new Ham4Parser.repetitions_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin316 = null;
var HamRepeatfromstartseveral317 = null;
var HamEtc318 = null;
var HamSeqend320 = null;
var HamEtc322 = null;
var HamAlternatingmotion326 = null;
var HamAlternatingmotion327 = null;
var HamAlternatingmotion328 = null;
var HamAlternatingmotion329 = null;
var ellipsedirection319 = null;
var repetition321 = null;
var repetition323 = null;
var movingrepetition324 = null;
var sizechangenonlinear325 = null;
var HamSeqbegin316_tree=null;
var HamRepeatfromstartseveral317_tree=null;
var HamEtc318_tree=null;
var HamSeqend320_tree=null;
var HamEtc322_tree=null;
var HamAlternatingmotion326_tree=null;
var HamAlternatingmotion327_tree=null;
var HamAlternatingmotion328_tree=null;
var HamAlternatingmotion329_tree=null;
var stream_HamAlternatingmotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamAlternatingmotion");
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_HamRepeatfromstartseveral=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamRepeatfromstartseveral");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_movingrepetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movingrepetition");
var stream_ellipsedirection=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ellipsedirection");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_repetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetition");
this.trace("ANTLR Parse: repetitions starts "+this.state.backtracking);
try {
// Ham4Parser.g:3051:5: ( ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) ) )
// Ham4Parser.g:3052:5: ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) )
// Ham4Parser.g:3052:5: ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) )
var alt123=3;
switch ( this.input.LA(1) ) {
case HamSeqbegin:
var LA123_1 = this.input.LA(2);
if ( (this.synpred36_Ham4Parser()) ) {
alt123=1;
}
else if ( (true) ) {
alt123=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 123, 1, this.input);
throw nvae;
}
break;
case HamRepeatfromstart:
case HamRepeatfromstartseveral:
case HamRepeatcontinue:
case HamRepeatcontinueseveral:
case HamRepeatreverse:
alt123=2;
break;
case HamAlternatingmotion:
alt123=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 123, 0, this.input);
throw nvae;
}
switch (alt123) {
case 1 :
// Ham4Parser.g:3053:9: ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend
HamSeqbegin316=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_repetitions11234); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin316);
HamRepeatfromstartseveral317=this.match(this.input,HamRepeatfromstartseveral,Ham4Parser.FOLLOW_HamRepeatfromstartseveral_in_repetitions11245); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamRepeatfromstartseveral.add(HamRepeatfromstartseveral317);
HamEtc318=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_repetitions11255); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc318);
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_repetitions11265);
ellipsedirection319=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ellipsedirection.add(ellipsedirection319.getTree());
HamSeqend320=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_repetitions11275); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend320);
// AST REWRITE
// elements: HamEtc, ellipsedirection, HamRepeatfromstartseveral
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3060:5: -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection )
{
// Ham4Parser.g:3060:8: ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
this.adaptor.addChild(root_1, stream_HamRepeatfromstartseveral.nextNode());
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
this.adaptor.addChild(root_1, stream_ellipsedirection.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:3062:9: ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )?
// Ham4Parser.g:3062:9: ( repetition ( HamEtc | repetition )? | movingrepetition )
var alt118=2;
var LA118_0 = this.input.LA(1);
if ( ((LA118_0>=HamRepeatfromstart && LA118_0<=HamRepeatcontinueseveral)||LA118_0==HamRepeatreverse) ) {
alt118=1;
}
else if ( (LA118_0==HamSeqbegin) ) {
alt118=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 118, 0, this.input);
throw nvae;
}
switch (alt118) {
case 1 :
// Ham4Parser.g:3063:13: repetition ( HamEtc | repetition )?
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_repetitions11322);
repetition321=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition321.getTree());
// Ham4Parser.g:3064:13: ( HamEtc | repetition )?
var alt117=3;
var LA117_0 = this.input.LA(1);
if ( (LA117_0==HamEtc) ) {
alt117=1;
}
else if ( ((LA117_0>=HamRepeatfromstart && LA117_0<=HamRepeatcontinueseveral)||LA117_0==HamRepeatreverse) ) {
alt117=2;
}
switch (alt117) {
case 1 :
// Ham4Parser.g:3065:17: HamEtc
HamEtc322=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_repetitions11354); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc322);
break;
case 2 :
// Ham4Parser.g:3067:17: repetition
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_repetitions11386);
repetition323=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition323.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3070:13: movingrepetition
this.pushFollow(Ham4Parser.FOLLOW_movingrepetition_in_repetitions11425);
movingrepetition324=this.movingrepetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movingrepetition.add(movingrepetition324.getTree());
break;
}
// Ham4Parser.g:3072:9: ( sizechangenonlinear )?
var alt119=2;
var LA119_0 = this.input.LA(1);
if ( ((LA119_0>=HamIncreasing && LA119_0<=HamDecreasing)) ) {
alt119=1;
}
switch (alt119) {
case 1 :
// Ham4Parser.g:3072:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_repetitions11447);
sizechangenonlinear325=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear325.getTree());
break;
}
// Ham4Parser.g:3073:9: ( HamAlternatingmotion ( HamAlternatingmotion )? )?
var alt121=2;
var LA121_0 = this.input.LA(1);
if ( (LA121_0==HamAlternatingmotion) ) {
alt121=1;
}
switch (alt121) {
case 1 :
// Ham4Parser.g:3074:13: HamAlternatingmotion ( HamAlternatingmotion )?
HamAlternatingmotion326=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11474); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion326);
// Ham4Parser.g:3075:13: ( HamAlternatingmotion )?
var alt120=2;
var LA120_0 = this.input.LA(1);
if ( (LA120_0==HamAlternatingmotion) ) {
alt120=1;
}
switch (alt120) {
case 1 :
// Ham4Parser.g:3075:15: HamAlternatingmotion
HamAlternatingmotion327=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11490); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion327);
break;
}
break;
}
// AST REWRITE
// elements: HamEtc, sizechangenonlinear, HamAlternatingmotion, movingrepetition, repetition
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3077:5: -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* )
{
// Ham4Parser.g:3077:8: ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
// Ham4Parser.g:3077:22: ( repetition )*
while ( stream_repetition.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetition.nextTree());
}
stream_repetition.reset();
// Ham4Parser.g:3077:34: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:3077:42: ( movingrepetition )?
if ( stream_movingrepetition.hasNext() ) {
this.adaptor.addChild(root_1, stream_movingrepetition.nextTree());
}
stream_movingrepetition.reset();
// Ham4Parser.g:3077:60: ( sizechangenonlinear )?
if ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
// Ham4Parser.g:3077:81: ( HamAlternatingmotion )*
while ( stream_HamAlternatingmotion.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamAlternatingmotion.nextNode());
}
stream_HamAlternatingmotion.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:3079:9: HamAlternatingmotion ( HamAlternatingmotion )?
HamAlternatingmotion328=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11545); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion328);
// Ham4Parser.g:3080:9: ( HamAlternatingmotion )?
var alt122=2;
var LA122_0 = this.input.LA(1);
if ( (LA122_0==HamAlternatingmotion) ) {
alt122=1;
}
switch (alt122) {
case 1 :
// Ham4Parser.g:3080:11: HamAlternatingmotion
HamAlternatingmotion329=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11557); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion329);
break;
}
// AST REWRITE
// elements: HamAlternatingmotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3081:5: -> ^( REPETITIONS ( HamAlternatingmotion )* )
{
// Ham4Parser.g:3081:8: ^( REPETITIONS ( HamAlternatingmotion )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
// Ham4Parser.g:3081:22: ( HamAlternatingmotion )*
while ( stream_HamAlternatingmotion.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamAlternatingmotion.nextNode());
}
stream_HamAlternatingmotion.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetitions finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
alternations_return: (function() {
Ham4Parser.alternations_return = function(){};
org.antlr.lang.extend(Ham4Parser.alternations_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3085:1: alternations : HamAlternatingmotion ( HamAlternatingmotion )? ;
// $ANTLR start "alternations"
alternations: function() {
var retval = new Ham4Parser.alternations_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamAlternatingmotion330 = null;
var HamAlternatingmotion331 = null;
var HamAlternatingmotion330_tree=null;
var HamAlternatingmotion331_tree=null;
this.trace("ANTLR Parse: alternations starts "+this.state.backtracking);
try {
// Ham4Parser.g:3100:5: ( HamAlternatingmotion ( HamAlternatingmotion )? )
// Ham4Parser.g:3100:9: HamAlternatingmotion ( HamAlternatingmotion )?
root_0 = this.adaptor.nil();
HamAlternatingmotion330=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_alternations11608); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion330_tree = this.adaptor.create(HamAlternatingmotion330);
this.adaptor.addChild(root_0, HamAlternatingmotion330_tree);
}
// Ham4Parser.g:3101:9: ( HamAlternatingmotion )?
var alt124=2;
var LA124_0 = this.input.LA(1);
if ( (LA124_0==HamAlternatingmotion) ) {
alt124=1;
}
switch (alt124) {
case 1 :
// Ham4Parser.g:3101:11: HamAlternatingmotion
HamAlternatingmotion331=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_alternations11620); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion331_tree = this.adaptor.create(HamAlternatingmotion331);
this.adaptor.addChild(root_0, HamAlternatingmotion331_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: alternations finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movingrepetition_return: (function() {
Ham4Parser.movingrepetition_return = function(){};
org.antlr.lang.extend(Ham4Parser.movingrepetition_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3104:1: movingrepetition : HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* ) ;
// $ANTLR start "movingrepetition"
movingrepetition: function() {
var retval = new Ham4Parser.movingrepetition_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin332 = null;
var HamSeqend337 = null;
var repetition333 = null;
var movementarrow334 = null;
var size335 = null;
var sizechangenonlinear336 = null;
var HamSeqbegin332_tree=null;
var HamSeqend337_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_movementarrow=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementarrow");
var stream_size=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule size");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_repetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetition");
this.trace("ANTLR Parse: movingrepetition starts "+this.state.backtracking);
try {
// Ham4Parser.g:3126:5: ( HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* ) )
// Ham4Parser.g:3127:9: HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend
HamSeqbegin332=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_movingrepetition11658); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin332);
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_movingrepetition11669);
repetition333=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition333.getTree());
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_movingrepetition11679);
movementarrow334=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow334.getTree());
// Ham4Parser.g:3130:9: ( size )?
var alt125=2;
var LA125_0 = this.input.LA(1);
if ( ((LA125_0>=HamSmallmod && LA125_0<=HamLargemod)) ) {
alt125=1;
}
switch (alt125) {
case 1 :
// Ham4Parser.g:3130:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_movingrepetition11691);
size335=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size335.getTree());
break;
}
// Ham4Parser.g:3131:9: ( sizechangenonlinear )?
var alt126=2;
var LA126_0 = this.input.LA(1);
if ( ((LA126_0>=HamIncreasing && LA126_0<=HamDecreasing)) ) {
alt126=1;
}
switch (alt126) {
case 1 :
// Ham4Parser.g:3131:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_movingrepetition11706);
sizechangenonlinear336=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear336.getTree());
break;
}
HamSeqend337=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_movingrepetition11719); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend337);
// AST REWRITE
// elements: size, movementarrow, sizechangenonlinear, repetition
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3134:4: -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* )
{
// Ham4Parser.g:3134:7: ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MOVINGREPETITION, "MOVINGREPETITION"), root_1);
this.adaptor.addChild(root_1, stream_repetition.nextTree());
this.adaptor.addChild(root_1, stream_movementarrow.nextTree());
// Ham4Parser.g:3134:51: ( size )*
while ( stream_size.hasNext() ) {
this.adaptor.addChild(root_1, stream_size.nextTree());
}
stream_size.reset();
// Ham4Parser.g:3134:57: ( sizechangenonlinear )*
while ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movingrepetition finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
simplemovement_return: (function() {
Ham4Parser.simplemovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.simplemovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3140:1: simplemovement : ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )? -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? ) ;
// $ANTLR start "simplemovement"
simplemovement: function() {
var retval = new Ham4Parser.simplemovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFingerplay352 = null;
var straightmovement338 = null;
var size339 = null;
var arckind340 = null;
var zigzag341 = null;
var circularmovement342 = null;
var size343 = null;
var revolutions344 = null;
var ellipse345 = null;
var sizechangenonlinear346 = null;
var movementcross347 = null;
var size348 = null;
var wristmovement349 = null;
var size350 = null;
var replacement351 = null;
var brushingcontact353 = null;
var locationindexdefine354 = null;
var HamFingerplay352_tree=null;
var stream_HamFingerplay=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFingerplay");
var stream_locationindexdefine=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationindexdefine");
var stream_movementcross=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementcross");
var stream_brushingcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule brushingcontact");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_arckind=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule arckind");
var stream_straightmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule straightmovement");
var stream_zigzag=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule zigzag");
var stream_circularmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule circularmovement");
var stream_revolutions=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule revolutions");
var stream_size=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule size");
var stream_ellipse=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ellipse");
var stream_wristmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule wristmovement");
var stream_replacement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule replacement");
this.trace("ANTLR Parse: simplemovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3195:5: ( ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )? -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? ) )
// Ham4Parser.g:3196:9: ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )?
// Ham4Parser.g:3196:9: ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay )
var alt135=6;
switch ( this.input.LA(1) ) {
case HamMoveu:
case HamMoveur:
case HamMover:
case HamMovedr:
case HamMoved:
case HamMovedl:
case HamMovel:
case HamMoveul:
case HamMoveol:
case HamMoveo:
case HamMoveor:
case HamMoveil:
case HamMovei:
case HamMoveir:
case HamMoveui:
case HamMovedi:
case HamMovedo:
case HamMoveuo:
alt135=1;
break;
case HamCircleo:
case HamCirclei:
case HamCircled:
case HamCircleu:
case HamCirclel:
case HamCircler:
case HamCircleul:
case HamCircledr:
case HamCircleur:
case HamCircledl:
case HamCircleol:
case HamCircleir:
case HamCircleor:
case HamCircleil:
case HamCircledo:
case HamCircleui:
case HamCircledi:
case HamCircleuo:
alt135=2;
break;
case HamMovecross:
case HamMovex:
alt135=3;
break;
case HamNodding:
case HamSwinging:
case HamTwisting:
case HamStircw:
case HamStirccw:
alt135=4;
break;
case HamReplace:
alt135=5;
break;
case HamFingerplay:
alt135=6;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);
throw nvae;
}
switch (alt135) {
case 1 :
// Ham4Parser.g:3197:13: straightmovement ( size )? ( arckind | zigzag )?
this.pushFollow(Ham4Parser.FOLLOW_straightmovement_in_simplemovement11800);
straightmovement338=this.straightmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_straightmovement.add(straightmovement338.getTree());
// Ham4Parser.g:3198:13: ( size )?
var alt127=2;
alt127 = this.dfa127.predict(this.input);
switch (alt127) {
case 1 :
// Ham4Parser.g:3198:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement11816);
size339=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size339.getTree());
break;
}
// Ham4Parser.g:3199:13: ( arckind | zigzag )?
var alt128=3;
alt128 = this.dfa128.predict(this.input);
switch (alt128) {
case 1 :
// Ham4Parser.g:3200:17: arckind
this.pushFollow(Ham4Parser.FOLLOW_arckind_in_simplemovement11851);
arckind340=this.arckind();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_arckind.add(arckind340.getTree());
break;
case 2 :
// Ham4Parser.g:3202:17: zigzag
this.pushFollow(Ham4Parser.FOLLOW_zigzag_in_simplemovement11883);
zigzag341=this.zigzag();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_zigzag.add(zigzag341.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3205:13: circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )?
this.pushFollow(Ham4Parser.FOLLOW_circularmovement_in_simplemovement11922);
circularmovement342=this.circularmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_circularmovement.add(circularmovement342.getTree());
// Ham4Parser.g:3206:13: ( size )?
var alt129=2;
alt129 = this.dfa129.predict(this.input);
switch (alt129) {
case 1 :
// Ham4Parser.g:3206:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement11938);
size343=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size343.getTree());
break;
}
// Ham4Parser.g:3207:13: ( revolutions )?
var alt130=2;
alt130 = this.dfa130.predict(this.input);
switch (alt130) {
case 1 :
// Ham4Parser.g:3207:15: revolutions
this.pushFollow(Ham4Parser.FOLLOW_revolutions_in_simplemovement11957);
revolutions344=this.revolutions();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_revolutions.add(revolutions344.getTree());
break;
}
// Ham4Parser.g:3208:13: ( ellipse )?
var alt131=2;
alt131 = this.dfa131.predict(this.input);
switch (alt131) {
case 1 :
// Ham4Parser.g:3208:15: ellipse
this.pushFollow(Ham4Parser.FOLLOW_ellipse_in_simplemovement11976);
ellipse345=this.ellipse();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ellipse.add(ellipse345.getTree());
break;
}
// Ham4Parser.g:3209:13: ( sizechangenonlinear )?
var alt132=2;
alt132 = this.dfa132.predict(this.input);
switch (alt132) {
case 1 :
// Ham4Parser.g:3209:15: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_simplemovement11995);
sizechangenonlinear346=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear346.getTree());
break;
}
break;
case 3 :
// Ham4Parser.g:3211:13: movementcross ( size )?
this.pushFollow(Ham4Parser.FOLLOW_movementcross_in_simplemovement12022);
movementcross347=this.movementcross();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcross.add(movementcross347.getTree());
// Ham4Parser.g:3212:13: ( size )?
var alt133=2;
alt133 = this.dfa133.predict(this.input);
switch (alt133) {
case 1 :
// Ham4Parser.g:3212:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement12038);
size348=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size348.getTree());
break;
}
break;
case 4 :
// Ham4Parser.g:3214:13: wristmovement ( size )?
this.pushFollow(Ham4Parser.FOLLOW_wristmovement_in_simplemovement12065);
wristmovement349=this.wristmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_wristmovement.add(wristmovement349.getTree());
// Ham4Parser.g:3215:13: ( size )?
var alt134=2;
alt134 = this.dfa134.predict(this.input);
switch (alt134) {
case 1 :
// Ham4Parser.g:3215:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement12081);
size350=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size350.getTree());
break;
}
break;
case 5 :
// Ham4Parser.g:3217:13: replacement
this.pushFollow(Ham4Parser.FOLLOW_replacement_in_simplemovement12108);
replacement351=this.replacement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacement.add(replacement351.getTree());
break;
case 6 :
// Ham4Parser.g:3219:13: HamFingerplay
HamFingerplay352=this.match(this.input,HamFingerplay,Ham4Parser.FOLLOW_HamFingerplay_in_simplemovement12132); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFingerplay.add(HamFingerplay352);
break;
}
// Ham4Parser.g:3221:9: ( ( HamSeqbegin HamBrushing )=> brushingcontact )?
var alt136=2;
alt136 = this.dfa136.predict(this.input);
switch (alt136) {
case 1 :
// Ham4Parser.g:3222:11: ( HamSeqbegin HamBrushing )=> brushingcontact
this.pushFollow(Ham4Parser.FOLLOW_brushingcontact_in_simplemovement12194);
brushingcontact353=this.brushingcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_brushingcontact.add(brushingcontact353.getTree());
break;
}
// Ham4Parser.g:3226:9: ( ( locationindexdefine )=> locationindexdefine )?
var alt137=2;
alt137 = this.dfa137.predict(this.input);
switch (alt137) {
case 1 :
// Ham4Parser.g:3227:11: ( locationindexdefine )=> locationindexdefine
this.pushFollow(Ham4Parser.FOLLOW_locationindexdefine_in_simplemovement12289);
locationindexdefine354=this.locationindexdefine();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationindexdefine.add(locationindexdefine354.getTree());
break;
}
// AST REWRITE
// elements: replacement, revolutions, wristmovement, locationindexdefine, straightmovement, zigzag, movementcross, ellipse, sizechangenonlinear, HamFingerplay, brushingcontact, arckind, circularmovement, size
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3232:4: -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? )
{
// Ham4Parser.g:3232:7: ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIMPLEMVMT, "SIMPLEMVMT"), root_1);
// Ham4Parser.g:3232:20: ( straightmovement )?
if ( stream_straightmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_straightmovement.nextTree());
}
stream_straightmovement.reset();
// Ham4Parser.g:3232:38: ( circularmovement )?
if ( stream_circularmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_circularmovement.nextTree());
}
stream_circularmovement.reset();
// Ham4Parser.g:3232:56: ( movementcross )?
if ( stream_movementcross.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementcross.nextTree());
}
stream_movementcross.reset();
// Ham4Parser.g:3232:71: ( wristmovement )?
if ( stream_wristmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_wristmovement.nextTree());
}
stream_wristmovement.reset();
// Ham4Parser.g:3232:86: ( size )?
if ( stream_size.hasNext() ) {
this.adaptor.addChild(root_1, stream_size.nextTree());
}
stream_size.reset();
// Ham4Parser.g:3233:6: ( arckind )?
if ( stream_arckind.hasNext() ) {
this.adaptor.addChild(root_1, stream_arckind.nextTree());
}
stream_arckind.reset();
// Ham4Parser.g:3233:15: ( zigzag )?
if ( stream_zigzag.hasNext() ) {
this.adaptor.addChild(root_1, stream_zigzag.nextTree());
}
stream_zigzag.reset();
// Ham4Parser.g:3234:6: ( revolutions )?
if ( stream_revolutions.hasNext() ) {
this.adaptor.addChild(root_1, stream_revolutions.nextTree());
}
stream_revolutions.reset();
// Ham4Parser.g:3234:19: ( ellipse )?
if ( stream_ellipse.hasNext() ) {
this.adaptor.addChild(root_1, stream_ellipse.nextTree());
}
stream_ellipse.reset();
// Ham4Parser.g:3234:28: ( sizechangenonlinear )?
if ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
// Ham4Parser.g:3235:6: ( replacement )?
if ( stream_replacement.hasNext() ) {
this.adaptor.addChild(root_1, stream_replacement.nextTree());
}
stream_replacement.reset();
// Ham4Parser.g:3235:19: ( HamFingerplay )?
if ( stream_HamFingerplay.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamFingerplay.nextNode());
}
stream_HamFingerplay.reset();
// Ham4Parser.g:3236:6: ( brushingcontact )?
if ( stream_brushingcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_brushingcontact.nextTree());
}
stream_brushingcontact.reset();
// Ham4Parser.g:3236:23: ( locationindexdefine )?
if ( stream_locationindexdefine.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationindexdefine.nextTree());
}
stream_locationindexdefine.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: simplemovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
specialfingerplaymovement_return: (function() {
Ham4Parser.specialfingerplaymovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.specialfingerplaymovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3239:1: specialfingerplaymovement : HamSeqbegin ( digit )+ HamFingerplay HamSeqend -> ^( SIMPLEMVMT ( digit )* HamFingerplay ) ;
// $ANTLR start "specialfingerplaymovement"
specialfingerplaymovement: function() {
var retval = new Ham4Parser.specialfingerplaymovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin355 = null;
var HamFingerplay357 = null;
var HamSeqend358 = null;
var digit356 = null;
var HamSeqbegin355_tree=null;
var HamFingerplay357_tree=null;
var HamSeqend358_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamFingerplay=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFingerplay");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: specialfingerplaymovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3258:5: ( HamSeqbegin ( digit )+ HamFingerplay HamSeqend -> ^( SIMPLEMVMT ( digit )* HamFingerplay ) )
// Ham4Parser.g:3259:9: HamSeqbegin ( digit )+ HamFingerplay HamSeqend
HamSeqbegin355=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_specialfingerplaymovement12449); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin355);
// Ham4Parser.g:3260:9: ( digit )+
var cnt138=0;
loop138:
do {
var alt138=2;
var LA138_0 = this.input.LA(1);
if ( ((LA138_0>=HamThumb && LA138_0<=HamPinky)) ) {
alt138=1;
}
switch (alt138) {
case 1 :
// Ham4Parser.g:3260:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_specialfingerplaymovement12462);
digit356=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(digit356.getTree());
break;
default :
if ( cnt138 >= 1 ) {
break loop138;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(138, this.input);
throw eee;
}
cnt138++;
} while (true);
HamFingerplay357=this.match(this.input,HamFingerplay,Ham4Parser.FOLLOW_HamFingerplay_in_specialfingerplaymovement12475); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFingerplay.add(HamFingerplay357);
HamSeqend358=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_specialfingerplaymovement12485); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend358);
// AST REWRITE
// elements: HamFingerplay, digit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3263:5: -> ^( SIMPLEMVMT ( digit )* HamFingerplay )
{
// Ham4Parser.g:3263:8: ^( SIMPLEMVMT ( digit )* HamFingerplay )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIMPLEMVMT, "SIMPLEMVMT"), root_1);
// Ham4Parser.g:3263:21: ( digit )*
while ( stream_digit.hasNext() ) {
this.adaptor.addChild(root_1, stream_digit.nextTree());
}
stream_digit.reset();
this.adaptor.addChild(root_1, stream_HamFingerplay.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: specialfingerplaymovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
straightmovement_return: (function() {
Ham4Parser.straightmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.straightmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3266:1: straightmovement : movementarrow ( HamBetween movementarrow )? -> ^( STRGHTMVMT ( movementarrow )* ) ;
// $ANTLR start "straightmovement"
straightmovement: function() {
var retval = new Ham4Parser.straightmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween360 = null;
var movementarrow359 = null;
var movementarrow361 = null;
var HamBetween360_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_movementarrow=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementarrow");
this.trace("ANTLR Parse: straightmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3285:5: ( movementarrow ( HamBetween movementarrow )? -> ^( STRGHTMVMT ( movementarrow )* ) )
// Ham4Parser.g:3285:9: movementarrow ( HamBetween movementarrow )?
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_straightmovement12530);
movementarrow359=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow359.getTree());
// Ham4Parser.g:3286:9: ( HamBetween movementarrow )?
var alt139=2;
var LA139_0 = this.input.LA(1);
if ( (LA139_0==HamBetween) ) {
alt139=1;
}
switch (alt139) {
case 1 :
// Ham4Parser.g:3287:13: HamBetween movementarrow
HamBetween360=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_straightmovement12554); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween360);
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_straightmovement12569);
movementarrow361=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow361.getTree());
break;
}
// AST REWRITE
// elements: movementarrow
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3290:5: -> ^( STRGHTMVMT ( movementarrow )* )
{
// Ham4Parser.g:3290:8: ^( STRGHTMVMT ( movementarrow )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(STRGHTMVMT, "STRGHTMVMT"), root_1);
// Ham4Parser.g:3290:21: ( movementarrow )*
while ( stream_movementarrow.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementarrow.nextTree());
}
stream_movementarrow.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: straightmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
circularmovement_return: (function() {
Ham4Parser.circularmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.circularmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3293:1: circularmovement : movementcircle ( HamBetween movementcircle )? -> ^( CRCLRMVMT ( movementcircle )* ) ;
// $ANTLR start "circularmovement"
circularmovement: function() {
var retval = new Ham4Parser.circularmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween363 = null;
var movementcircle362 = null;
var movementcircle364 = null;
var HamBetween363_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_movementcircle=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementcircle");
this.trace("ANTLR Parse: circularmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3312:5: ( movementcircle ( HamBetween movementcircle )? -> ^( CRCLRMVMT ( movementcircle )* ) )
// Ham4Parser.g:3312:9: movementcircle ( HamBetween movementcircle )?
this.pushFollow(Ham4Parser.FOLLOW_movementcircle_in_circularmovement12622);
movementcircle362=this.movementcircle();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcircle.add(movementcircle362.getTree());
// Ham4Parser.g:3313:9: ( HamBetween movementcircle )?
var alt140=2;
var LA140_0 = this.input.LA(1);
if ( (LA140_0==HamBetween) ) {
alt140=1;
}
switch (alt140) {
case 1 :
// Ham4Parser.g:3314:13: HamBetween movementcircle
HamBetween363=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_circularmovement12646); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween363);
this.pushFollow(Ham4Parser.FOLLOW_movementcircle_in_circularmovement12661);
movementcircle364=this.movementcircle();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcircle.add(movementcircle364.getTree());
break;
}
// AST REWRITE
// elements: movementcircle
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3317:5: -> ^( CRCLRMVMT ( movementcircle )* )
{
// Ham4Parser.g:3317:8: ^( CRCLRMVMT ( movementcircle )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CRCLRMVMT, "CRCLRMVMT"), root_1);
// Ham4Parser.g:3317:20: ( movementcircle )*
while ( stream_movementcircle.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementcircle.nextTree());
}
stream_movementcircle.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: circularmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
arckind_return: (function() {
Ham4Parser.arckind_return = function(){};
org.antlr.lang.extend(Ham4Parser.arckind_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3320:1: arckind : arc ( arc )? ( size )? ;
// $ANTLR start "arckind"
arckind: function() {
var retval = new Ham4Parser.arckind_return();
retval.start = this.input.LT(1);
var root_0 = null;
var arc365 = null;
var arc366 = null;
var size367 = null;
this.trace("ANTLR Parse: arckind starts "+this.state.backtracking);
try {
// Ham4Parser.g:3336:5: ( arc ( arc )? ( size )? )
// Ham4Parser.g:3336:9: arc ( arc )? ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_arc_in_arckind12714);
arc365=this.arc();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arc365.getTree());
// Ham4Parser.g:3337:9: ( arc )?
var alt141=2;
var LA141_0 = this.input.LA(1);
if ( ((LA141_0>=HamArcl && LA141_0<=HamArcd)) ) {
alt141=1;
}
switch (alt141) {
case 1 :
// Ham4Parser.g:3337:11: arc
this.pushFollow(Ham4Parser.FOLLOW_arc_in_arckind12726);
arc366=this.arc();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arc366.getTree());
break;
}
// Ham4Parser.g:3338:9: ( size )?
var alt142=2;
var LA142_0 = this.input.LA(1);
if ( ((LA142_0>=HamSmallmod && LA142_0<=HamLargemod)) ) {
alt142=1;
}
switch (alt142) {
case 1 :
// Ham4Parser.g:3338:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_arckind12741);
size367=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size367.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: arckind finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
zigzag_return: (function() {
Ham4Parser.zigzag_return = function(){};
org.antlr.lang.extend(Ham4Parser.zigzag_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3341:1: zigzag : ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )? ;
// $ANTLR start "zigzag"
zigzag: function() {
var retval = new Ham4Parser.zigzag_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set368 = null;
var size369 = null;
var ellipsedirection370 = null;
var sizechangenonlinear371 = null;
var set368_tree=null;
this.trace("ANTLR Parse: zigzag starts "+this.state.backtracking);
try {
// Ham4Parser.g:3362:5: ( ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )? )
// Ham4Parser.g:3362:9: ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )?
root_0 = this.adaptor.nil();
set368=this.input.LT(1);
if ( (this.input.LA(1)>=HamWavy && this.input.LA(1)<=HamZigzag) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set368));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:3367:9: ( size )?
var alt143=2;
var LA143_0 = this.input.LA(1);
if ( ((LA143_0>=HamSmallmod && LA143_0<=HamLargemod)) ) {
alt143=1;
}
switch (alt143) {
case 1 :
// Ham4Parser.g:3367:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_zigzag12833);
size369=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size369.getTree());
break;
}
// Ham4Parser.g:3368:9: ( ellipsedirection )?
var alt144=2;
var LA144_0 = this.input.LA(1);
if ( ((LA144_0>=HamEllipseh && LA144_0<=HamEllipseul)) ) {
alt144=1;
}
switch (alt144) {
case 1 :
// Ham4Parser.g:3368:11: ellipsedirection
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_zigzag12848);
ellipsedirection370=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ellipsedirection370.getTree());
break;
}
// Ham4Parser.g:3369:9: ( sizechangenonlinear )?
var alt145=2;
var LA145_0 = this.input.LA(1);
if ( ((LA145_0>=HamIncreasing && LA145_0<=HamDecreasing)) ) {
alt145=1;
}
switch (alt145) {
case 1 :
// Ham4Parser.g:3369:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_zigzag12863);
sizechangenonlinear371=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sizechangenonlinear371.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: zigzag finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sizechangenonlinear_return: (function() {
Ham4Parser.sizechangenonlinear_return = function(){};
org.antlr.lang.extend(Ham4Parser.sizechangenonlinear_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3372:1: sizechangenonlinear : sizechange ( size )? ;
// $ANTLR start "sizechangenonlinear"
sizechangenonlinear: function() {
var retval = new Ham4Parser.sizechangenonlinear_return();
retval.start = this.input.LT(1);
var root_0 = null;
var sizechange372 = null;
var size373 = null;
this.trace("ANTLR Parse: sizechangenonlinear starts "+this.state.backtracking);
try {
// Ham4Parser.g:3387:5: ( sizechange ( size )? )
// Ham4Parser.g:3387:9: sizechange ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_sizechange_in_sizechangenonlinear12895);
sizechange372=this.sizechange();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sizechange372.getTree());
// Ham4Parser.g:3388:9: ( size )?
var alt146=2;
var LA146_0 = this.input.LA(1);
if ( ((LA146_0>=HamSmallmod && LA146_0<=HamLargemod)) ) {
alt146=1;
}
switch (alt146) {
case 1 :
// Ham4Parser.g:3388:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_sizechangenonlinear12907);
size373=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size373.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sizechangenonlinear finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ellipse_return: (function() {
Ham4Parser.ellipse_return = function(){};
org.antlr.lang.extend(Ham4Parser.ellipse_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3391:1: ellipse : ellipsedirection ( size )? ;
// $ANTLR start "ellipse"
ellipse: function() {
var retval = new Ham4Parser.ellipse_return();
retval.start = this.input.LT(1);
var root_0 = null;
var ellipsedirection374 = null;
var size375 = null;
this.trace("ANTLR Parse: ellipse starts "+this.state.backtracking);
try {
// Ham4Parser.g:3406:5: ( ellipsedirection ( size )? )
// Ham4Parser.g:3406:9: ellipsedirection ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_ellipse12939);
ellipsedirection374=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ellipsedirection374.getTree());
// Ham4Parser.g:3407:9: ( size )?
var alt147=2;
var LA147_0 = this.input.LA(1);
if ( ((LA147_0>=HamSmallmod && LA147_0<=HamLargemod)) ) {
alt147=1;
}
switch (alt147) {
case 1 :
// Ham4Parser.g:3407:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_ellipse12951);
size375=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size375.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ellipse finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
revolutions_return: (function() {
Ham4Parser.revolutions_return = function(){};
org.antlr.lang.extend(Ham4Parser.revolutions_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3410:1: revolutions : ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? ) ;
// $ANTLR start "revolutions"
revolutions: function() {
var retval = new Ham4Parser.revolutions_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamClockfull377 = null;
var HamClockfull378 = null;
var HamClockfull380 = null;
var HamClockfull381 = null;
var clock376 = null;
var clock379 = null;
var clock382 = null;
var HamClockfull377_tree=null;
var HamClockfull378_tree=null;
var HamClockfull380_tree=null;
var HamClockfull381_tree=null;
this.trace("ANTLR Parse: revolutions starts "+this.state.backtracking);
try {
// Ham4Parser.g:3436:5: ( ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? ) )
// Ham4Parser.g:3437:5: ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3437:5: ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? )
var alt153=2;
var LA153_0 = this.input.LA(1);
if ( ((LA153_0>=HamClocku && LA153_0<=HamClockur)) ) {
alt153=1;
}
else if ( (LA153_0==HamClockfull) ) {
alt153=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 153, 0, this.input);
throw nvae;
}
switch (alt153) {
case 1 :
// Ham4Parser.g:3438:9: clock ( HamClockfull ( HamClockfull )? )? ( clock )?
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions12995);
clock376=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock376.getTree());
// Ham4Parser.g:3439:9: ( HamClockfull ( HamClockfull )? )?
var alt149=2;
var LA149_0 = this.input.LA(1);
if ( (LA149_0==HamClockfull) ) {
alt149=1;
}
switch (alt149) {
case 1 :
// Ham4Parser.g:3440:13: HamClockfull ( HamClockfull )?
HamClockfull377=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13019); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull377_tree = this.adaptor.create(HamClockfull377);
this.adaptor.addChild(root_0, HamClockfull377_tree);
}
// Ham4Parser.g:3441:13: ( HamClockfull )?
var alt148=2;
var LA148_0 = this.input.LA(1);
if ( (LA148_0==HamClockfull) ) {
alt148=1;
}
switch (alt148) {
case 1 :
// Ham4Parser.g:3441:15: HamClockfull
HamClockfull378=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13035); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull378_tree = this.adaptor.create(HamClockfull378);
this.adaptor.addChild(root_0, HamClockfull378_tree);
}
break;
}
break;
}
// Ham4Parser.g:3443:9: ( clock )?
var alt150=2;
var LA150_0 = this.input.LA(1);
if ( ((LA150_0>=HamClocku && LA150_0<=HamClockur)) ) {
alt150=1;
}
switch (alt150) {
case 1 :
// Ham4Parser.g:3443:11: clock
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions13061);
clock379=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock379.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3445:9: HamClockfull ( HamClockfull )? ( clock )?
HamClockfull380=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13080); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull380_tree = this.adaptor.create(HamClockfull380);
this.adaptor.addChild(root_0, HamClockfull380_tree);
}
// Ham4Parser.g:3446:9: ( HamClockfull )?
var alt151=2;
var LA151_0 = this.input.LA(1);
if ( (LA151_0==HamClockfull) ) {
alt151=1;
}
switch (alt151) {
case 1 :
// Ham4Parser.g:3446:11: HamClockfull
HamClockfull381=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13092); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull381_tree = this.adaptor.create(HamClockfull381);
this.adaptor.addChild(root_0, HamClockfull381_tree);
}
break;
}
// Ham4Parser.g:3447:9: ( clock )?
var alt152=2;
var LA152_0 = this.input.LA(1);
if ( ((LA152_0>=HamClocku && LA152_0<=HamClockur)) ) {
alt152=1;
}
switch (alt152) {
case 1 :
// Ham4Parser.g:3447:11: clock
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions13107);
clock382=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock382.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: revolutions finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
replacement_return: (function() {
Ham4Parser.replacement_return = function(){};
org.antlr.lang.extend(Ham4Parser.replacement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3451:1: replacement : HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) ) ;
// $ANTLR start "replacement"
replacement: function() {
var retval = new Ham4Parser.replacement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamReplace383 = null;
var sizechange384 = null;
var handshape1385 = null;
var splitreplacetail386 = null;
var extfidir1387 = null;
var palmor1388 = null;
var splitreplacetail389 = null;
var extfidir1390 = null;
var palmor1391 = null;
var palmor1392 = null;
var HamReplace383_tree=null;
var stream_HamReplace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamReplace");
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_sizechange=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechange");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
var stream_splitreplacetail=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitreplacetail");
this.trace("ANTLR Parse: replacement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3488:5: ( HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) ) )
// Ham4Parser.g:3488:9: HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) )
HamReplace383=this.match(this.input,HamReplace,Ham4Parser.FOLLOW_HamReplace_in_replacement13145); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamReplace.add(HamReplace383);
// Ham4Parser.g:3489:9: ( sizechange )?
var alt154=2;
var LA154_0 = this.input.LA(1);
if ( ((LA154_0>=HamIncreasing && LA154_0<=HamDecreasing)) ) {
alt154=1;
}
switch (alt154) {
case 1 :
// Ham4Parser.g:3489:11: sizechange
this.pushFollow(Ham4Parser.FOLLOW_sizechange_in_replacement13158);
sizechange384=this.sizechange();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechange.add(sizechange384.getTree());
break;
}
// Ham4Parser.g:3490:9: ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) )
var alt159=4;
switch ( this.input.LA(1) ) {
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
case HamNondominant:
alt159=1;
break;
case HamParbegin:
alt159=2;
break;
case HamExtfingeru:
case HamExtfingerur:
case HamExtfingerr:
case HamExtfingerdr:
case HamExtfingerd:
case HamExtfingerdl:
case HamExtfingerl:
case HamExtfingerul:
case HamExtfingerol:
case HamExtfingero:
case HamExtfingeror:
case HamExtfingeril:
case HamExtfingeri:
case HamExtfingerir:
case HamExtfingerui:
case HamExtfingerdi:
case HamExtfingerdo:
case HamExtfingeruo:
alt159=3;
break;
case HamPalmu:
case HamPalmur:
case HamPalmr:
case HamPalmdr:
case HamPalmd:
case HamPalmdl:
case HamPalml:
case HamPalmul:
alt159=4;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 159, 0, this.input);
throw nvae;
}
switch (alt159) {
case 1 :
// Ham4Parser.g:3491:13: handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_replacement13185);
handshape1385=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape1385.getTree());
// Ham4Parser.g:3492:13: ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )
var alt157=2;
alt157 = this.dfa157.predict(this.input);
switch (alt157) {
case 1 :
// Ham4Parser.g:3493:17: ( splitreplacetail )=> splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_replacement13257);
splitreplacetail386=this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitreplacetail.add(splitreplacetail386.getTree());
break;
case 2 :
// Ham4Parser.g:3497:17: ( extfidir1 )? ( palmor1 )?
// Ham4Parser.g:3497:17: ( extfidir1 )?
var alt155=2;
var LA155_0 = this.input.LA(1);
if ( ((LA155_0>=HamExtfingeru && LA155_0<=HamExtfingeruo)) ) {
alt155=1;
}
switch (alt155) {
case 1 :
// Ham4Parser.g:3497:19: extfidir1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacement13291);
extfidir1387=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1387.getTree());
break;
}
// Ham4Parser.g:3498:17: ( palmor1 )?
var alt156=2;
var LA156_0 = this.input.LA(1);
if ( ((LA156_0>=HamPalmu && LA156_0<=HamPalmul)) ) {
alt156=1;
}
switch (alt156) {
case 1 :
// Ham4Parser.g:3498:19: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13314);
palmor1388=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1388.getTree());
break;
}
break;
}
// AST REWRITE
// elements: sizechange, palmor1, splitreplacetail, handshape1, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3500:6: -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* )
{
// Ham4Parser.g:3500:9: ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3500:19: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
// Ham4Parser.g:3500:42: ( splitreplacetail )*
while ( stream_splitreplacetail.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitreplacetail.nextTree());
}
stream_splitreplacetail.reset();
// Ham4Parser.g:3500:60: ( extfidir1 )*
while ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:3500:71: ( palmor1 )*
while ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:3502:13: splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_replacement13380);
splitreplacetail389=this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitreplacetail.add(splitreplacetail389.getTree());
// AST REWRITE
// elements: sizechange, splitreplacetail
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3503:5: -> ^( REPLACE ( sizechange )* splitreplacetail )
{
// Ham4Parser.g:3503:8: ^( REPLACE ( sizechange )* splitreplacetail )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3503:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_splitreplacetail.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:3505:13: extfidir1 ( palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacement13419);
extfidir1390=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1390.getTree());
// Ham4Parser.g:3506:13: ( palmor1 )?
var alt158=2;
var LA158_0 = this.input.LA(1);
if ( ((LA158_0>=HamPalmu && LA158_0<=HamPalmul)) ) {
alt158=1;
}
switch (alt158) {
case 1 :
// Ham4Parser.g:3506:15: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13435);
palmor1391=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1391.getTree());
break;
}
// AST REWRITE
// elements: palmor1, sizechange, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3507:5: -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* )
{
// Ham4Parser.g:3507:8: ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3507:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
// Ham4Parser.g:3507:40: ( palmor1 )*
while ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:3509:13: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13480);
palmor1392=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1392.getTree());
// AST REWRITE
// elements: palmor1, sizechange
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3510:5: -> ^( REPLACE ( sizechange )* palmor1 )
{
// Ham4Parser.g:3510:8: ^( REPLACE ( sizechange )* palmor1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3510:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: replacement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitreplacetail_return: (function() {
Ham4Parser.splitreplacetail_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitreplacetail_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3514:1: splitreplacetail : HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend -> ^( SPLITREPLACETL ( replacetail1 )* ) ;
// $ANTLR start "splitreplacetail"
splitreplacetail: function() {
var retval = new Ham4Parser.splitreplacetail_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin393 = null;
var HamPlus395 = null;
var HamNomotion396 = null;
var HamParend398 = null;
var replacetail1394 = null;
var replacetail1397 = null;
var HamParbegin393_tree=null;
var HamPlus395_tree=null;
var HamNomotion396_tree=null;
var HamParend398_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_replacetail1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule replacetail1");
this.trace("ANTLR Parse: splitreplacetail starts "+this.state.backtracking);
try {
// Ham4Parser.g:3538:5: ( HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend -> ^( SPLITREPLACETL ( replacetail1 )* ) )
// Ham4Parser.g:3538:9: HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend
HamParbegin393=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitreplacetail13534); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin393);
this.pushFollow(Ham4Parser.FOLLOW_replacetail1_in_splitreplacetail13545);
replacetail1394=this.replacetail1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacetail1.add(replacetail1394.getTree());
HamPlus395=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitreplacetail13555); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus395);
// Ham4Parser.g:3541:9: ( HamNomotion | replacetail1 )
var alt160=2;
var LA160_0 = this.input.LA(1);
if ( (LA160_0==HamNomotion) ) {
alt160=1;
}
else if ( ((LA160_0>=HamExtfingeru && LA160_0<=HamExtfingeruo)||(LA160_0>=HamPalmu && LA160_0<=HamPalmul)) ) {
alt160=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 160, 0, this.input);
throw nvae;
}
switch (alt160) {
case 1 :
// Ham4Parser.g:3542:13: HamNomotion
HamNomotion396=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_splitreplacetail13580); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion396);
break;
case 2 :
// Ham4Parser.g:3544:13: replacetail1
this.pushFollow(Ham4Parser.FOLLOW_replacetail1_in_splitreplacetail13605);
replacetail1397=this.replacetail1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacetail1.add(replacetail1397.getTree());
break;
}
HamParend398=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitreplacetail13625); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend398);
// AST REWRITE
// elements: replacetail1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3548:5: -> ^( SPLITREPLACETL ( replacetail1 )* )
{
// Ham4Parser.g:3548:8: ^( SPLITREPLACETL ( replacetail1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITREPLACETL, "SPLITREPLACETL"), root_1);
// Ham4Parser.g:3548:25: ( replacetail1 )*
while ( stream_replacetail1.hasNext() ) {
this.adaptor.addChild(root_1, stream_replacetail1.nextTree());
}
stream_replacetail1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitreplacetail finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
replacetail1_return: (function() {
Ham4Parser.replacetail1_return = function(){};
org.antlr.lang.extend(Ham4Parser.replacetail1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3551:1: replacetail1 : ( extfidir1 ( palmor1 )? | palmor1 ) -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? ) ;
// $ANTLR start "replacetail1"
replacetail1: function() {
var retval = new Ham4Parser.replacetail1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidir1399 = null;
var palmor1400 = null;
var palmor1401 = null;
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: replacetail1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:3572:5: ( ( extfidir1 ( palmor1 )? | palmor1 ) -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? ) )
// Ham4Parser.g:3573:5: ( extfidir1 ( palmor1 )? | palmor1 )
// Ham4Parser.g:3573:5: ( extfidir1 ( palmor1 )? | palmor1 )
var alt162=2;
var LA162_0 = this.input.LA(1);
if ( ((LA162_0>=HamExtfingeru && LA162_0<=HamExtfingeruo)) ) {
alt162=1;
}
else if ( ((LA162_0>=HamPalmu && LA162_0<=HamPalmul)) ) {
alt162=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 162, 0, this.input);
throw nvae;
}
switch (alt162) {
case 1 :
// Ham4Parser.g:3574:9: extfidir1 ( palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacetail113689);
extfidir1399=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1399.getTree());
// Ham4Parser.g:3575:9: ( palmor1 )?
var alt161=2;
var LA161_0 = this.input.LA(1);
if ( ((LA161_0>=HamPalmu && LA161_0<=HamPalmul)) ) {
alt161=1;
}
switch (alt161) {
case 1 :
// Ham4Parser.g:3575:11: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacetail113701);
palmor1400=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1400.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3577:9: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacetail113720);
palmor1401=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1401.getTree());
break;
}
// AST REWRITE
// elements: extfidir1, palmor1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3579:4: -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? )
{
// Ham4Parser.g:3579:7: ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACETAIL1, "REPLACETAIL1"), root_1);
// Ham4Parser.g:3579:22: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:3579:33: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: replacetail1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
brushingcontact_return: (function() {
Ham4Parser.brushingcontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.brushingcontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3582:1: brushingcontact : HamSeqbegin HamBrushing location1 HamSeqend ;
// $ANTLR start "brushingcontact"
brushingcontact: function() {
var retval = new Ham4Parser.brushingcontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin402 = null;
var HamBrushing403 = null;
var HamSeqend405 = null;
var location1404 = null;
var HamSeqbegin402_tree=null;
var HamBrushing403_tree=null;
var HamSeqend405_tree=null;
this.trace("ANTLR Parse: brushingcontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:3600:5: ( HamSeqbegin HamBrushing location1 HamSeqend )
// Ham4Parser.g:3601:9: HamSeqbegin HamBrushing location1 HamSeqend
root_0 = this.adaptor.nil();
HamSeqbegin402=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_brushingcontact13776); if (this.state.failed) return retval;
HamBrushing403=this.match(this.input,HamBrushing,Ham4Parser.FOLLOW_HamBrushing_in_brushingcontact13788); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamBrushing403_tree = this.adaptor.create(HamBrushing403);
this.adaptor.addChild(root_0, HamBrushing403_tree);
}
this.pushFollow(Ham4Parser.FOLLOW_location1_in_brushingcontact13798);
location1404=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location1404.getTree());
HamSeqend405=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_brushingcontact13808); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: brushingcontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshapeclasstok_return: (function() {
Ham4Parser.handshapeclasstok_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshapeclasstok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3610:1: handshapeclasstok : ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ;
// $ANTLR start "handshapeclasstok"
handshapeclasstok: function() {
var retval = new Ham4Parser.handshapeclasstok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set406 = null;
var set406_tree=null;
this.trace("ANTLR Parse: handshapeclasstok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3639:5: ( ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) )
// Ham4Parser.g:3640:5: ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open )
root_0 = this.adaptor.nil();
set406=this.input.LT(1);
if ( (this.input.LA(1)>=HamFist && this.input.LA(1)<=HamFinger2345)||(this.input.LA(1)>=HamPinch12 && this.input.LA(1)<=HamCee12open) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set406));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshapeclasstok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshapeclass_return: (function() {
Ham4Parser.handshapeclass_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshapeclass_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3657:1: handshapeclass : handshapeclasstok -> ^( HSCLASS handshapeclasstok ) ;
// $ANTLR start "handshapeclass"
handshapeclass: function() {
var retval = new Ham4Parser.handshapeclass_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshapeclasstok407 = null;
var stream_handshapeclasstok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshapeclasstok");
try {
// Ham4Parser.g:3658:2: ( handshapeclasstok -> ^( HSCLASS handshapeclasstok ) )
// Ham4Parser.g:3658:4: handshapeclasstok
this.pushFollow(Ham4Parser.FOLLOW_handshapeclasstok_in_handshapeclass13980);
handshapeclasstok407=this.handshapeclasstok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshapeclasstok.add(handshapeclasstok407.getTree());
// AST REWRITE
// elements: handshapeclasstok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3659:2: -> ^( HSCLASS handshapeclasstok )
{
// Ham4Parser.g:3659:5: ^( HSCLASS handshapeclasstok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSCLASS, "HSCLASS"), root_1);
this.adaptor.addChild(root_1, stream_handshapeclasstok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerbendingtok_return: (function() {
Ham4Parser.fingerbendingtok_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerbendingtok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3662:1: fingerbendingtok : ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ;
// $ANTLR start "fingerbendingtok"
fingerbendingtok: function() {
var retval = new Ham4Parser.fingerbendingtok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set408 = null;
var set408_tree=null;
this.trace("ANTLR Parse: fingerbendingtok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3682:5: ( ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) )
// Ham4Parser.g:3683:5: ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked )
root_0 = this.adaptor.nil();
set408=this.input.LT(1);
if ( (this.input.LA(1)>=HamFingerstraightmod && this.input.LA(1)<=HamFingerhookedmod)||(this.input.LA(1)>=HamDoublebent && this.input.LA(1)<=HamDoublehooked) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set408));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerbendingtok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerbending_return: (function() {
Ham4Parser.fingerbending_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerbending_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3691:1: fingerbending : fingerbendingtok -> ^( FIBENDING fingerbendingtok ) ;
// $ANTLR start "fingerbending"
fingerbending: function() {
var retval = new Ham4Parser.fingerbending_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingerbendingtok409 = null;
var stream_fingerbendingtok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerbendingtok");
try {
// Ham4Parser.g:3692:2: ( fingerbendingtok -> ^( FIBENDING fingerbendingtok ) )
// Ham4Parser.g:3692:4: fingerbendingtok
this.pushFollow(Ham4Parser.FOLLOW_fingerbendingtok_in_fingerbending14085);
fingerbendingtok409=this.fingerbendingtok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerbendingtok.add(fingerbendingtok409.getTree());
// AST REWRITE
// elements: fingerbendingtok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3693:4: -> ^( FIBENDING fingerbendingtok )
{
// Ham4Parser.g:3693:7: ^( FIBENDING fingerbendingtok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FIBENDING, "FIBENDING"), root_1);
this.adaptor.addChild(root_1, stream_fingerbendingtok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbpostok_return: (function() {
Ham4Parser.thumbpostok_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbpostok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3696:1: thumbpostok : ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ;
// $ANTLR start "thumbpostok"
thumbpostok: function() {
var retval = new Ham4Parser.thumbpostok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set410 = null;
var set410_tree=null;
this.trace("ANTLR Parse: thumbpostok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3714:5: ( ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) )
// Ham4Parser.g:3715:5: ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod )
root_0 = this.adaptor.nil();
set410=this.input.LT(1);
if ( (this.input.LA(1)>=HamThumboutmod && this.input.LA(1)<=HamThumbacrossmod)||this.input.LA(1)==HamThumbopenmod ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set410));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbpostok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbpos_return: (function() {
Ham4Parser.thumbpos_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbpos_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3721:1: thumbpos : thumbpostok -> ^( THUMBPOS thumbpostok ) ;
// $ANTLR start "thumbpos"
thumbpos: function() {
var retval = new Ham4Parser.thumbpos_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbpostok411 = null;
var stream_thumbpostok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbpostok");
try {
// Ham4Parser.g:3722:2: ( thumbpostok -> ^( THUMBPOS thumbpostok ) )
// Ham4Parser.g:3722:4: thumbpostok
this.pushFollow(Ham4Parser.FOLLOW_thumbpostok_in_thumbpos14171);
thumbpostok411=this.thumbpostok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbpostok.add(thumbpostok411.getTree());
// AST REWRITE
// elements: thumbpostok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3723:4: -> ^( THUMBPOS thumbpostok )
{
// Ham4Parser.g:3723:7: ^( THUMBPOS thumbpostok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THUMBPOS, "THUMBPOS"), root_1);
this.adaptor.addChild(root_1, stream_thumbpostok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumb_return: (function() {
Ham4Parser.thumb_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumb_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3726:1: thumb : HamThumb ;
// $ANTLR start "thumb"
thumb: function() {
var retval = new Ham4Parser.thumb_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamThumb412 = null;
var HamThumb412_tree=null;
this.trace("ANTLR Parse: thumb starts "+this.state.backtracking);
try {
// Ham4Parser.g:3740:5: ( HamThumb )
// Ham4Parser.g:3740:9: HamThumb
root_0 = this.adaptor.nil();
HamThumb412=this.match(this.input,HamThumb,Ham4Parser.FOLLOW_HamThumb_in_thumb14211); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamThumb412_tree = this.adaptor.create(HamThumb412);
this.adaptor.addChild(root_0, HamThumb412_tree);
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumb finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
finger_return: (function() {
Ham4Parser.finger_return = function(){};
org.antlr.lang.extend(Ham4Parser.finger_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3743:1: finger : ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky );
// $ANTLR start "finger"
finger: function() {
var retval = new Ham4Parser.finger_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set413 = null;
var set413_tree=null;
this.trace("ANTLR Parse: finger starts "+this.state.backtracking);
try {
// Ham4Parser.g:3760:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set413=this.input.LT(1);
if ( (this.input.LA(1)>=HamIndexfinger && this.input.LA(1)<=HamPinky) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set413));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: finger finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerpart_return: (function() {
Ham4Parser.fingerpart_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerpart_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3766:1: fingerpart : ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside );
// $ANTLR start "fingerpart"
fingerpart: function() {
var retval = new Ham4Parser.fingerpart_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set414 = null;
var set414_tree=null;
this.trace("ANTLR Parse: fingerpart starts "+this.state.backtracking);
try {
// Ham4Parser.g:3785:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set414=this.input.LT(1);
if ( (this.input.LA(1)>=HamFingertip && this.input.LA(1)<=HamFingerside) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set414));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerpart finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidirtok_return: (function() {
Ham4Parser.extfidirtok_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidirtok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3793:1: extfidirtok : ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) ) ;
// $ANTLR start "extfidirtok"
extfidirtok: function() {
var retval = new Ham4Parser.extfidirtok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamExtfingeru415 = null;
var HamExtfingerur416 = null;
var HamExtfingerr417 = null;
var HamExtfingerdr418 = null;
var HamExtfingerd419 = null;
var HamExtfingerdl420 = null;
var HamExtfingerl421 = null;
var HamExtfingerul422 = null;
var HamExtfingerol423 = null;
var set424 = null;
var HamExtfingero425 = null;
var HamExtfingeror426 = null;
var set427 = null;
var HamExtfingeril428 = null;
var set429 = null;
var HamExtfingeri430 = null;
var HamExtfingerir431 = null;
var set432 = null;
var HamExtfingerui433 = null;
var set434 = null;
var HamExtfingerdi435 = null;
var set436 = null;
var HamExtfingerdo437 = null;
var set438 = null;
var HamExtfingeruo439 = null;
var set440 = null;
var HamExtfingeru415_tree=null;
var HamExtfingerur416_tree=null;
var HamExtfingerr417_tree=null;
var HamExtfingerdr418_tree=null;
var HamExtfingerd419_tree=null;
var HamExtfingerdl420_tree=null;
var HamExtfingerl421_tree=null;
var HamExtfingerul422_tree=null;
var HamExtfingerol423_tree=null;
var set424_tree=null;
var HamExtfingero425_tree=null;
var HamExtfingeror426_tree=null;
var set427_tree=null;
var HamExtfingeril428_tree=null;
var set429_tree=null;
var HamExtfingeri430_tree=null;
var HamExtfingerir431_tree=null;
var set432_tree=null;
var HamExtfingerui433_tree=null;
var set434_tree=null;
var HamExtfingerdi435_tree=null;
var set436_tree=null;
var HamExtfingerdo437_tree=null;
var set438_tree=null;
var HamExtfingeruo439_tree=null;
var set440_tree=null;
this.trace("ANTLR Parse: extfidirtok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3874:5: ( ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) ) )
// Ham4Parser.g:3875:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3875:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )
var alt171=18;
alt171 = this.dfa171.predict(this.input);
switch (alt171) {
case 1 :
// Ham4Parser.g:3875:9: HamExtfingeru
HamExtfingeru415=this.match(this.input,HamExtfingeru,Ham4Parser.FOLLOW_HamExtfingeru_in_extfidirtok14384); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeru415_tree = this.adaptor.create(HamExtfingeru415);
this.adaptor.addChild(root_0, HamExtfingeru415_tree);
}
break;
case 2 :
// Ham4Parser.g:3876:9: HamExtfingerur
HamExtfingerur416=this.match(this.input,HamExtfingerur,Ham4Parser.FOLLOW_HamExtfingerur_in_extfidirtok14394); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerur416_tree = this.adaptor.create(HamExtfingerur416);
this.adaptor.addChild(root_0, HamExtfingerur416_tree);
}
break;
case 3 :
// Ham4Parser.g:3877:9: HamExtfingerr
HamExtfingerr417=this.match(this.input,HamExtfingerr,Ham4Parser.FOLLOW_HamExtfingerr_in_extfidirtok14404); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerr417_tree = this.adaptor.create(HamExtfingerr417);
this.adaptor.addChild(root_0, HamExtfingerr417_tree);
}
break;
case 4 :
// Ham4Parser.g:3878:9: HamExtfingerdr
HamExtfingerdr418=this.match(this.input,HamExtfingerdr,Ham4Parser.FOLLOW_HamExtfingerdr_in_extfidirtok14414); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdr418_tree = this.adaptor.create(HamExtfingerdr418);
this.adaptor.addChild(root_0, HamExtfingerdr418_tree);
}
break;
case 5 :
// Ham4Parser.g:3879:9: HamExtfingerd
HamExtfingerd419=this.match(this.input,HamExtfingerd,Ham4Parser.FOLLOW_HamExtfingerd_in_extfidirtok14424); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerd419_tree = this.adaptor.create(HamExtfingerd419);
this.adaptor.addChild(root_0, HamExtfingerd419_tree);
}
break;
case 6 :
// Ham4Parser.g:3880:9: HamExtfingerdl
HamExtfingerdl420=this.match(this.input,HamExtfingerdl,Ham4Parser.FOLLOW_HamExtfingerdl_in_extfidirtok14434); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdl420_tree = this.adaptor.create(HamExtfingerdl420);
this.adaptor.addChild(root_0, HamExtfingerdl420_tree);
}
break;
case 7 :
// Ham4Parser.g:3881:9: HamExtfingerl
HamExtfingerl421=this.match(this.input,HamExtfingerl,Ham4Parser.FOLLOW_HamExtfingerl_in_extfidirtok14444); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerl421_tree = this.adaptor.create(HamExtfingerl421);
this.adaptor.addChild(root_0, HamExtfingerl421_tree);
}
break;
case 8 :
// Ham4Parser.g:3882:9: HamExtfingerul
HamExtfingerul422=this.match(this.input,HamExtfingerul,Ham4Parser.FOLLOW_HamExtfingerul_in_extfidirtok14454); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerul422_tree = this.adaptor.create(HamExtfingerul422);
this.adaptor.addChild(root_0, HamExtfingerul422_tree);
}
break;
case 9 :
// Ham4Parser.g:3883:9: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3883:9: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3884:13: HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )?
HamExtfingerol423=this.match(this.input,HamExtfingerol,Ham4Parser.FOLLOW_HamExtfingerol_in_extfidirtok14478); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerol423_tree = this.adaptor.create(HamExtfingerol423);
this.adaptor.addChild(root_0, HamExtfingerol423_tree);
}
// Ham4Parser.g:3885:13: ( HamExtfingeruo | HamExtfingerdo )?
var alt163=2;
var LA163_0 = this.input.LA(1);
if ( ((LA163_0>=HamExtfingerdo && LA163_0<=HamExtfingeruo)) ) {
alt163=1;
}
switch (alt163) {
case 1 :
// Ham4Parser.g:
set424=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerdo && this.input.LA(1)<=HamExtfingeruo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set424));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 10 :
// Ham4Parser.g:3890:9: HamExtfingero
HamExtfingero425=this.match(this.input,HamExtfingero,Ham4Parser.FOLLOW_HamExtfingero_in_extfidirtok14563); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingero425_tree = this.adaptor.create(HamExtfingero425);
this.adaptor.addChild(root_0, HamExtfingero425_tree);
}
break;
case 11 :
// Ham4Parser.g:3891:9: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3891:9: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3892:13: HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )?
HamExtfingeror426=this.match(this.input,HamExtfingeror,Ham4Parser.FOLLOW_HamExtfingeror_in_extfidirtok14587); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeror426_tree = this.adaptor.create(HamExtfingeror426);
this.adaptor.addChild(root_0, HamExtfingeror426_tree);
}
// Ham4Parser.g:3893:13: ( HamExtfingeruo | HamExtfingerdo )?
var alt164=2;
var LA164_0 = this.input.LA(1);
if ( ((LA164_0>=HamExtfingerdo && LA164_0<=HamExtfingeruo)) ) {
alt164=1;
}
switch (alt164) {
case 1 :
// Ham4Parser.g:
set427=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerdo && this.input.LA(1)<=HamExtfingeruo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set427));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 12 :
// Ham4Parser.g:3898:9: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3898:9: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3899:13: HamExtfingeril ( HamExtfingerui | HamExtfingerdi )?
HamExtfingeril428=this.match(this.input,HamExtfingeril,Ham4Parser.FOLLOW_HamExtfingeril_in_extfidirtok14686); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeril428_tree = this.adaptor.create(HamExtfingeril428);
this.adaptor.addChild(root_0, HamExtfingeril428_tree);
}
// Ham4Parser.g:3900:13: ( HamExtfingerui | HamExtfingerdi )?
var alt165=2;
var LA165_0 = this.input.LA(1);
if ( ((LA165_0>=HamExtfingerui && LA165_0<=HamExtfingerdi)) ) {
alt165=1;
}
switch (alt165) {
case 1 :
// Ham4Parser.g:
set429=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerui && this.input.LA(1)<=HamExtfingerdi) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set429));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 13 :
// Ham4Parser.g:3905:9: HamExtfingeri
HamExtfingeri430=this.match(this.input,HamExtfingeri,Ham4Parser.FOLLOW_HamExtfingeri_in_extfidirtok14771); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeri430_tree = this.adaptor.create(HamExtfingeri430);
this.adaptor.addChild(root_0, HamExtfingeri430_tree);
}
break;
case 14 :
// Ham4Parser.g:3906:9: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3906:9: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3907:13: HamExtfingerir ( HamExtfingerui | HamExtfingerdi )?
HamExtfingerir431=this.match(this.input,HamExtfingerir,Ham4Parser.FOLLOW_HamExtfingerir_in_extfidirtok14795); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerir431_tree = this.adaptor.create(HamExtfingerir431);
this.adaptor.addChild(root_0, HamExtfingerir431_tree);
}
// Ham4Parser.g:3908:13: ( HamExtfingerui | HamExtfingerdi )?
var alt166=2;
var LA166_0 = this.input.LA(1);
if ( ((LA166_0>=HamExtfingerui && LA166_0<=HamExtfingerdi)) ) {
alt166=1;
}
switch (alt166) {
case 1 :
// Ham4Parser.g:
set432=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerui && this.input.LA(1)<=HamExtfingerdi) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set432));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 15 :
// Ham4Parser.g:3913:9: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3913:9: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3914:13: HamExtfingerui ( HamExtfingeril | HamExtfingerir )?
HamExtfingerui433=this.match(this.input,HamExtfingerui,Ham4Parser.FOLLOW_HamExtfingerui_in_extfidirtok14894); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerui433_tree = this.adaptor.create(HamExtfingerui433);
this.adaptor.addChild(root_0, HamExtfingerui433_tree);
}
// Ham4Parser.g:3915:13: ( HamExtfingeril | HamExtfingerir )?
var alt167=2;
var LA167_0 = this.input.LA(1);
if ( (LA167_0==HamExtfingeril||LA167_0==HamExtfingerir) ) {
alt167=1;
}
switch (alt167) {
case 1 :
// Ham4Parser.g:
set434=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingeril||this.input.LA(1)==HamExtfingerir ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set434));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 16 :
// Ham4Parser.g:3920:9: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3920:9: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3921:13: HamExtfingerdi ( HamExtfingeril | HamExtfingerir )?
HamExtfingerdi435=this.match(this.input,HamExtfingerdi,Ham4Parser.FOLLOW_HamExtfingerdi_in_extfidirtok14993); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdi435_tree = this.adaptor.create(HamExtfingerdi435);
this.adaptor.addChild(root_0, HamExtfingerdi435_tree);
}
// Ham4Parser.g:3922:13: ( HamExtfingeril | HamExtfingerir )?
var alt168=2;
var LA168_0 = this.input.LA(1);
if ( (LA168_0==HamExtfingeril||LA168_0==HamExtfingerir) ) {
alt168=1;
}
switch (alt168) {
case 1 :
// Ham4Parser.g:
set436=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingeril||this.input.LA(1)==HamExtfingerir ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set436));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 17 :
// Ham4Parser.g:3927:9: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3927:9: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3928:13: HamExtfingerdo ( HamExtfingerol | HamExtfingeror )?
HamExtfingerdo437=this.match(this.input,HamExtfingerdo,Ham4Parser.FOLLOW_HamExtfingerdo_in_extfidirtok15092); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdo437_tree = this.adaptor.create(HamExtfingerdo437);
this.adaptor.addChild(root_0, HamExtfingerdo437_tree);
}
// Ham4Parser.g:3929:13: ( HamExtfingerol | HamExtfingeror )?
var alt169=2;
var LA169_0 = this.input.LA(1);
if ( (LA169_0==HamExtfingerol||LA169_0==HamExtfingeror) ) {
alt169=1;
}
switch (alt169) {
case 1 :
// Ham4Parser.g:
set438=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingerol||this.input.LA(1)==HamExtfingeror ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set438));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 18 :
// Ham4Parser.g:3934:9: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3934:9: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3935:13: HamExtfingeruo ( HamExtfingerol | HamExtfingeror )?
HamExtfingeruo439=this.match(this.input,HamExtfingeruo,Ham4Parser.FOLLOW_HamExtfingeruo_in_extfidirtok15191); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeruo439_tree = this.adaptor.create(HamExtfingeruo439);
this.adaptor.addChild(root_0, HamExtfingeruo439_tree);
}
// Ham4Parser.g:3936:13: ( HamExtfingerol | HamExtfingeror )?
var alt170=2;
var LA170_0 = this.input.LA(1);
if ( (LA170_0==HamExtfingerol||LA170_0==HamExtfingeror) ) {
alt170=1;
}
switch (alt170) {
case 1 :
// Ham4Parser.g:
set440=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingerol||this.input.LA(1)==HamExtfingeror ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set440));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidirtok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir_return: (function() {
Ham4Parser.extfidir_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3944:1: extfidir : extfidirtok -> ^( EXTFIDIR extfidirtok ) ;
// $ANTLR start "extfidir"
extfidir: function() {
var retval = new Ham4Parser.extfidir_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidirtok441 = null;
var stream_extfidirtok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidirtok");
try {
// Ham4Parser.g:3945:2: ( extfidirtok -> ^( EXTFIDIR extfidirtok ) )
// Ham4Parser.g:3945:4: extfidirtok
this.pushFollow(Ham4Parser.FOLLOW_extfidirtok_in_extfidir15286);
extfidirtok441=this.extfidirtok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidirtok.add(extfidirtok441.getTree());
// AST REWRITE
// elements: extfidirtok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3946:2: -> ^( EXTFIDIR extfidirtok )
{
// Ham4Parser.g:3946:5: ^( EXTFIDIR extfidirtok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR, "EXTFIDIR"), root_1);
this.adaptor.addChild(root_1, stream_extfidirtok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor_return: (function() {
Ham4Parser.palmor_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3949:1: palmor : ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul );
// $ANTLR start "palmor"
palmor: function() {
var retval = new Ham4Parser.palmor_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set442 = null;
var set442_tree=null;
this.trace("ANTLR Parse: palmor starts "+this.state.backtracking);
try {
// Ham4Parser.g:3970:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set442=this.input.LT(1);
if ( (this.input.LA(1)>=HamPalmu && this.input.LA(1)<=HamPalmul) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set442));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locarm_return: (function() {
Ham4Parser.locarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3983:1: locarm : ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm );
// $ANTLR start "locarm"
locarm: function() {
var retval = new Ham4Parser.locarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set443 = null;
var set443_tree=null;
this.trace("ANTLR Parse: locarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:4000:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set443=this.input.LT(1);
if ( (this.input.LA(1)>=HamUpperarm && this.input.LA(1)<=HamLowerarm) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set443));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locbodytok_return: (function() {
Ham4Parser.locbodytok_return = function(){};
org.antlr.lang.extend(Ham4Parser.locbodytok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4006:1: locbodytok : ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ;
// $ANTLR start "locbodytok"
locbodytok: function() {
var retval = new Ham4Parser.locbodytok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamHead444 = null;
var HamHeadtop445 = null;
var HamForehead446 = null;
var HamEyebrows447 = null;
var HamNose448 = null;
var HamNostrils449 = null;
var HamTongue450 = null;
var set451 = null;
var set452 = null;
var HamChin453 = null;
var HamUnderchin454 = null;
var HamNeck455 = null;
var HamShouldertop456 = null;
var HamShoulders457 = null;
var HamChest458 = null;
var HamStomach459 = null;
var HamBelowstomach460 = null;
var HamHead444_tree=null;
var HamHeadtop445_tree=null;
var HamForehead446_tree=null;
var HamEyebrows447_tree=null;
var HamNose448_tree=null;
var HamNostrils449_tree=null;
var HamTongue450_tree=null;
var set451_tree=null;
var set452_tree=null;
var HamChin453_tree=null;
var HamUnderchin454_tree=null;
var HamNeck455_tree=null;
var HamShouldertop456_tree=null;
var HamShoulders457_tree=null;
var HamChest458_tree=null;
var HamStomach459_tree=null;
var HamBelowstomach460_tree=null;
this.trace("ANTLR Parse: locbodytok starts "+this.state.backtracking);
try {
// Ham4Parser.g:4047:5: ( ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) )
// Ham4Parser.g:4048:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
root_0 = this.adaptor.nil();
// Ham4Parser.g:4048:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
var alt173=16;
alt173 = this.dfa173.predict(this.input);
switch (alt173) {
case 1 :
// Ham4Parser.g:4048:9: HamHead
HamHead444=this.match(this.input,HamHead,Ham4Parser.FOLLOW_HamHead_in_locbodytok15488); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamHead444_tree = this.adaptor.create(HamHead444);
this.adaptor.addChild(root_0, HamHead444_tree);
}
break;
case 2 :
// Ham4Parser.g:4049:9: HamHeadtop
HamHeadtop445=this.match(this.input,HamHeadtop,Ham4Parser.FOLLOW_HamHeadtop_in_locbodytok15498); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamHeadtop445_tree = this.adaptor.create(HamHeadtop445);
this.adaptor.addChild(root_0, HamHeadtop445_tree);
}
break;
case 3 :
// Ham4Parser.g:4050:9: HamForehead
HamForehead446=this.match(this.input,HamForehead,Ham4Parser.FOLLOW_HamForehead_in_locbodytok15508); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamForehead446_tree = this.adaptor.create(HamForehead446);
this.adaptor.addChild(root_0, HamForehead446_tree);
}
break;
case 4 :
// Ham4Parser.g:4051:9: HamEyebrows
HamEyebrows447=this.match(this.input,HamEyebrows,Ham4Parser.FOLLOW_HamEyebrows_in_locbodytok15518); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamEyebrows447_tree = this.adaptor.create(HamEyebrows447);
this.adaptor.addChild(root_0, HamEyebrows447_tree);
}
break;
case 5 :
// Ham4Parser.g:4052:9: HamNose
HamNose448=this.match(this.input,HamNose,Ham4Parser.FOLLOW_HamNose_in_locbodytok15528); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNose448_tree = this.adaptor.create(HamNose448);
this.adaptor.addChild(root_0, HamNose448_tree);
}
break;
case 6 :
// Ham4Parser.g:4053:9: HamNostrils
HamNostrils449=this.match(this.input,HamNostrils,Ham4Parser.FOLLOW_HamNostrils_in_locbodytok15538); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNostrils449_tree = this.adaptor.create(HamNostrils449);
this.adaptor.addChild(root_0, HamNostrils449_tree);
}
break;
case 7 :
// Ham4Parser.g:4054:9: HamTongue
HamTongue450=this.match(this.input,HamTongue,Ham4Parser.FOLLOW_HamTongue_in_locbodytok15548); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamTongue450_tree = this.adaptor.create(HamTongue450);
this.adaptor.addChild(root_0, HamTongue450_tree);
}
break;
case 8 :
// Ham4Parser.g:4055:9: ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? )
// Ham4Parser.g:4055:9: ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? )
// Ham4Parser.g:4056:13: ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )?
set451=this.input.LT(1);
if ( this.input.LA(1)==HamTeeth||this.input.LA(1)==HamEyes||this.input.LA(1)==HamLips ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set451));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:4061:13: ( HamDoublebent | HamDoublehooked )?
var alt172=2;
var LA172_0 = this.input.LA(1);
if ( ((LA172_0>=HamDoublebent && LA172_0<=HamDoublehooked)) ) {
alt172=1;
}
switch (alt172) {
case 1 :
// Ham4Parser.g:
set452=this.input.LT(1);
if ( (this.input.LA(1)>=HamDoublebent && this.input.LA(1)<=HamDoublehooked) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set452));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 9 :
// Ham4Parser.g:4066:9: HamChin
HamChin453=this.match(this.input,HamChin,Ham4Parser.FOLLOW_HamChin_in_locbodytok15725); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamChin453_tree = this.adaptor.create(HamChin453);
this.adaptor.addChild(root_0, HamChin453_tree);
}
break;
case 10 :
// Ham4Parser.g:4067:9: HamUnderchin
HamUnderchin454=this.match(this.input,HamUnderchin,Ham4Parser.FOLLOW_HamUnderchin_in_locbodytok15735); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamUnderchin454_tree = this.adaptor.create(HamUnderchin454);
this.adaptor.addChild(root_0, HamUnderchin454_tree);
}
break;
case 11 :
// Ham4Parser.g:4068:9: HamNeck
HamNeck455=this.match(this.input,HamNeck,Ham4Parser.FOLLOW_HamNeck_in_locbodytok15745); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNeck455_tree = this.adaptor.create(HamNeck455);
this.adaptor.addChild(root_0, HamNeck455_tree);
}
break;
case 12 :
// Ham4Parser.g:4069:9: HamShouldertop
HamShouldertop456=this.match(this.input,HamShouldertop,Ham4Parser.FOLLOW_HamShouldertop_in_locbodytok15755); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamShouldertop456_tree = this.adaptor.create(HamShouldertop456);
this.adaptor.addChild(root_0, HamShouldertop456_tree);
}
break;
case 13 :
// Ham4Parser.g:4070:9: HamShoulders
HamShoulders457=this.match(this.input,HamShoulders,Ham4Parser.FOLLOW_HamShoulders_in_locbodytok15765); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamShoulders457_tree = this.adaptor.create(HamShoulders457);
this.adaptor.addChild(root_0, HamShoulders457_tree);
}
break;
case 14 :
// Ham4Parser.g:4071:9: HamChest
HamChest458=this.match(this.input,HamChest,Ham4Parser.FOLLOW_HamChest_in_locbodytok15775); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamChest458_tree = this.adaptor.create(HamChest458);
this.adaptor.addChild(root_0, HamChest458_tree);
}
break;
case 15 :
// Ham4Parser.g:4072:9: HamStomach
HamStomach459=this.match(this.input,HamStomach,Ham4Parser.FOLLOW_HamStomach_in_locbodytok15785); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamStomach459_tree = this.adaptor.create(HamStomach459);
this.adaptor.addChild(root_0, HamStomach459_tree);
}
break;
case 16 :
// Ham4Parser.g:4073:9: HamBelowstomach
HamBelowstomach460=this.match(this.input,HamBelowstomach,Ham4Parser.FOLLOW_HamBelowstomach_in_locbodytok15795); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamBelowstomach460_tree = this.adaptor.create(HamBelowstomach460);
this.adaptor.addChild(root_0, HamBelowstomach460_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locbodytok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locbody_return: (function() {
Ham4Parser.locbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.locbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4077:1: locbody : locbodytok -> ^( LOCBODY locbodytok ) ;
// $ANTLR start "locbody"
locbody: function() {
var retval = new Ham4Parser.locbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var locbodytok461 = null;
var stream_locbodytok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locbodytok");
try {
// Ham4Parser.g:4078:2: ( locbodytok -> ^( LOCBODY locbodytok ) )
// Ham4Parser.g:4078:4: locbodytok
this.pushFollow(Ham4Parser.FOLLOW_locbodytok_in_locbody15815);
locbodytok461=this.locbodytok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbodytok.add(locbodytok461.getTree());
// AST REWRITE
// elements: locbodytok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 4079:4: -> ^( LOCBODY locbodytok )
{
// Ham4Parser.g:4079:7: ^( LOCBODY locbodytok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCBODY, "LOCBODY"), root_1);
this.adaptor.addChild(root_1, stream_locbodytok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locsided_return: (function() {
Ham4Parser.locsided_return = function(){};
org.antlr.lang.extend(Ham4Parser.locsided_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4082:1: locsided : ( HamEar | HamEarlobe | HamCheek );
// $ANTLR start "locsided"
locsided: function() {
var retval = new Ham4Parser.locsided_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set462 = null;
var set462_tree=null;
this.trace("ANTLR Parse: locsided starts "+this.state.backtracking);
try {
// Ham4Parser.g:4098:5: ( HamEar | HamEarlobe | HamCheek )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set462=this.input.LT(1);
if ( this.input.LA(1)==HamEarlobe||(this.input.LA(1)>=HamEar && this.input.LA(1)<=HamCheek) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set462));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locsided finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handpart_return: (function() {
Ham4Parser.handpart_return = function(){};
org.antlr.lang.extend(Ham4Parser.handpart_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4103:1: handpart : ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside );
// $ANTLR start "handpart"
handpart: function() {
var retval = new Ham4Parser.handpart_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set463 = null;
var set463_tree=null;
this.trace("ANTLR Parse: handpart starts "+this.state.backtracking);
try {
// Ham4Parser.g:4123:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set463=this.input.LT(1);
if ( (this.input.LA(1)>=HamWristback && this.input.LA(1)<=HamHandback)||(this.input.LA(1)>=HamThumbside && this.input.LA(1)<=HamPinkyside) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set463));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handpart finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
side_return: (function() {
Ham4Parser.side_return = function(){};
org.antlr.lang.extend(Ham4Parser.side_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4132:1: side : ( HamLrbeside | HamLrat );
// $ANTLR start "side"
side: function() {
var retval = new Ham4Parser.side_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set464 = null;
var set464_tree=null;
this.trace("ANTLR Parse: side starts "+this.state.backtracking);
try {
// Ham4Parser.g:4147:5: ( HamLrbeside | HamLrat )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set464=this.input.LT(1);
if ( (this.input.LA(1)>=HamLrbeside && this.input.LA(1)<=HamLrat) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set464));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: side finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
dorsalorpalmar_return: (function() {
Ham4Parser.dorsalorpalmar_return = function(){};
org.antlr.lang.extend(Ham4Parser.dorsalorpalmar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4151:1: dorsalorpalmar : ( HamHandback | HamPalm );
// $ANTLR start "dorsalorpalmar"
dorsalorpalmar: function() {
var retval = new Ham4Parser.dorsalorpalmar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set465 = null;
var set465_tree=null;
this.trace("ANTLR Parse: dorsalorpalmar starts "+this.state.backtracking);
try {
// Ham4Parser.g:4166:5: ( HamHandback | HamPalm )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set465=this.input.LT(1);
if ( (this.input.LA(1)>=HamPalm && this.input.LA(1)<=HamHandback) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set465));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: dorsalorpalmar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
pcontact_return: (function() {
Ham4Parser.pcontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.pcontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4170:1: pcontact : ( HamTouch | HamClose );
// $ANTLR start "pcontact"
pcontact: function() {
var retval = new Ham4Parser.pcontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set466 = null;
var set466_tree=null;
this.trace("ANTLR Parse: pcontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:4185:5: ( HamTouch | HamClose )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set466=this.input.LT(1);
if ( (this.input.LA(1)>=HamClose && this.input.LA(1)<=HamTouch) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set466));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: pcontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ccontact_return: (function() {
Ham4Parser.ccontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.ccontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4189:1: ccontact : ( HamInterlock | HamCross );
// $ANTLR start "ccontact"
ccontact: function() {
var retval = new Ham4Parser.ccontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set467 = null;
var set467_tree=null;
this.trace("ANTLR Parse: ccontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:4204:5: ( HamInterlock | HamCross )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set467=this.input.LT(1);
if ( (this.input.LA(1)>=HamInterlock && this.input.LA(1)<=HamCross) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set467));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ccontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sizechange_return: (function() {
Ham4Parser.sizechange_return = function(){};
org.antlr.lang.extend(Ham4Parser.sizechange_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4211:1: sizechange : ( HamIncreasing | HamDecreasing );
// $ANTLR start "sizechange"
sizechange: function() {
var retval = new Ham4Parser.sizechange_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set468 = null;
var set468_tree=null;
this.trace("ANTLR Parse: sizechange starts "+this.state.backtracking);
try {
// Ham4Parser.g:4226:5: ( HamIncreasing | HamDecreasing )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set468=this.input.LT(1);
if ( (this.input.LA(1)>=HamIncreasing && this.input.LA(1)<=HamDecreasing) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set468));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sizechange finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetition_return: (function() {
Ham4Parser.repetition_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetition_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4230:1: repetition : ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse );
// $ANTLR start "repetition"
repetition: function() {
var retval = new Ham4Parser.repetition_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set469 = null;
var set469_tree=null;
this.trace("ANTLR Parse: repetition starts "+this.state.backtracking);
try {
// Ham4Parser.g:4248:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set469=this.input.LT(1);
if ( (this.input.LA(1)>=HamRepeatfromstart && this.input.LA(1)<=HamRepeatcontinueseveral)||this.input.LA(1)==HamRepeatreverse ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set469));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetition finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementarrow_return: (function() {
Ham4Parser.movementarrow_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementarrow_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4255:1: movementarrow : ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo );
// $ANTLR start "movementarrow"
movementarrow: function() {
var retval = new Ham4Parser.movementarrow_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set470 = null;
var set470_tree=null;
this.trace("ANTLR Parse: movementarrow starts "+this.state.backtracking);
try {
// Ham4Parser.g:4286:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set470=this.input.LT(1);
if ( (this.input.LA(1)>=HamMoveu && this.input.LA(1)<=HamMoveuo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set470));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementarrow finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementcross_return: (function() {
Ham4Parser.movementcross_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementcross_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4306:1: movementcross : ( HamMovecross | HamMovex );
// $ANTLR start "movementcross"
movementcross: function() {
var retval = new Ham4Parser.movementcross_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set471 = null;
var set471_tree=null;
this.trace("ANTLR Parse: movementcross starts "+this.state.backtracking);
try {
// Ham4Parser.g:4321:5: ( HamMovecross | HamMovex )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set471=this.input.LT(1);
if ( (this.input.LA(1)>=HamMovecross && this.input.LA(1)<=HamMovex) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set471));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementcross finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
wristmovement_return: (function() {
Ham4Parser.wristmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.wristmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4325:1: wristmovement : ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw );
// $ANTLR start "wristmovement"
wristmovement: function() {
var retval = new Ham4Parser.wristmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set472 = null;
var set472_tree=null;
this.trace("ANTLR Parse: wristmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:4343:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set472=this.input.LT(1);
if ( (this.input.LA(1)>=HamNodding && this.input.LA(1)<=HamStirccw) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set472));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: wristmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementcircle_return: (function() {
Ham4Parser.movementcircle_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementcircle_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4350:1: movementcircle : ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo );
// $ANTLR start "movementcircle"
movementcircle: function() {
var retval = new Ham4Parser.movementcircle_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set473 = null;
var set473_tree=null;
this.trace("ANTLR Parse: movementcircle starts "+this.state.backtracking);
try {
// Ham4Parser.g:4381:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set473=this.input.LT(1);
if ( (this.input.LA(1)>=HamCircleo && this.input.LA(1)<=HamCircler)||(this.input.LA(1)>=HamCircleul && this.input.LA(1)<=HamCircleuo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set473));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementcircle finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ellipsedirection_return: (function() {
Ham4Parser.ellipsedirection_return = function(){};
org.antlr.lang.extend(Ham4Parser.ellipsedirection_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4401:1: ellipsedirection : ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul );
// $ANTLR start "ellipsedirection"
ellipsedirection: function() {
var retval = new Ham4Parser.ellipsedirection_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set474 = null;
var set474_tree=null;
this.trace("ANTLR Parse: ellipsedirection starts "+this.state.backtracking);
try {
// Ham4Parser.g:4418:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set474=this.input.LT(1);
if ( (this.input.LA(1)>=HamEllipseh && this.input.LA(1)<=HamEllipseul) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set474));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ellipsedirection finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
clock_return: (function() {
Ham4Parser.clock_return = function(){};
org.antlr.lang.extend(Ham4Parser.clock_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4424:1: clock : ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur );
// $ANTLR start "clock"
clock: function() {
var retval = new Ham4Parser.clock_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set475 = null;
var set475_tree=null;
this.trace("ANTLR Parse: clock starts "+this.state.backtracking);
try {
// Ham4Parser.g:4445:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set475=this.input.LT(1);
if ( (this.input.LA(1)>=HamClocku && this.input.LA(1)<=HamClockur) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set475));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: clock finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
modifier_return: (function() {
Ham4Parser.modifier_return = function(){};
org.antlr.lang.extend(Ham4Parser.modifier_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4455:1: modifier : ( HamFast | HamSlow | HamTense | HamRest | HamHalt );
// $ANTLR start "modifier"
modifier: function() {
var retval = new Ham4Parser.modifier_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set476 = null;
var set476_tree=null;
this.trace("ANTLR Parse: modifier starts "+this.state.backtracking);
try {
// Ham4Parser.g:4473:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set476=this.input.LT(1);
if ( (this.input.LA(1)>=HamFast && this.input.LA(1)<=HamHalt) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set476));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: modifier finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
arc_return: (function() {
Ham4Parser.arc_return = function(){};
org.antlr.lang.extend(Ham4Parser.arc_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4480:1: arc : ( HamArcl | HamArcu | HamArcr | HamArcd );
// $ANTLR start "arc"
arc: function() {
var retval = new Ham4Parser.arc_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set477 = null;
var set477_tree=null;
this.trace("ANTLR Parse: arc starts "+this.state.backtracking);
try {
// Ham4Parser.g:4497:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set477=this.input.LT(1);
if ( (this.input.LA(1)>=HamArcl && this.input.LA(1)<=HamArcd) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set477));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: arc finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
size_return: (function() {
Ham4Parser.size_return = function(){};
org.antlr.lang.extend(Ham4Parser.size_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4503:1: size : ( HamSmallmod | HamLargemod );
// $ANTLR start "size"
size: function() {
var retval = new Ham4Parser.size_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set478 = null;
var set478_tree=null;
this.trace("ANTLR Parse: size starts "+this.state.backtracking);
try {
// Ham4Parser.g:4518:5: ( HamSmallmod | HamLargemod )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set478=this.input.LT(1);
if ( (this.input.LA(1)>=HamSmallmod && this.input.LA(1)<=HamLargemod) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set478));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: size finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// $ANTLR start "synpred1_Ham4Parser"
synpred1_Ham4Parser_fragment: function() {
// Ham4Parser.g:253:9: ( HamNondominant initialconfig1 )
// Ham4Parser.g:253:11: HamNondominant initialconfig1
this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_synpred1_Ham4Parser928); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_synpred1_Ham4Parser930);
this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred1_Ham4Parser",
// $ANTLR start "synpred2_Ham4Parser"
synpred2_Ham4Parser_fragment: function() {
// Ham4Parser.g:322:9: ( HamNomotion HamNondominant initialconfig1 )
// Ham4Parser.g:322:11: HamNomotion HamNondominant initialconfig1
this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_synpred2_Ham4Parser1112); if (this.state.failed) return ;
this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_synpred2_Ham4Parser1114); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_synpred2_Ham4Parser1116);
this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred2_Ham4Parser",
// $ANTLR start "synpred3_Ham4Parser"
synpred3_Ham4Parser_fragment: function() {
// Ham4Parser.g:504:11: ( levelbody )
// Ham4Parser.g:504:13: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred3_Ham4Parser1806);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred3_Ham4Parser",
// $ANTLR start "synpred4_Ham4Parser"
synpred4_Ham4Parser_fragment: function() {
// Ham4Parser.g:561:9: ( handconfig2 )
// Ham4Parser.g:561:11: handconfig2
this.pushFollow(Ham4Parser.FOLLOW_handconfig2_in_synpred4_Ham4Parser1943);
this.handconfig2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred4_Ham4Parser",
// $ANTLR start "synpred5_Ham4Parser"
synpred5_Ham4Parser_fragment: function() {
// Ham4Parser.g:565:13: ( location2 )
// Ham4Parser.g:565:15: location2
this.pushFollow(Ham4Parser.FOLLOW_location2_in_synpred5_Ham4Parser1991);
this.location2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred5_Ham4Parser",
// $ANTLR start "synpred6_Ham4Parser"
synpred6_Ham4Parser_fragment: function() {
// Ham4Parser.g:574:13: ( HamPlus )
// Ham4Parser.g:574:15: HamPlus
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred6_Ham4Parser2101); if (this.state.failed) return ;
},
// $ANTLR end "synpred6_Ham4Parser",
// $ANTLR start "synpred7_Ham4Parser"
synpred7_Ham4Parser_fragment: function() {
// Ham4Parser.g:651:9: ( handshape2 ( HamParbegin )? extfidir1 )
// Ham4Parser.g:651:11: handshape2 ( HamParbegin )? extfidir1
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_synpred7_Ham4Parser2414);
this.handshape2();
this.state._fsp--;
if (this.state.failed) return ;
// Ham4Parser.g:651:22: ( HamParbegin )?
var alt174=2;
var LA174_0 = this.input.LA(1);
if ( (LA174_0==HamParbegin) ) {
alt174=1;
}
switch (alt174) {
case 1 :
// Ham4Parser.g:651:24: HamParbegin
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred7_Ham4Parser2418); if (this.state.failed) return ;
break;
}
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_synpred7_Ham4Parser2423);
this.extfidir1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred7_Ham4Parser",
// $ANTLR start "synpred8_Ham4Parser"
synpred8_Ham4Parser_fragment: function() {
// Ham4Parser.g:657:9: ( handshape2 )
// Ham4Parser.g:657:11: handshape2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_synpred8_Ham4Parser2488);
this.handshape2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred8_Ham4Parser",
// $ANTLR start "synpred9_Ham4Parser"
synpred9_Ham4Parser_fragment: function() {
// Ham4Parser.g:760:9: ( extfidir2 )
// Ham4Parser.g:760:11: extfidir2
this.pushFollow(Ham4Parser.FOLLOW_extfidir2_in_synpred9_Ham4Parser2805);
this.extfidir2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred9_Ham4Parser",
// $ANTLR start "synpred10_Ham4Parser"
synpred10_Ham4Parser_fragment: function() {
// Ham4Parser.g:869:13: ( ( hsfingeritem )+ HamBetween finger )
// Ham4Parser.g:869:15: ( hsfingeritem )+ HamBetween finger
// Ham4Parser.g:869:15: ( hsfingeritem )+
var cnt175=0;
loop175:
do {
var alt175=2;
var LA175_0 = this.input.LA(1);
if ( ((LA175_0>=HamIndexfinger && LA175_0<=HamPinky)) ) {
alt175=1;
}
switch (alt175) {
case 1 :
// Ham4Parser.g:869:17: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred10_Ham4Parser3168);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt175 >= 1 ) {
break loop175;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(175, this.input);
throw eee;
}
cnt175++;
} while (true);
this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_synpred10_Ham4Parser3173); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_finger_in_synpred10_Ham4Parser3175);
this.finger();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred10_Ham4Parser",
// $ANTLR start "synpred11_Ham4Parser"
synpred11_Ham4Parser_fragment: function() {
// Ham4Parser.g:877:13: ( ( hsdigit )* ( fingerbending | fingerpart ) )
// Ham4Parser.g:877:15: ( hsdigit )* ( fingerbending | fingerpart )
// Ham4Parser.g:877:15: ( hsdigit )*
loop176:
do {
var alt176=2;
var LA176_0 = this.input.LA(1);
if ( ((LA176_0>=HamThumb && LA176_0<=HamPinky)) ) {
alt176=1;
}
switch (alt176) {
case 1 :
// Ham4Parser.g:877:17: hsdigit
this.pushFollow(Ham4Parser.FOLLOW_hsdigit_in_synpred11_Ham4Parser3282);
this.hsdigit();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
break loop176;
}
} while (true);
// Ham4Parser.g:877:28: ( fingerbending | fingerpart )
var alt177=2;
var LA177_0 = this.input.LA(1);
if ( ((LA177_0>=HamFingerstraightmod && LA177_0<=HamFingerhookedmod)||(LA177_0>=HamDoublebent && LA177_0<=HamDoublehooked)) ) {
alt177=1;
}
else if ( ((LA177_0>=HamFingertip && LA177_0<=HamFingerside)) ) {
alt177=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 177, 0, this.input);
throw nvae;
}
switch (alt177) {
case 1 :
// Ham4Parser.g:877:30: fingerbending
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_synpred11_Ham4Parser3289);
this.fingerbending();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:877:46: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_synpred11_Ham4Parser3293);
this.fingerpart();
this.state._fsp--;
if (this.state.failed) return ;
break;
}
},
// $ANTLR end "synpred11_Ham4Parser",
// $ANTLR start "synpred12_Ham4Parser"
synpred12_Ham4Parser_fragment: function() {
// Ham4Parser.g:882:15: ( thumbspecial )
// Ham4Parser.g:882:17: thumbspecial
this.pushFollow(Ham4Parser.FOLLOW_thumbspecial_in_synpred12_Ham4Parser3371);
this.thumbspecial();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred12_Ham4Parser",
// $ANTLR start "synpred13_Ham4Parser"
synpred13_Ham4Parser_fragment: function() {
// Ham4Parser.g:885:13: ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )
// Ham4Parser.g:885:15: ( hsfingeritem )* ( thumbbetweendefault | thumbextra )
// Ham4Parser.g:885:15: ( hsfingeritem )*
loop178:
do {
var alt178=2;
var LA178_0 = this.input.LA(1);
if ( ((LA178_0>=HamIndexfinger && LA178_0<=HamPinky)) ) {
alt178=1;
}
switch (alt178) {
case 1 :
// Ham4Parser.g:885:17: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred13_Ham4Parser3415);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
break loop178;
}
} while (true);
// Ham4Parser.g:885:33: ( thumbbetweendefault | thumbextra )
var alt179=2;
var LA179_0 = this.input.LA(1);
if ( (LA179_0==HamBetween) ) {
alt179=1;
}
else if ( (LA179_0==HamThumb||(LA179_0>=HamFingertip && LA179_0<=HamFingerside)) ) {
alt179=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 179, 0, this.input);
throw nvae;
}
switch (alt179) {
case 1 :
// Ham4Parser.g:885:35: thumbbetweendefault
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_synpred13_Ham4Parser3422);
this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:885:57: thumbextra
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_synpred13_Ham4Parser3426);
this.thumbextra();
this.state._fsp--;
if (this.state.failed) return ;
break;
}
},
// $ANTLR end "synpred13_Ham4Parser",
// $ANTLR start "synpred14_Ham4Parser"
synpred14_Ham4Parser_fragment: function() {
// Ham4Parser.g:927:13: ( HamBetween handshapeclass )
// Ham4Parser.g:927:15: HamBetween handshapeclass
this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_synpred14_Ham4Parser3680); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_handshapeclass_in_synpred14_Ham4Parser3682);
this.handshapeclass();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred14_Ham4Parser",
// $ANTLR start "synpred15_Ham4Parser"
synpred15_Ham4Parser_fragment: function() {
// Ham4Parser.g:1036:13: ( hsfingeritem )
// Ham4Parser.g:1036:15: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred15_Ham4Parser4086);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred15_Ham4Parser",
// $ANTLR start "synpred16_Ham4Parser"
synpred16_Ham4Parser_fragment: function() {
// Ham4Parser.g:1084:13: ( hsfingeritem digit )
// Ham4Parser.g:1084:15: hsfingeritem digit
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred16_Ham4Parser4241);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_digit_in_synpred16_Ham4Parser4243);
this.digit();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred16_Ham4Parser",
// $ANTLR start "synpred17_Ham4Parser"
synpred17_Ham4Parser_fragment: function() {
// Ham4Parser.g:1132:13: ( fingershape )
// Ham4Parser.g:1132:15: fingershape
this.pushFollow(Ham4Parser.FOLLOW_fingershape_in_synpred17_Ham4Parser4401);
this.fingershape();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred17_Ham4Parser",
// $ANTLR start "synpred18_Ham4Parser"
synpred18_Ham4Parser_fragment: function() {
// Ham4Parser.g:1180:13: ( fingercrossing )
// Ham4Parser.g:1180:15: fingercrossing
this.pushFollow(Ham4Parser.FOLLOW_fingercrossing_in_synpred18_Ham4Parser4556);
this.fingercrossing();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred18_Ham4Parser",
// $ANTLR start "synpred19_Ham4Parser"
synpred19_Ham4Parser_fragment: function() {
// Ham4Parser.g:1677:9: ( handconstellation )
// Ham4Parser.g:1677:11: handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_synpred19_Ham4Parser5989);
this.handconstellation();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred19_Ham4Parser",
// $ANTLR start "synpred20_Ham4Parser"
synpred20_Ham4Parser_fragment: function() {
// Ham4Parser.g:1725:9: ( locationindexuse )
// Ham4Parser.g:1725:11: locationindexuse
this.pushFollow(Ham4Parser.FOLLOW_locationindexuse_in_synpred20_Ham4Parser6231);
this.locationindexuse();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred20_Ham4Parser",
// $ANTLR start "synpred21_Ham4Parser"
synpred21_Ham4Parser_fragment: function() {
// Ham4Parser.g:1729:9: ( levelhand )
// Ham4Parser.g:1729:11: levelhand
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_synpred21_Ham4Parser6291);
this.levelhand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred21_Ham4Parser",
// $ANTLR start "synpred22_Ham4Parser"
synpred22_Ham4Parser_fragment: function() {
// Ham4Parser.g:1810:9: ( levelbody )
// Ham4Parser.g:1810:11: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred22_Ham4Parser6522);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred22_Ham4Parser",
// $ANTLR start "synpred23_Ham4Parser"
synpred23_Ham4Parser_fragment: function() {
// Ham4Parser.g:1839:11: ( contactbody )
// Ham4Parser.g:1839:13: contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_synpred23_Ham4Parser6643);
this.contactbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred23_Ham4Parser",
// $ANTLR start "synpred24_Ham4Parser"
synpred24_Ham4Parser_fragment: function() {
// Ham4Parser.g:1862:11: ( contacthand )
// Ham4Parser.g:1862:12: contacthand
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_synpred24_Ham4Parser6723);
this.contacthand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred24_Ham4Parser",
// $ANTLR start "synpred25_Ham4Parser"
synpred25_Ham4Parser_fragment: function() {
// Ham4Parser.g:1887:11: ( contactbody )
// Ham4Parser.g:1887:13: contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_synpred25_Ham4Parser6815);
this.contactbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred25_Ham4Parser",
// $ANTLR start "synpred26_Ham4Parser"
synpred26_Ham4Parser_fragment: function() {
// Ham4Parser.g:2245:13: ( levelhand )
// Ham4Parser.g:2245:15: levelhand
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_synpred26_Ham4Parser8193);
this.levelhand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred26_Ham4Parser",
// $ANTLR start "synpred27_Ham4Parser"
synpred27_Ham4Parser_fragment: function() {
// Ham4Parser.g:2476:9: ( action1 location2not1 )
// Ham4Parser.g:2476:11: action1 location2not1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred27_Ham4Parser8814);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_synpred27_Ham4Parser8816);
this.location2not1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred27_Ham4Parser",
// $ANTLR start "synpred28_Ham4Parser"
synpred28_Ham4Parser_fragment: function() {
// Ham4Parser.g:2483:9: ( action1t )
// Ham4Parser.g:2483:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_synpred28_Ham4Parser8894);
this.action1t();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred28_Ham4Parser",
// $ANTLR start "synpred29_Ham4Parser"
synpred29_Ham4Parser_fragment: function() {
// Ham4Parser.g:2489:13: ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )
// Ham4Parser.g:2489:15: HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred29_Ham4Parser8961); if (this.state.failed) return ;
// Ham4Parser.g:2489:27: ( action1 )+
var cnt180=0;
loop180:
do {
var alt180=2;
alt180 = this.dfa180.predict(this.input);
switch (alt180) {
case 1 :
// Ham4Parser.g:2489:29: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred29_Ham4Parser8965);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt180 >= 1 ) {
break loop180;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(180, this.input);
throw eee;
}
cnt180++;
} while (true);
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred29_Ham4Parser8970); if (this.state.failed) return ;
// Ham4Parser.g:2490:15: ( action1 )+
var cnt181=0;
loop181:
do {
var alt181=2;
alt181 = this.dfa181.predict(this.input);
switch (alt181) {
case 1 :
// Ham4Parser.g:2490:17: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred29_Ham4Parser8988);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt181 >= 1 ) {
break loop181;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(181, this.input);
throw eee;
}
cnt181++;
} while (true);
this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_synpred29_Ham4Parser8993); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_location2_in_synpred29_Ham4Parser8995);
this.location2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred29_Ham4Parser",
// $ANTLR start "synpred30_Ham4Parser"
synpred30_Ham4Parser_fragment: function() {
// Ham4Parser.g:2494:13: ( HamParbegin ( action1t )+ HamPlus )
// Ham4Parser.g:2494:15: HamParbegin ( action1t )+ HamPlus
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred30_Ham4Parser9051); if (this.state.failed) return ;
// Ham4Parser.g:2494:27: ( action1t )+
var cnt182=0;
loop182:
do {
var alt182=2;
alt182 = this.dfa182.predict(this.input);
switch (alt182) {
case 1 :
// Ham4Parser.g:2494:29: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_synpred30_Ham4Parser9055);
this.action1t();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt182 >= 1 ) {
break loop182;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(182, this.input);
throw eee;
}
cnt182++;
} while (true);
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred30_Ham4Parser9060); if (this.state.failed) return ;
},
// $ANTLR end "synpred30_Ham4Parser",
// $ANTLR start "synpred31_Ham4Parser"
synpred31_Ham4Parser_fragment: function() {
// Ham4Parser.g:2554:13: ( action1 )
// Ham4Parser.g:2554:15: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred31_Ham4Parser9268);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred31_Ham4Parser",
// $ANTLR start "synpred32_Ham4Parser"
synpred32_Ham4Parser_fragment: function() {
// Ham4Parser.g:2559:21: ( handconstellation )
// Ham4Parser.g:2559:23: handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_synpred32_Ham4Parser9358);
this.handconstellation();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred32_Ham4Parser",
// $ANTLR start "synpred33_Ham4Parser"
synpred33_Ham4Parser_fragment: function() {
// Ham4Parser.g:2635:9: ( HamSeqbegin digit )
// Ham4Parser.g:2635:11: HamSeqbegin digit
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred33_Ham4Parser9858); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_digit_in_synpred33_Ham4Parser9860);
this.digit();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred33_Ham4Parser",
// $ANTLR start "synpred34_Ham4Parser"
synpred34_Ham4Parser_fragment: function() {
// Ham4Parser.g:2857:6: ( levelbody )
// Ham4Parser.g:2857:8: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred34_Ham4Parser10615);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred34_Ham4Parser",
// $ANTLR start "synpred35_Ham4Parser"
synpred35_Ham4Parser_fragment: function() {
// Ham4Parser.g:3000:13: ( ( HamSeqbegin )? repetition | HamAlternatingmotion )
var alt184=2;
var LA184_0 = this.input.LA(1);
if ( ((LA184_0>=HamRepeatfromstart && LA184_0<=HamSeqbegin)||LA184_0==HamRepeatreverse) ) {
alt184=1;
}
else if ( (LA184_0==HamAlternatingmotion) ) {
alt184=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);
throw nvae;
}
switch (alt184) {
case 1 :
// Ham4Parser.g:3000:15: ( HamSeqbegin )? repetition
// Ham4Parser.g:3000:15: ( HamSeqbegin )?
var alt183=2;
var LA183_0 = this.input.LA(1);
if ( (LA183_0==HamSeqbegin) ) {
alt183=1;
}
switch (alt183) {
case 1 :
// Ham4Parser.g:3000:17: HamSeqbegin
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred35_Ham4Parser11115); if (this.state.failed) return ;
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_synpred35_Ham4Parser11120);
this.repetition();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:3000:45: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_synpred35_Ham4Parser11124); if (this.state.failed) return ;
break;
}},
// $ANTLR end "synpred35_Ham4Parser",
// $ANTLR start "synpred36_Ham4Parser"
synpred36_Ham4Parser_fragment: function() {
// Ham4Parser.g:3053:9: ( HamSeqbegin HamRepeatfromstartseveral HamEtc )
// Ham4Parser.g:3053:11: HamSeqbegin HamRepeatfromstartseveral HamEtc
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred36_Ham4Parser11208); if (this.state.failed) return ;
this.match(this.input,HamRepeatfromstartseveral,Ham4Parser.FOLLOW_HamRepeatfromstartseveral_in_synpred36_Ham4Parser11210); if (this.state.failed) return ;
this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_synpred36_Ham4Parser11212); if (this.state.failed) return ;
},
// $ANTLR end "synpred36_Ham4Parser",
// $ANTLR start "synpred37_Ham4Parser"
synpred37_Ham4Parser_fragment: function() {
// Ham4Parser.g:3222:11: ( HamSeqbegin HamBrushing )
// Ham4Parser.g:3222:13: HamSeqbegin HamBrushing
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred37_Ham4Parser12166); if (this.state.failed) return ;
this.match(this.input,HamBrushing,Ham4Parser.FOLLOW_HamBrushing_in_synpred37_Ham4Parser12168); if (this.state.failed) return ;
},
// $ANTLR end "synpred37_Ham4Parser",
// $ANTLR start "synpred38_Ham4Parser"
synpred38_Ham4Parser_fragment: function() {
// Ham4Parser.g:3227:11: ( locationindexdefine )
// Ham4Parser.g:3227:13: locationindexdefine
this.pushFollow(Ham4Parser.FOLLOW_locationindexdefine_in_synpred38_Ham4Parser12263);
this.locationindexdefine();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred38_Ham4Parser",
// $ANTLR start "synpred39_Ham4Parser"
synpred39_Ham4Parser_fragment: function() {
// Ham4Parser.g:3493:17: ( splitreplacetail )
// Ham4Parser.g:3493:19: splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_synpred39_Ham4Parser13219);
this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred39_Ham4Parser"
// Delegated rules
synpred6_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred6_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred19_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred19_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred22_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred22_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred12_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred12_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred9_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred9_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred3_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred3_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred16_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred16_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred26_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred26_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred36_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred36_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred28_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred28_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred32_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred32_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred31_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred31_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred5_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred5_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred21_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred21_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred38_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred38_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred11_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred11_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred15_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred15_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred25_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred25_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred39_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred39_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred35_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred35_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred2_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred2_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred29_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred29_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred37_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred37_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred14_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred14_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred17_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred17_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred20_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred20_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred10_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred10_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred34_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred34_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred24_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred24_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred30_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred30_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred1_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred1_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred7_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred7_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred18_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred18_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred23_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred23_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred13_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred13_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred8_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred8_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred4_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred4_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred27_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred27_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred33_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred33_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
}
}, true); // important to pass true to overwrite default implementations
org.antlr.lang.augmentObject(Ham4Parser, {
DFA13_eotS:
"\u0014\uffff",
DFA13_eofS:
"\u0014\uffff",
DFA13_minS:
"\u0001\u0043\u0011\uffff\u0001\u0000\u0001\uffff",
DFA13_maxS:
"\u0001\u006b\u0011\uffff\u0001\u0000\u0001\uffff",
DFA13_acceptS:
"\u0001\uffff\u0011\u0001\u0001\uffff\u0001\u0002",
DFA13_specialS:
"\u0001\u0000\u0011\uffff\u0001\u0001\u0001\uffff}>",
DFA13_transitionS: [
"\u0001\u0011\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007"+
"\u0001\u0008\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002"+
"\u0001\u0003\u0001\u0004\u0001\u0008\u0001\u0005\u0002\u0011"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d"+
"\u0001\u000e\u0001\u0010\u0002\u0012\u0004\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA13_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_eotS),
DFA13_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_eofS),
DFA13_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA13_minS),
DFA13_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA13_maxS),
DFA13_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_acceptS),
DFA13_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_specialS),
DFA13_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA13_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA13 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 13;
this.eot = Ham4Parser.DFA13_eot;
this.eof = Ham4Parser.DFA13_eof;
this.min = Ham4Parser.DFA13_min;
this.max = Ham4Parser.DFA13_max;
this.accept = Ham4Parser.DFA13_accept;
this.special = Ham4Parser.DFA13_special;
this.transition = Ham4Parser.DFA13_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA13, org.antlr.runtime.DFA, {
getDescription: function() {
return "503:9: ( ( levelbody )=> levelbody | levelarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA13_0 = input.LA(1);
var index13_0 = input.index();
input.rewind();
s = -1;
if ( (LA13_0==HamHead) && (this.synpred3_Ham4Parser())) {s = 1;}
else if ( (LA13_0==HamHeadtop) && (this.synpred3_Ham4Parser())) {s = 2;}
else if ( (LA13_0==HamForehead) && (this.synpred3_Ham4Parser())) {s = 3;}
else if ( (LA13_0==HamEyebrows) && (this.synpred3_Ham4Parser())) {s = 4;}
else if ( (LA13_0==HamNose) && (this.synpred3_Ham4Parser())) {s = 5;}
else if ( (LA13_0==HamNostrils) && (this.synpred3_Ham4Parser())) {s = 6;}
else if ( (LA13_0==HamTongue) && (this.synpred3_Ham4Parser())) {s = 7;}
else if ( (LA13_0==HamTeeth||LA13_0==HamEyes||LA13_0==HamLips) && (this.synpred3_Ham4Parser())) {s = 8;}
else if ( (LA13_0==HamChin) && (this.synpred3_Ham4Parser())) {s = 9;}
else if ( (LA13_0==HamUnderchin) && (this.synpred3_Ham4Parser())) {s = 10;}
else if ( (LA13_0==HamNeck) && (this.synpred3_Ham4Parser())) {s = 11;}
else if ( (LA13_0==HamShouldertop) && (this.synpred3_Ham4Parser())) {s = 12;}
else if ( (LA13_0==HamShoulders) && (this.synpred3_Ham4Parser())) {s = 13;}
else if ( (LA13_0==HamChest) && (this.synpred3_Ham4Parser())) {s = 14;}
else if ( (LA13_0==HamStomach) && (this.synpred3_Ham4Parser())) {s = 15;}
else if ( (LA13_0==HamBelowstomach) && (this.synpred3_Ham4Parser())) {s = 16;}
else if ( (LA13_0==HamEarlobe||(LA13_0>=HamEar && LA13_0<=HamCheek)) && (this.synpred3_Ham4Parser())) {s = 17;}
else if ( ((LA13_0>=HamLrbeside && LA13_0<=HamLrat)) ) {s = 18;}
else if ( ((LA13_0>=HamUpperarm && LA13_0<=HamLowerarm)) ) {s = 19;}
input.seek(index13_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA13_18 = input.LA(1);
var index13_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred3_Ham4Parser()) ) {s = 17;}
else if ( (true) ) {s = 19;}
input.seek(index13_18);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 13, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA14_eotS:
"\u0027\uffff",
DFA14_eofS:
"\u0001\u001d\u0026\uffff",
DFA14_minS:
"\u0001\u000f\u0018\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u000a"+
"\uffff",
DFA14_maxS:
"\u0001\u00d9\u0018\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u000a"+
"\uffff",
DFA14_acceptS:
"\u0001\uffff\u0018\u0001\u0001\uffff\u0002\u0001\u0001\uffff\u0001"+
"\u0002\u0009\uffff",
DFA14_specialS:
"\u0001\u0000\u0018\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u000a"+
"\uffff}>",
DFA14_transitionS: [
"\u0001\u001d\u0033\uffff\u0001\u0017\u0001\u000c\u0001\u0012"+
"\u0008\uffff\u0001\u001d\u0004\uffff\u0001\u000d\u0001\u000e"+
"\u0001\u0015\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009"+
"\u0001\u000a\u0001\u000e\u0001\u000b\u0002\u0017\u0001\u000e"+
"\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0013\u0001\u0014"+
"\u0001\u0016\u0002\u0005\u0004\u0018\u0005\u0003\u0001\u0001"+
"\u0004\u0002\u0002\u0003\u0001\uffff\u0006\u0004\u0006\uffff"+
"\u0015\u001d\u0008\uffff\u0001\u001d\u0001\u0019\u0001\uffff"+
"\u0006\u001d\u0002\uffff\u0002\u001a\u0002\u001b\u0009\uffff"+
"\u0001\u001c\u000c\uffff\u0006\u001d\u0001\uffff\u000c\u001d",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA14_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_eotS),
DFA14_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_eofS),
DFA14_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA14_minS),
DFA14_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA14_maxS),
DFA14_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_acceptS),
DFA14_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_specialS),
DFA14_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA14_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA14 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 14;
this.eot = Ham4Parser.DFA14_eot;
this.eof = Ham4Parser.DFA14_eof;
this.min = Ham4Parser.DFA14_min;
this.max = Ham4Parser.DFA14_max;
this.accept = Ham4Parser.DFA14_accept;
this.special = Ham4Parser.DFA14_special;
this.transition = Ham4Parser.DFA14_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA14, org.antlr.runtime.DFA, {
getDescription: function() {
return "564:9: ( ( location2 )=> location2 )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA14_0 = input.LA(1);
var index14_0 = input.index();
input.rewind();
s = -1;
if ( (LA14_0==HamThumb) && (this.synpred5_Ham4Parser())) {s = 1;}
else if ( ((LA14_0>=HamIndexfinger && LA14_0<=HamPinky)) && (this.synpred5_Ham4Parser())) {s = 2;}
else if ( ((LA14_0>=HamWristback && LA14_0<=HamHandback)||(LA14_0>=HamThumbside && LA14_0<=HamPinkyside)) && (this.synpred5_Ham4Parser())) {s = 3;}
else if ( ((LA14_0>=HamFingertip && LA14_0<=HamFingerside)) && (this.synpred5_Ham4Parser())) {s = 4;}
else if ( ((LA14_0>=HamLrbeside && LA14_0<=HamLrat)) && (this.synpred5_Ham4Parser())) {s = 5;}
else if ( (LA14_0==HamNeutralspace) && (this.synpred5_Ham4Parser())) {s = 6;}
else if ( (LA14_0==HamHead) && (this.synpred5_Ham4Parser())) {s = 7;}
else if ( (LA14_0==HamHeadtop) && (this.synpred5_Ham4Parser())) {s = 8;}
else if ( (LA14_0==HamForehead) && (this.synpred5_Ham4Parser())) {s = 9;}
else if ( (LA14_0==HamEyebrows) && (this.synpred5_Ham4Parser())) {s = 10;}
else if ( (LA14_0==HamNose) && (this.synpred5_Ham4Parser())) {s = 11;}
else if ( (LA14_0==HamNostrils) && (this.synpred5_Ham4Parser())) {s = 12;}
else if ( (LA14_0==HamTongue) && (this.synpred5_Ham4Parser())) {s = 13;}
else if ( (LA14_0==HamTeeth||LA14_0==HamEyes||LA14_0==HamLips) && (this.synpred5_Ham4Parser())) {s = 14;}
else if ( (LA14_0==HamChin) && (this.synpred5_Ham4Parser())) {s = 15;}
else if ( (LA14_0==HamUnderchin) && (this.synpred5_Ham4Parser())) {s = 16;}
else if ( (LA14_0==HamNeck) && (this.synpred5_Ham4Parser())) {s = 17;}
else if ( (LA14_0==HamShouldertop) && (this.synpred5_Ham4Parser())) {s = 18;}
else if ( (LA14_0==HamShoulders) && (this.synpred5_Ham4Parser())) {s = 19;}
else if ( (LA14_0==HamChest) && (this.synpred5_Ham4Parser())) {s = 20;}
else if ( (LA14_0==HamStomach) && (this.synpred5_Ham4Parser())) {s = 21;}
else if ( (LA14_0==HamBelowstomach) && (this.synpred5_Ham4Parser())) {s = 22;}
else if ( (LA14_0==HamEarlobe||(LA14_0>=HamEar && LA14_0<=HamCheek)) && (this.synpred5_Ham4Parser())) {s = 23;}
else if ( ((LA14_0>=HamUpperarm && LA14_0<=HamLowerarm)) && (this.synpred5_Ham4Parser())) {s = 24;}
else if ( (LA14_0==HamParbegin) ) {s = 25;}
else if ( ((LA14_0>=HamClose && LA14_0<=HamTouch)) && (this.synpred5_Ham4Parser())) {s = 26;}
else if ( ((LA14_0>=HamInterlock && LA14_0<=HamCross)) && (this.synpred5_Ham4Parser())) {s = 27;}
else if ( (LA14_0==HamSeqbegin) ) {s = 28;}
else if ( (LA14_0==EOF||LA14_0==HamPlus||LA14_0==HamReplace||(LA14_0>=HamNomotion && LA14_0<=HamMovex)||LA14_0==HamFingerplay||(LA14_0>=HamCircleo && LA14_0<=HamCircler)||(LA14_0>=HamNodding && LA14_0<=HamFusionbegin)||(LA14_0>=HamCircleul && LA14_0<=HamCircleuo)) ) {s = 29;}
input.seek(index14_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA14_25 = input.LA(1);
var index14_25 = input.index();
input.rewind();
s = -1;
if ( (this.synpred5_Ham4Parser()) ) {s = 27;}
else if ( (true) ) {s = 29;}
input.seek(index14_25);
if ( s>=0 ) return s;
break;
case 2 : 
var LA14_28 = input.LA(1);
var index14_28 = input.index();
input.rewind();
s = -1;
if ( (this.synpred5_Ham4Parser()) ) {s = 27;}
else if ( (true) ) {s = 29;}
input.seek(index14_28);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 14, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA16_eotS:
"\u001a\uffff",
DFA16_eofS:
"\u001a\uffff",
DFA16_minS:
"\u0001\u000f\u0019\uffff",
DFA16_maxS:
"\u0001\u007e\u0019\uffff",
DFA16_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0017\uffff",
DFA16_specialS:
"\u0001\u0000\u0019\uffff}>",
DFA16_transitionS: [
"\u0001\u0001\u0033\uffff\u0003\u0002\u000d\uffff\u0025\u0002"+
"\u0001\uffff\u0006\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA16_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_eotS),
DFA16_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_eofS),
DFA16_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA16_minS),
DFA16_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA16_maxS),
DFA16_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_acceptS),
DFA16_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_specialS),
DFA16_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA16_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA16 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 16;
this.eot = Ham4Parser.DFA16_eot;
this.eof = Ham4Parser.DFA16_eof;
this.min = Ham4Parser.DFA16_min;
this.max = Ham4Parser.DFA16_max;
this.accept = Ham4Parser.DFA16_accept;
this.special = Ham4Parser.DFA16_special;
this.transition = Ham4Parser.DFA16_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA16, org.antlr.runtime.DFA, {
getDescription: function() {
return "573:9: ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA16_0 = input.LA(1);
var index16_0 = input.index();
input.rewind();
s = -1;
if ( (LA16_0==HamPlus) && (this.synpred6_Ham4Parser())) {s = 1;}
else if ( ((LA16_0>=HamEarlobe && LA16_0<=HamShouldertop)||(LA16_0>=HamTongue && LA16_0<=HamPinkyside)||(LA16_0>=HamFingertip && LA16_0<=HamFingerside)) ) {s = 2;}
input.seek(index16_0);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 16, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA15_eotS:
"\u001a\uffff",
DFA15_eofS:
"\u001a\uffff",
DFA15_minS:
"\u0001\u0043\u0019\uffff",
DFA15_maxS:
"\u0001\u00a4\u0019\uffff",
DFA15_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002",
DFA15_specialS:
"\u001a\uffff}>",
DFA15_transitionS: [
"\u0003\u0001\u000d\uffff\u0025\u0001\u0001\uffff\u0006\u0001"+
"\u0025\uffff\u0001\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA15_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_eotS),
DFA15_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_eofS),
DFA15_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA15_minS),
DFA15_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA15_maxS),
DFA15_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_acceptS),
DFA15_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_specialS),
DFA15_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA15_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA15 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 15;
this.eot = Ham4Parser.DFA15_eot;
this.eof = Ham4Parser.DFA15_eof;
this.min = Ham4Parser.DFA15_min;
this.max = Ham4Parser.DFA15_max;
this.accept = Ham4Parser.DFA15_accept;
this.special = Ham4Parser.DFA15_special;
this.transition = Ham4Parser.DFA15_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA15, org.antlr.runtime.DFA, {
getDescription: function() {
return "585:13: (ploc= location1 )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA18_eotS:
"\u0025\uffff",
DFA18_eofS:
"\u0001\u0019\u0024\uffff",
DFA18_minS:
"\u0001\u000f\u0024\uffff",
DFA18_maxS:
"\u0001\u00d9\u0024\uffff",
DFA18_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002\u000b\uffff",
DFA18_specialS:
"\u0025\uffff}>",
DFA18_transitionS: [
"\u0001\u0019\u0033\uffff\u0003\u0001\u0008\uffff\u0001\u0019"+
"\u0004\uffff\u0025\u0001\u0001\uffff\u0006\u0001\u0006\uffff"+
"\u0015\u0019\u0008\uffff\u0002\u0019\u0001\uffff\u0006\u0019"+
"\u000f\uffff\u0001\u0019\u000c\uffff\u0006\u0019\u0001\uffff"+
"\u000c\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA18_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_eotS),
DFA18_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_eofS),
DFA18_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA18_minS),
DFA18_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA18_maxS),
DFA18_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_acceptS),
DFA18_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_specialS),
DFA18_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA18_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA18 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 18;
this.eot = Ham4Parser.DFA18_eot;
this.eof = Ham4Parser.DFA18_eof;
this.min = Ham4Parser.DFA18_min;
this.max = Ham4Parser.DFA18_max;
this.accept = Ham4Parser.DFA18_accept;
this.special = Ham4Parser.DFA18_special;
this.transition = Ham4Parser.DFA18_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA18, org.antlr.runtime.DFA, {
getDescription: function() {
return "612:9: ( location1 )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA21_eotS:
"\u0015\uffff",
DFA21_eofS:
"\u0015\uffff",
DFA21_minS:
"\u0001\u0031\u0012\uffff\u0001\u0000\u0001\uffff",
DFA21_maxS:
"\u0001\u00a3\u0012\uffff\u0001\u0000\u0001\uffff",
DFA21_acceptS:
"\u0001\uffff\u0012\u0001\u0001\uffff\u0001\u0002",
DFA21_specialS:
"\u0001\u0000\u0012\uffff\u0001\u0001\u0001\uffff}>",
DFA21_transitionS: [
"\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005"+
"\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a"+
"\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f"+
"\u0001\u0010\u0001\u0011\u0001\u0012\u0060\uffff\u0001\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA21_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_eotS),
DFA21_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_eofS),
DFA21_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA21_minS),
DFA21_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA21_maxS),
DFA21_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_acceptS),
DFA21_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_specialS),
DFA21_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA21_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA21 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 21;
this.eot = Ham4Parser.DFA21_eot;
this.eof = Ham4Parser.DFA21_eof;
this.min = Ham4Parser.DFA21_min;
this.max = Ham4Parser.DFA21_max;
this.accept = Ham4Parser.DFA21_accept;
this.special = Ham4Parser.DFA21_special;
this.transition = Ham4Parser.DFA21_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA21, org.antlr.runtime.DFA, {
getDescription: function() {
return "759:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA21_0 = input.LA(1);
var index21_0 = input.index();
input.rewind();
s = -1;
if ( (LA21_0==HamExtfingeru) && (this.synpred9_Ham4Parser())) {s = 1;}
else if ( (LA21_0==HamExtfingerur) && (this.synpred9_Ham4Parser())) {s = 2;}
else if ( (LA21_0==HamExtfingerr) && (this.synpred9_Ham4Parser())) {s = 3;}
else if ( (LA21_0==HamExtfingerdr) && (this.synpred9_Ham4Parser())) {s = 4;}
else if ( (LA21_0==HamExtfingerd) && (this.synpred9_Ham4Parser())) {s = 5;}
else if ( (LA21_0==HamExtfingerdl) && (this.synpred9_Ham4Parser())) {s = 6;}
else if ( (LA21_0==HamExtfingerl) && (this.synpred9_Ham4Parser())) {s = 7;}
else if ( (LA21_0==HamExtfingerul) && (this.synpred9_Ham4Parser())) {s = 8;}
else if ( (LA21_0==HamExtfingerol) && (this.synpred9_Ham4Parser())) {s = 9;}
else if ( (LA21_0==HamExtfingero) && (this.synpred9_Ham4Parser())) {s = 10;}
else if ( (LA21_0==HamExtfingeror) && (this.synpred9_Ham4Parser())) {s = 11;}
else if ( (LA21_0==HamExtfingeril) && (this.synpred9_Ham4Parser())) {s = 12;}
else if ( (LA21_0==HamExtfingeri) && (this.synpred9_Ham4Parser())) {s = 13;}
else if ( (LA21_0==HamExtfingerir) && (this.synpred9_Ham4Parser())) {s = 14;}
else if ( (LA21_0==HamExtfingerui) && (this.synpred9_Ham4Parser())) {s = 15;}
else if ( (LA21_0==HamExtfingerdi) && (this.synpred9_Ham4Parser())) {s = 16;}
else if ( (LA21_0==HamExtfingerdo) && (this.synpred9_Ham4Parser())) {s = 17;}
else if ( (LA21_0==HamExtfingeruo) && (this.synpred9_Ham4Parser())) {s = 18;}
else if ( (LA21_0==HamParbegin) ) {s = 19;}
input.seek(index21_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA21_19 = input.LA(1);
var index21_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred9_Ham4Parser()) ) {s = 18;}
else if ( (true) ) {s = 20;}
input.seek(index21_19);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 21, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA25_eotS:
"\u0045\uffff",
DFA25_eofS:
"\u0001\u0037\u0044\uffff",
DFA25_minS:
"\u0001\u000f\u0040\u0000\u0004\uffff",
DFA25_maxS:
"\u0001\u00d9\u0040\u0000\u0004\uffff",
DFA25_acceptS:
"\u0041\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004",
DFA25_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
"\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001"+
"\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001"+
"\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001"+
"\u0016\u0001\u0017\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001"+
"\u001c\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021\u0001"+
"\u0022\u0001\u0023\u0001\u0024\u0001\u0025\u0001\u0026\u0001\u0027\u0001"+
"\u0028\u0001\u0029\u0001\u002a\u0001\u002b\u0001\u002c\u0001\u002d\u0001"+
"\u002e\u0001\u002f\u0001\u0030\u0001\u0031\u0001\u0032\u0001\u0033\u0001"+
"\u0034\u0001\u0035\u0001\u0036\u0001\u0037\u0001\u0038\u0001\u0039\u0001"+
"\u003a\u0001\u003b\u0001\u003c\u0001\u003d\u0001\u003e\u0001\u003f\u0004"+
"\uffff}>",
DFA25_transitionS: [
"\u0001\u0017\u0021\uffff\u0001\u0005\u0001\u0006\u0001\u0007"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c"+
"\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011"+
"\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016"+
"\u0001\u002b\u0001\u0020\u0001\u0026\u0008\u003b\u0001\u0032"+
"\u0004\uffff\u0001\u0021\u0001\u0022\u0001\u0029\u0001\u001a"+
"\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u0022"+
"\u0001\u001f\u0002\u002b\u0001\u0022\u0001\u0023\u0001\u0024"+
"\u0001\u0025\u0001\u0027\u0001\u0028\u0001\u002a\u0002\u0019"+
"\u0004\u002c\u0005\u0018\u0001\u0002\u0004\u0001\u0002\u0018"+
"\u0001\u0003\u0006\u0004\u0006\uffff\u0001\u002d\u0012\u002e"+
"\u0002\u0030\u0008\uffff\u0001\u0033\u0001\u0035\u0001\u0038"+
"\u0006\u002f\u0002\uffff\u0002\u0039\u0002\u003a\u0005\u003c"+
"\u0004\u003e\u0001\u0034\u0001\u003d\u0001\u003f\u0001\u003e"+
"\u0009\uffff\u0005\u0031\u0001\u0036\u0001\u0040\u000c\u002f",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA25_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_eotS),
DFA25_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_eofS),
DFA25_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA25_minS),
DFA25_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA25_maxS),
DFA25_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_acceptS),
DFA25_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_specialS),
DFA25_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA25_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA25 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 25;
this.eot = Ham4Parser.DFA25_eot;
this.eof = Ham4Parser.DFA25_eof;
this.min = Ham4Parser.DFA25_min;
this.max = Ham4Parser.DFA25_max;
this.accept = Ham4Parser.DFA25_accept;
this.special = Ham4Parser.DFA25_special;
this.transition = Ham4Parser.DFA25_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA25, org.antlr.runtime.DFA, {
getDescription: function() {
return "868:9: ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA25_1 = input.LA(1);
var index25_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred10_Ham4Parser()) ) {s = 65;}
else if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA25_2 = input.LA(1);
var index25_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred10_Ham4Parser()) ) {s = 65;}
else if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_2);
if ( s>=0 ) return s;
break;
case 2 : 
var LA25_3 = input.LA(1);
var index25_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
input.seek(index25_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA25_4 = input.LA(1);
var index25_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_4);
if ( s>=0 ) return s;
break;
case 4 : 
var LA25_5 = input.LA(1);
var index25_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_5);
if ( s>=0 ) return s;
break;
case 5 : 
var LA25_6 = input.LA(1);
var index25_6 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_6);
if ( s>=0 ) return s;
break;
case 6 : 
var LA25_7 = input.LA(1);
var index25_7 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_7);
if ( s>=0 ) return s;
break;
case 7 : 
var LA25_8 = input.LA(1);
var index25_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_8);
if ( s>=0 ) return s;
break;
case 8 : 
var LA25_9 = input.LA(1);
var index25_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_9);
if ( s>=0 ) return s;
break;
case 9 : 
var LA25_10 = input.LA(1);
var index25_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_10);
if ( s>=0 ) return s;
break;
case 10 : 
var LA25_11 = input.LA(1);
var index25_11 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_11);
if ( s>=0 ) return s;
break;
case 11 : 
var LA25_12 = input.LA(1);
var index25_12 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_12);
if ( s>=0 ) return s;
break;
case 12 : 
var LA25_13 = input.LA(1);
var index25_13 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_13);
if ( s>=0 ) return s;
break;
case 13 : 
var LA25_14 = input.LA(1);
var index25_14 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_14);
if ( s>=0 ) return s;
break;
case 14 : 
var LA25_15 = input.LA(1);
var index25_15 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_15);
if ( s>=0 ) return s;
break;
case 15 : 
var LA25_16 = input.LA(1);
var index25_16 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_16);
if ( s>=0 ) return s;
break;
case 16 : 
var LA25_17 = input.LA(1);
var index25_17 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_17);
if ( s>=0 ) return s;
break;
case 17 : 
var LA25_18 = input.LA(1);
var index25_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_18);
if ( s>=0 ) return s;
break;
case 18 : 
var LA25_19 = input.LA(1);
var index25_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_19);
if ( s>=0 ) return s;
break;
case 19 : 
var LA25_20 = input.LA(1);
var index25_20 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_20);
if ( s>=0 ) return s;
break;
case 20 : 
var LA25_21 = input.LA(1);
var index25_21 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_21);
if ( s>=0 ) return s;
break;
case 21 : 
var LA25_22 = input.LA(1);
var index25_22 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_22);
if ( s>=0 ) return s;
break;
case 22 : 
var LA25_23 = input.LA(1);
var index25_23 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_23);
if ( s>=0 ) return s;
break;
case 23 : 
var LA25_24 = input.LA(1);
var index25_24 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_24);
if ( s>=0 ) return s;
break;
case 24 : 
var LA25_25 = input.LA(1);
var index25_25 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_25);
if ( s>=0 ) return s;
break;
case 25 : 
var LA25_26 = input.LA(1);
var index25_26 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_26);
if ( s>=0 ) return s;
break;
case 26 : 
var LA25_27 = input.LA(1);
var index25_27 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_27);
if ( s>=0 ) return s;
break;
case 27 : 
var LA25_28 = input.LA(1);
var index25_28 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_28);
if ( s>=0 ) return s;
break;
case 28 : 
var LA25_29 = input.LA(1);
var index25_29 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_29);
if ( s>=0 ) return s;
break;
case 29 : 
var LA25_30 = input.LA(1);
var index25_30 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_30);
if ( s>=0 ) return s;
break;
case 30 : 
var LA25_31 = input.LA(1);
var index25_31 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_31);
if ( s>=0 ) return s;
break;
case 31 : 
var LA25_32 = input.LA(1);
var index25_32 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_32);
if ( s>=0 ) return s;
break;
case 32 : 
var LA25_33 = input.LA(1);
var index25_33 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_33);
if ( s>=0 ) return s;
break;
case 33 : 
var LA25_34 = input.LA(1);
var index25_34 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_34);
if ( s>=0 ) return s;
break;
case 34 : 
var LA25_35 = input.LA(1);
var index25_35 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_35);
if ( s>=0 ) return s;
break;
case 35 : 
var LA25_36 = input.LA(1);
var index25_36 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_36);
if ( s>=0 ) return s;
break;
case 36 : 
var LA25_37 = input.LA(1);
var index25_37 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_37);
if ( s>=0 ) return s;
break;
case 37 : 
var LA25_38 = input.LA(1);
var index25_38 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_38);
if ( s>=0 ) return s;
break;
case 38 : 
var LA25_39 = input.LA(1);
var index25_39 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_39);
if ( s>=0 ) return s;
break;
case 39 : 
var LA25_40 = input.LA(1);
var index25_40 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_40);
if ( s>=0 ) return s;
break;
case 40 : 
var LA25_41 = input.LA(1);
var index25_41 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_41);
if ( s>=0 ) return s;
break;
case 41 : 
var LA25_42 = input.LA(1);
var index25_42 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_42);
if ( s>=0 ) return s;
break;
case 42 : 
var LA25_43 = input.LA(1);
var index25_43 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_43);
if ( s>=0 ) return s;
break;
case 43 : 
var LA25_44 = input.LA(1);
var index25_44 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_44);
if ( s>=0 ) return s;
break;
case 44 : 
var LA25_45 = input.LA(1);
var index25_45 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_45);
if ( s>=0 ) return s;
break;
case 45 : 
var LA25_46 = input.LA(1);
var index25_46 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_46);
if ( s>=0 ) return s;
break;
case 46 : 
var LA25_47 = input.LA(1);
var index25_47 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_47);
if ( s>=0 ) return s;
break;
case 47 : 
var LA25_48 = input.LA(1);
var index25_48 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_48);
if ( s>=0 ) return s;
break;
case 48 : 
var LA25_49 = input.LA(1);
var index25_49 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_49);
if ( s>=0 ) return s;
break;
case 49 : 
var LA25_50 = input.LA(1);
var index25_50 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_50);
if ( s>=0 ) return s;
break;
case 50 : 
var LA25_51 = input.LA(1);
var index25_51 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_51);
if ( s>=0 ) return s;
break;
case 51 : 
var LA25_52 = input.LA(1);
var index25_52 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_52);
if ( s>=0 ) return s;
break;
case 52 : 
var LA25_53 = input.LA(1);
var index25_53 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_53);
if ( s>=0 ) return s;
break;
case 53 : 
var LA25_54 = input.LA(1);
var index25_54 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_54);
if ( s>=0 ) return s;
break;
case 54 : 
var LA25_55 = input.LA(1);
var index25_55 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_55);
if ( s>=0 ) return s;
break;
case 55 : 
var LA25_56 = input.LA(1);
var index25_56 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_56);
if ( s>=0 ) return s;
break;
case 56 : 
var LA25_57 = input.LA(1);
var index25_57 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_57);
if ( s>=0 ) return s;
break;
case 57 : 
var LA25_58 = input.LA(1);
var index25_58 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_58);
if ( s>=0 ) return s;
break;
case 58 : 
var LA25_59 = input.LA(1);
var index25_59 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_59);
if ( s>=0 ) return s;
break;
case 59 : 
var LA25_60 = input.LA(1);
var index25_60 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_60);
if ( s>=0 ) return s;
break;
case 60 : 
var LA25_61 = input.LA(1);
var index25_61 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_61);
if ( s>=0 ) return s;
break;
case 61 : 
var LA25_62 = input.LA(1);
var index25_62 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_62);
if ( s>=0 ) return s;
break;
case 62 : 
var LA25_63 = input.LA(1);
var index25_63 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_63);
if ( s>=0 ) return s;
break;
case 63 : 
var LA25_64 = input.LA(1);
var index25_64 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_64);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 25, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA23_eotS:
"\u0041\uffff",
DFA23_eofS:
"\u0001\u0005\u0040\uffff",
DFA23_minS:
"\u0001\u000f\u0001\u0000\u0001\uffff\u0002\u0000\u003c\uffff",
DFA23_maxS:
"\u0001\u00d9\u0001\u0000\u0001\uffff\u0002\u0000\u003c\uffff",
DFA23_acceptS:
"\u0002\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u003b\uffff",
DFA23_specialS:
"\u0001\u0000\u0001\u0001\u0001\uffff\u0001\u0002\u0001\u0003\u003c"+
"\uffff}>",
DFA23_transitionS: [
"\u0001\u0005\u0021\uffff\u001e\u0005\u0004\uffff\u001e\u0005"+
"\u0001\u0003\u0004\u0001\u0002\u0005\u0001\u0002\u0006\u0004"+
"\u0006\uffff\u0015\u0005\u0008\uffff\u0009\u0005\u0002\uffff"+
"\u0011\u0005\u0009\uffff\u0013\u0005",
"\u0001\uffff",
"",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA23_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_eotS),
DFA23_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_eofS),
DFA23_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA23_minS),
DFA23_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA23_maxS),
DFA23_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_acceptS),
DFA23_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_specialS),
DFA23_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA23_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA23 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 23;
this.eot = Ham4Parser.DFA23_eot;
this.eof = Ham4Parser.DFA23_eof;
this.min = Ham4Parser.DFA23_min;
this.max = Ham4Parser.DFA23_max;
this.accept = Ham4Parser.DFA23_accept;
this.special = Ham4Parser.DFA23_special;
this.transition = Ham4Parser.DFA23_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA23, org.antlr.runtime.DFA, {
getDescription: function() {
return "882:13: ( ( thumbspecial )=> thumbspecial )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA23_0 = input.LA(1);
var index23_0 = input.index();
input.rewind();
s = -1;
if ( ((LA23_0>=HamIndexfinger && LA23_0<=HamPinky)) ) {s = 1;}
else if ( (LA23_0==HamBetween) && (this.synpred12_Ham4Parser())) {s = 2;}
else if ( (LA23_0==HamThumb) ) {s = 3;}
else if ( ((LA23_0>=HamFingertip && LA23_0<=HamFingerside)) ) {s = 4;}
else if ( (LA23_0==EOF||LA23_0==HamPlus||(LA23_0>=HamExtfingeru && LA23_0<=HamReplace)||(LA23_0>=HamTongue && LA23_0<=HamHandback)||(LA23_0>=HamThumbside && LA23_0<=HamPinkyside)||(LA23_0>=HamNomotion && LA23_0<=HamMovex)||(LA23_0>=HamFingerplay && LA23_0<=HamCircler)||(LA23_0>=HamClose && LA23_0<=HamRepeatreverse)||(LA23_0>=HamNodding && LA23_0<=HamCircleuo)) ) {s = 5;}
input.seek(index23_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA23_1 = input.LA(1);
var index23_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA23_3 = input.LA(1);
var index23_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA23_4 = input.LA(1);
var index23_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_4);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 23, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA26_eotS:
"\u0042\uffff",
DFA26_eofS:
"\u0001\u0002\u0041\uffff",
DFA26_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA26_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA26_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA26_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA26_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u0025\u0002"+
"\u0001\u0001\u0006\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA26_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_eotS),
DFA26_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_eofS),
DFA26_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA26_minS),
DFA26_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA26_maxS),
DFA26_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_acceptS),
DFA26_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_specialS),
DFA26_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA26_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA26 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 26;
this.eot = Ham4Parser.DFA26_eot;
this.eof = Ham4Parser.DFA26_eof;
this.min = Ham4Parser.DFA26_min;
this.max = Ham4Parser.DFA26_max;
this.accept = Ham4Parser.DFA26_accept;
this.special = Ham4Parser.DFA26_special;
this.transition = Ham4Parser.DFA26_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA26, org.antlr.runtime.DFA, {
getDescription: function() {
return "926:9: ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA26_1 = input.LA(1);
var index26_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred14_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index26_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 26, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA33_eotS:
"\u0042\uffff",
DFA33_eofS:
"\u0001\u0002\u0041\uffff",
DFA33_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA33_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA33_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA33_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA33_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u001f\u0002"+
"\u0004\u0001\u0009\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA33_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_eotS),
DFA33_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_eofS),
DFA33_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA33_minS),
DFA33_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA33_maxS),
DFA33_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_acceptS),
DFA33_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_specialS),
DFA33_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA33_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA33 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 33;
this.eot = Ham4Parser.DFA33_eot;
this.eof = Ham4Parser.DFA33_eof;
this.min = Ham4Parser.DFA33_min;
this.max = Ham4Parser.DFA33_max;
this.accept = Ham4Parser.DFA33_accept;
this.special = Ham4Parser.DFA33_special;
this.transition = Ham4Parser.DFA33_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA33, org.antlr.runtime.DFA, {
getDescription: function() {
return "1035:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA33_1 = input.LA(1);
var index33_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred15_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index33_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 33, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA34_eotS:
"\u0042\uffff",
DFA34_eofS:
"\u0001\u0002\u0041\uffff",
DFA34_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA34_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA34_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA34_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA34_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u001f\u0002"+
"\u0004\u0001\u0009\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA34_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_eotS),
DFA34_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_eofS),
DFA34_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA34_minS),
DFA34_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA34_maxS),
DFA34_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_acceptS),
DFA34_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_specialS),
DFA34_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA34_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA34 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 34;
this.eot = Ham4Parser.DFA34_eot;
this.eof = Ham4Parser.DFA34_eof;
this.min = Ham4Parser.DFA34_min;
this.max = Ham4Parser.DFA34_max;
this.accept = Ham4Parser.DFA34_accept;
this.special = Ham4Parser.DFA34_special;
this.transition = Ham4Parser.DFA34_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA34, org.antlr.runtime.DFA, {
getDescription: function() {
return "1083:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA34_1 = input.LA(1);
var index34_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred16_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index34_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 34, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA35_eotS:
"\u0042\uffff",
DFA35_eofS:
"\u0001\u0003\u0041\uffff",
DFA35_minS:
"\u0001\u000f\u0002\u0000\u003f\uffff",
DFA35_maxS:
"\u0001\u00d9\u0002\u0000\u003f\uffff",
DFA35_acceptS:
"\u0003\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA35_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u003f\uffff}>",
DFA35_transitionS: [
"\u0001\u0003\u0021\uffff\u001e\u0003\u0004\uffff\u001e\u0003"+
"\u0001\u0001\u0004\u0002\u0009\u0003\u0006\uffff\u0015\u0003"+
"\u0008\uffff\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff"+
"\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA35_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_eotS),
DFA35_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_eofS),
DFA35_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA35_minS),
DFA35_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA35_maxS),
DFA35_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_acceptS),
DFA35_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_specialS),
DFA35_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA35_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA35 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 35;
this.eot = Ham4Parser.DFA35_eot;
this.eof = Ham4Parser.DFA35_eof;
this.min = Ham4Parser.DFA35_min;
this.max = Ham4Parser.DFA35_max;
this.accept = Ham4Parser.DFA35_accept;
this.special = Ham4Parser.DFA35_special;
this.transition = Ham4Parser.DFA35_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA35, org.antlr.runtime.DFA, {
getDescription: function() {
return "1131:9: ( ( fingershape )=> fingershape recfingershapelist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA35_1 = input.LA(1);
var index35_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred17_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index35_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA35_2 = input.LA(1);
var index35_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred17_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index35_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 35, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA36_eotS:
"\u0042\uffff",
DFA36_eofS:
"\u0001\u0003\u0041\uffff",
DFA36_minS:
"\u0001\u000f\u0002\u0000\u003f\uffff",
DFA36_maxS:
"\u0001\u00d9\u0002\u0000\u003f\uffff",
DFA36_acceptS:
"\u0003\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA36_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u003f\uffff}>",
DFA36_transitionS: [
"\u0001\u0003\u0021\uffff\u001e\u0003\u0004\uffff\u001e\u0003"+
"\u0001\u0001\u0004\u0002\u0009\u0003\u0006\uffff\u0015\u0003"+
"\u0008\uffff\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff"+
"\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA36_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_eotS),
DFA36_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_eofS),
DFA36_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA36_minS),
DFA36_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA36_maxS),
DFA36_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_acceptS),
DFA36_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_specialS),
DFA36_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA36_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA36 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 36;
this.eot = Ham4Parser.DFA36_eot;
this.eof = Ham4Parser.DFA36_eof;
this.min = Ham4Parser.DFA36_min;
this.max = Ham4Parser.DFA36_max;
this.accept = Ham4Parser.DFA36_accept;
this.special = Ham4Parser.DFA36_special;
this.transition = Ham4Parser.DFA36_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA36, org.antlr.runtime.DFA, {
getDescription: function() {
return "1179:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA36_1 = input.LA(1);
var index36_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred18_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index36_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA36_2 = input.LA(1);
var index36_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred18_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index36_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 36, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA49_eotS:
"\u001d\uffff",
DFA49_eofS:
"\u001d\uffff",
DFA49_minS:
"\u0001\u0043\u001c\uffff",
DFA49_maxS:
"\u0001\u00ba\u001c\uffff",
DFA49_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002\u0003\uffff",
DFA49_specialS:
"\u001d\uffff}>",
DFA49_transitionS: [
"\u0003\u0001\u000d\uffff\u0025\u0001\u0001\uffff\u0006\u0001"+
"\u0024\uffff\u0001\u0019\u0009\uffff\u0004\u0019\u0009\uffff"+
"\u0001\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA49_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_eotS),
DFA49_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_eofS),
DFA49_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA49_minS),
DFA49_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA49_maxS),
DFA49_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_acceptS),
DFA49_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_specialS),
DFA49_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA49_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA49 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 49;
this.eot = Ham4Parser.DFA49_eot;
this.eof = Ham4Parser.DFA49_eof;
this.min = Ham4Parser.DFA49_min;
this.max = Ham4Parser.DFA49_max;
this.accept = Ham4Parser.DFA49_accept;
this.special = Ham4Parser.DFA49_special;
this.transition = Ham4Parser.DFA49_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA49, org.antlr.runtime.DFA, {
getDescription: function() {
return "1616:5: ( location1as2 | location2not1 )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA54_eotS:
"\u001a\uffff",
DFA54_eofS:
"\u001a\uffff",
DFA54_minS:
"\u0001\u0043\u0002\u0000\u0002\uffff\u0001\u0000\u0014\uffff",
DFA54_maxS:
"\u0001\u007e\u0002\u0000\u0002\uffff\u0001\u0000\u0014\uffff",
DFA54_acceptS:
"\u0003\uffff\u0002\u0002\u0001\uffff\u0001\u0003\u0012\uffff\u0001"+
"\u0001",
DFA54_specialS:
"\u0001\u0000\u0001\u0001\u0001\u0002\u0002\uffff\u0001\u0003\u0014"+
"\uffff}>",
DFA54_transitionS: [
"\u0003\u0006\u000d\uffff\u0013\u0006\u0002\u0005\u0004\u0006"+
"\u0005\u0003\u0001\u0001\u0004\u0002\u0002\u0003\u0001\uffff"+
"\u0006\u0004",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA54_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_eotS),
DFA54_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_eofS),
DFA54_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA54_minS),
DFA54_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA54_maxS),
DFA54_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_acceptS),
DFA54_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_specialS),
DFA54_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA54_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA54 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 54;
this.eot = Ham4Parser.DFA54_eot;
this.eof = Ham4Parser.DFA54_eof;
this.min = Ham4Parser.DFA54_min;
this.max = Ham4Parser.DFA54_max;
this.accept = Ham4Parser.DFA54_accept;
this.special = Ham4Parser.DFA54_special;
this.transition = Ham4Parser.DFA54_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA54, org.antlr.runtime.DFA, {
getDescription: function() {
return "1724:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA54_0 = input.LA(1);
var index54_0 = input.index();
input.rewind();
s = -1;
if ( (LA54_0==HamThumb) ) {s = 1;}
else if ( ((LA54_0>=HamIndexfinger && LA54_0<=HamPinky)) ) {s = 2;}
else if ( ((LA54_0>=HamWristback && LA54_0<=HamHandback)||(LA54_0>=HamThumbside && LA54_0<=HamPinkyside)) && (this.synpred21_Ham4Parser())) {s = 3;}
else if ( ((LA54_0>=HamFingertip && LA54_0<=HamFingerside)) && (this.synpred21_Ham4Parser())) {s = 4;}
else if ( ((LA54_0>=HamLrbeside && LA54_0<=HamLrat)) ) {s = 5;}
else if ( ((LA54_0>=HamEarlobe && LA54_0<=HamShouldertop)||(LA54_0>=HamTongue && LA54_0<=HamBelowstomach)||(LA54_0>=HamUpperarm && LA54_0<=HamLowerarm)) ) {s = 6;}
input.seek(index54_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA54_1 = input.LA(1);
var index54_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred20_Ham4Parser()) ) {s = 25;}
else if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
input.seek(index54_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA54_2 = input.LA(1);
var index54_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred20_Ham4Parser()) ) {s = 25;}
else if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
input.seek(index54_2);
if ( s>=0 ) return s;
break;
case 3 : 
var LA54_5 = input.LA(1);
var index54_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
else if ( (true) ) {s = 6;}
input.seek(index54_5);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 54, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA56_eotS:
"\u0015\uffff",
DFA56_eofS:
"\u0015\uffff",
DFA56_minS:
"\u0001\u0043\u0012\uffff\u0001\u0000\u0001\uffff",
DFA56_maxS:
"\u0001\u006b\u0012\uffff\u0001\u0000\u0001\uffff",
DFA56_acceptS:
"\u0001\uffff\u0001\u0001\u0011\u0002\u0001\uffff\u0001\u0003",
DFA56_specialS:
"\u0001\u0000\u0012\uffff\u0001\u0001\u0001\uffff}>",
DFA56_transitionS: [
"\u0001\u0012\u0001\u0007\u0001\u000d\u000d\uffff\u0001\u0008"+
"\u0001\u0009\u0001\u0010\u0001\u0001\u0001\u0002\u0001\u0003"+
"\u0001\u0004\u0001\u0005\u0001\u0009\u0001\u0006\u0002\u0012"+
"\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000e"+
"\u0001\u000f\u0001\u0011\u0002\u0013\u0004\u0014",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA56_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_eotS),
DFA56_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_eofS),
DFA56_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA56_minS),
DFA56_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA56_maxS),
DFA56_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_acceptS),
DFA56_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_specialS),
DFA56_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA56_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA56 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 56;
this.eot = Ham4Parser.DFA56_eot;
this.eof = Ham4Parser.DFA56_eof;
this.min = Ham4Parser.DFA56_min;
this.max = Ham4Parser.DFA56_max;
this.accept = Ham4Parser.DFA56_accept;
this.special = Ham4Parser.DFA56_special;
this.transition = Ham4Parser.DFA56_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA56, org.antlr.runtime.DFA, {
getDescription: function() {
return "1806:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA56_0 = input.LA(1);
var index56_0 = input.index();
input.rewind();
s = -1;
if ( (LA56_0==HamNeutralspace) ) {s = 1;}
else if ( (LA56_0==HamHead) && (this.synpred22_Ham4Parser())) {s = 2;}
else if ( (LA56_0==HamHeadtop) && (this.synpred22_Ham4Parser())) {s = 3;}
else if ( (LA56_0==HamForehead) && (this.synpred22_Ham4Parser())) {s = 4;}
else if ( (LA56_0==HamEyebrows) && (this.synpred22_Ham4Parser())) {s = 5;}
else if ( (LA56_0==HamNose) && (this.synpred22_Ham4Parser())) {s = 6;}
else if ( (LA56_0==HamNostrils) && (this.synpred22_Ham4Parser())) {s = 7;}
else if ( (LA56_0==HamTongue) && (this.synpred22_Ham4Parser())) {s = 8;}
else if ( (LA56_0==HamTeeth||LA56_0==HamEyes||LA56_0==HamLips) && (this.synpred22_Ham4Parser())) {s = 9;}
else if ( (LA56_0==HamChin) && (this.synpred22_Ham4Parser())) {s = 10;}
else if ( (LA56_0==HamUnderchin) && (this.synpred22_Ham4Parser())) {s = 11;}
else if ( (LA56_0==HamNeck) && (this.synpred22_Ham4Parser())) {s = 12;}
else if ( (LA56_0==HamShouldertop) && (this.synpred22_Ham4Parser())) {s = 13;}
else if ( (LA56_0==HamShoulders) && (this.synpred22_Ham4Parser())) {s = 14;}
else if ( (LA56_0==HamChest) && (this.synpred22_Ham4Parser())) {s = 15;}
else if ( (LA56_0==HamStomach) && (this.synpred22_Ham4Parser())) {s = 16;}
else if ( (LA56_0==HamBelowstomach) && (this.synpred22_Ham4Parser())) {s = 17;}
else if ( (LA56_0==HamEarlobe||(LA56_0>=HamEar && LA56_0<=HamCheek)) && (this.synpred22_Ham4Parser())) {s = 18;}
else if ( ((LA56_0>=HamLrbeside && LA56_0<=HamLrat)) ) {s = 19;}
else if ( ((LA56_0>=HamUpperarm && LA56_0<=HamLowerarm)) ) {s = 20;}
input.seek(index56_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA56_19 = input.LA(1);
var index56_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred22_Ham4Parser()) ) {s = 18;}
else if ( (true) ) {s = 20;}
input.seek(index56_19);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 56, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA57_eotS:
"\u0016\uffff",
DFA57_eofS:
"\u0001\u0002\u0015\uffff",
DFA57_minS:
"\u0001\u000f\u0015\uffff",
DFA57_maxS:
"\u0001\u00d9\u0015\uffff",
DFA57_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0013\uffff",
DFA57_specialS:
"\u0016\uffff}>",
DFA57_transitionS: [
"\u0001\u0002\u003e\uffff\u0002\u0002\u0001\u0001\u0034\uffff"+
"\u0015\u0002\u0001\uffff\u0001\u0002\u0006\uffff\u0009\u0002"+
"\u0002\uffff\u0002\u0002\u0007\uffff\u0008\u0002\u0009\uffff"+
"\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA57_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_eotS),
DFA57_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_eofS),
DFA57_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA57_minS),
DFA57_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA57_maxS),
DFA57_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_acceptS),
DFA57_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_specialS),
DFA57_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA57_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA57 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 57;
this.eot = Ham4Parser.DFA57_eot;
this.eof = Ham4Parser.DFA57_eof;
this.min = Ham4Parser.DFA57_min;
this.max = Ham4Parser.DFA57_max;
this.accept = Ham4Parser.DFA57_accept;
this.special = Ham4Parser.DFA57_special;
this.transition = Ham4Parser.DFA57_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA57, org.antlr.runtime.DFA, {
getDescription: function() {
return "1838:9: ( HamBehind )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA58_eotS:
"\u0015\uffff",
DFA58_eofS:
"\u0001\u0004\u0014\uffff",
DFA58_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA58_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA58_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA58_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA58_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0001\u0002\u0035\uffff"+
"\u0015\u0004\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004"+
"\u0002\uffff\u0002\u0001\u0007\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA58_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_eotS),
DFA58_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_eofS),
DFA58_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA58_minS),
DFA58_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA58_maxS),
DFA58_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_acceptS),
DFA58_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_specialS),
DFA58_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA58_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA58 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 58;
this.eot = Ham4Parser.DFA58_eot;
this.eof = Ham4Parser.DFA58_eof;
this.min = Ham4Parser.DFA58_min;
this.max = Ham4Parser.DFA58_max;
this.accept = Ham4Parser.DFA58_accept;
this.special = Ham4Parser.DFA58_special;
this.transition = Ham4Parser.DFA58_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA58, org.antlr.runtime.DFA, {
getDescription: function() {
return "1839:9: ( ( contactbody )=> contactbody )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA58_0 = input.LA(1);
var index58_0 = input.index();
input.rewind();
s = -1;
if ( ((LA58_0>=HamClose && LA58_0<=HamTouch)) && (this.synpred23_Ham4Parser())) {s = 1;}
else if ( (LA58_0==HamArmextended) && (this.synpred23_Ham4Parser())) {s = 2;}
else if ( (LA58_0==HamSeqbegin) ) {s = 3;}
else if ( (LA58_0==EOF||LA58_0==HamPlus||LA58_0==HamReplace||(LA58_0>=HamNomotion && LA58_0<=HamMovex)||LA58_0==HamLargemod||(LA58_0>=HamFingerplay && LA58_0<=HamCircler)||(LA58_0>=HamRepeatfromstart && LA58_0<=HamRepeatcontinueseveral)||(LA58_0>=HamSeqend && LA58_0<=HamRepeatreverse)||(LA58_0>=HamNodding && LA58_0<=HamCircleuo)) ) {s = 4;}
input.seek(index58_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA58_3 = input.LA(1);
var index58_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred23_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index58_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 58, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA59_eotS:
"\u0015\uffff",
DFA59_eofS:
"\u0001\u0004\u0014\uffff",
DFA59_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA59_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA59_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA59_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA59_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0036\uffff\u0015\u0004"+
"\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004\u0002\uffff"+
"\u0002\u0001\u0002\u0002\u0005\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA59_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_eotS),
DFA59_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_eofS),
DFA59_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA59_minS),
DFA59_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA59_maxS),
DFA59_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_acceptS),
DFA59_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_specialS),
DFA59_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA59_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA59 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 59;
this.eot = Ham4Parser.DFA59_eot;
this.eof = Ham4Parser.DFA59_eof;
this.min = Ham4Parser.DFA59_min;
this.max = Ham4Parser.DFA59_max;
this.accept = Ham4Parser.DFA59_accept;
this.special = Ham4Parser.DFA59_special;
this.transition = Ham4Parser.DFA59_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA59, org.antlr.runtime.DFA, {
getDescription: function() {
return "1862:9: ( ( contacthand )=> contacthand )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA59_0 = input.LA(1);
var index59_0 = input.index();
input.rewind();
s = -1;
if ( ((LA59_0>=HamClose && LA59_0<=HamTouch)) && (this.synpred24_Ham4Parser())) {s = 1;}
else if ( ((LA59_0>=HamInterlock && LA59_0<=HamCross)) && (this.synpred24_Ham4Parser())) {s = 2;}
else if ( (LA59_0==HamSeqbegin) ) {s = 3;}
else if ( (LA59_0==EOF||LA59_0==HamPlus||LA59_0==HamReplace||(LA59_0>=HamNomotion && LA59_0<=HamMovex)||LA59_0==HamLargemod||(LA59_0>=HamFingerplay && LA59_0<=HamCircler)||(LA59_0>=HamRepeatfromstart && LA59_0<=HamRepeatcontinueseveral)||(LA59_0>=HamSeqend && LA59_0<=HamRepeatreverse)||(LA59_0>=HamNodding && LA59_0<=HamCircleuo)) ) {s = 4;}
input.seek(index59_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA59_3 = input.LA(1);
var index59_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred24_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index59_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 59, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA60_eotS:
"\u0016\uffff",
DFA60_eofS:
"\u0001\u0002\u0015\uffff",
DFA60_minS:
"\u0001\u000f\u0015\uffff",
DFA60_maxS:
"\u0001\u00d9\u0015\uffff",
DFA60_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0013\uffff",
DFA60_specialS:
"\u0016\uffff}>",
DFA60_transitionS: [
"\u0001\u0002\u003e\uffff\u0002\u0002\u0001\u0001\u0034\uffff"+
"\u0015\u0002\u0001\uffff\u0001\u0002\u0006\uffff\u0009\u0002"+
"\u0002\uffff\u0002\u0002\u0007\uffff\u0008\u0002\u0009\uffff"+
"\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA60_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_eotS),
DFA60_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_eofS),
DFA60_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA60_minS),
DFA60_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA60_maxS),
DFA60_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_acceptS),
DFA60_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_specialS),
DFA60_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA60_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA60 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 60;
this.eot = Ham4Parser.DFA60_eot;
this.eof = Ham4Parser.DFA60_eof;
this.min = Ham4Parser.DFA60_min;
this.max = Ham4Parser.DFA60_max;
this.accept = Ham4Parser.DFA60_accept;
this.special = Ham4Parser.DFA60_special;
this.transition = Ham4Parser.DFA60_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA60, org.antlr.runtime.DFA, {
getDescription: function() {
return "1886:9: ( HamBehind )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA61_eotS:
"\u0015\uffff",
DFA61_eofS:
"\u0001\u0004\u0014\uffff",
DFA61_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA61_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA61_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA61_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA61_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0001\u0002\u0035\uffff"+
"\u0015\u0004\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004"+
"\u0002\uffff\u0002\u0001\u0007\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA61_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_eotS),
DFA61_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_eofS),
DFA61_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA61_minS),
DFA61_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA61_maxS),
DFA61_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_acceptS),
DFA61_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_specialS),
DFA61_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA61_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA61 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 61;
this.eot = Ham4Parser.DFA61_eot;
this.eof = Ham4Parser.DFA61_eof;
this.min = Ham4Parser.DFA61_min;
this.max = Ham4Parser.DFA61_max;
this.accept = Ham4Parser.DFA61_accept;
this.special = Ham4Parser.DFA61_special;
this.transition = Ham4Parser.DFA61_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA61, org.antlr.runtime.DFA, {
getDescription: function() {
return "1887:9: ( ( contactbody )=> contactbody )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA61_0 = input.LA(1);
var index61_0 = input.index();
input.rewind();
s = -1;
if ( ((LA61_0>=HamClose && LA61_0<=HamTouch)) && (this.synpred25_Ham4Parser())) {s = 1;}
else if ( (LA61_0==HamArmextended) && (this.synpred25_Ham4Parser())) {s = 2;}
else if ( (LA61_0==HamSeqbegin) ) {s = 3;}
else if ( (LA61_0==EOF||LA61_0==HamPlus||LA61_0==HamReplace||(LA61_0>=HamNomotion && LA61_0<=HamMovex)||LA61_0==HamLargemod||(LA61_0>=HamFingerplay && LA61_0<=HamCircler)||(LA61_0>=HamRepeatfromstart && LA61_0<=HamRepeatcontinueseveral)||(LA61_0>=HamSeqend && LA61_0<=HamRepeatreverse)||(LA61_0>=HamNodding && LA61_0<=HamCircleuo)) ) {s = 4;}
input.seek(index61_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA61_3 = input.LA(1);
var index61_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred25_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index61_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 61, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA92_eotS:
"\u000d\uffff",
DFA92_eofS:
"\u0001\u000b\u000c\uffff",
DFA92_minS:
"\u0001\u000f\u000c\uffff",
DFA92_maxS:
"\u0001\u00d9\u000c\uffff",
DFA92_acceptS:
"\u0001\uffff\u0001\u0001\u0009\uffff\u0001\u0002\u0001\uffff",
DFA92_specialS:
"\u000d\uffff}>",
DFA92_transitionS: [
"\u0001\u000b\u003e\uffff\u0001\u0001\u0036\uffff\u0015\u0001"+
"\u0008\uffff\u0002\u0001\u0001\uffff\u0006\u0001\u000f\uffff"+
"\u0001\u0001\u000c\uffff\u0006\u0001\u0001\uffff\u000c\u0001",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA92_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_eotS),
DFA92_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_eofS),
DFA92_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA92_minS),
DFA92_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA92_maxS),
DFA92_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_acceptS),
DFA92_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_specialS),
DFA92_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA92_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA92 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 92;
this.eot = Ham4Parser.DFA92_eot;
this.eof = Ham4Parser.DFA92_eof;
this.min = Ham4Parser.DFA92_min;
this.max = Ham4Parser.DFA92_max;
this.accept = Ham4Parser.DFA92_accept;
this.special = Ham4Parser.DFA92_special;
this.transition = Ham4Parser.DFA92_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA92, org.antlr.runtime.DFA, {
getDescription: function() {
return "2397:9: ( action2t a2tlist )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA93_eotS:
"\u000d\uffff",
DFA93_eofS:
"\u0001\u000b\u000c\uffff",
DFA93_minS:
"\u0001\u000f\u000c\uffff",
DFA93_maxS:
"\u0001\u00d9\u000c\uffff",
DFA93_acceptS:
"\u0001\uffff\u0001\u0001\u0009\uffff\u0001\u0002\u0001\uffff",
DFA93_specialS:
"\u000d\uffff}>",
DFA93_transitionS: [
"\u0001\u000b\u003e\uffff\u0001\u0001\u0036\uffff\u0015\u0001"+
"\u0008\uffff\u0002\u0001\u0001\uffff\u0006\u0001\u000f\uffff"+
"\u0001\u0001\u000c\uffff\u0006\u0001\u0001\uffff\u000c\u0001",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA93_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_eotS),
DFA93_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_eofS),
DFA93_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA93_minS),
DFA93_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA93_maxS),
DFA93_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_acceptS),
DFA93_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_specialS),
DFA93_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA93_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA93 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 93;
this.eot = Ham4Parser.DFA93_eot;
this.eof = Ham4Parser.DFA93_eof;
this.min = Ham4Parser.DFA93_min;
this.max = Ham4Parser.DFA93_max;
this.accept = Ham4Parser.DFA93_accept;
this.special = Ham4Parser.DFA93_special;
this.transition = Ham4Parser.DFA93_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA93, org.antlr.runtime.DFA, {
getDescription: function() {
return "2422:9: ( action1t a1tlist )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA95_eotS:
"\u000e\uffff",
DFA95_eofS:
"\u000e\uffff",
DFA95_minS:
"\u0001\u004e\u000a\u0000\u0003\uffff",
DFA95_maxS:
"\u0001\u00d9\u000a\u0000\u0003\uffff",
DFA95_acceptS:
"\u000b\uffff\u0001\u0001\u0001\u0002\u0001\u0003",
DFA95_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
"\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0003"+
"\uffff}>",
DFA95_transitionS: [
"\u0001\u0006\u0036\uffff\u0001\u0001\u0012\u0002\u0002\u0004"+
"\u0008\uffff\u0001\u0007\u0001\u0009\u0001\uffff\u0006\u0003"+
"\u000f\uffff\u0001\u0008\u000c\uffff\u0005\u0005\u0001\u000a"+
"\u0001\uffff\u000c\u0003",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA95_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_eotS),
DFA95_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_eofS),
DFA95_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA95_minS),
DFA95_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA95_maxS),
DFA95_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_acceptS),
DFA95_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_specialS),
DFA95_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA95_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA95 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 95;
this.eot = Ham4Parser.DFA95_eot;
this.eof = Ham4Parser.DFA95_eof;
this.min = Ham4Parser.DFA95_min;
this.max = Ham4Parser.DFA95_max;
this.accept = Ham4Parser.DFA95_accept;
this.special = Ham4Parser.DFA95_special;
this.transition = Ham4Parser.DFA95_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA95, org.antlr.runtime.DFA, {
getDescription: function() {
return "2475:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA95_1 = input.LA(1);
var index95_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA95_2 = input.LA(1);
var index95_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_2);
if ( s>=0 ) return s;
break;
case 2 : 
var LA95_3 = input.LA(1);
var index95_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA95_4 = input.LA(1);
var index95_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_4);
if ( s>=0 ) return s;
break;
case 4 : 
var LA95_5 = input.LA(1);
var index95_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_5);
if ( s>=0 ) return s;
break;
case 5 : 
var LA95_6 = input.LA(1);
var index95_6 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_6);
if ( s>=0 ) return s;
break;
case 6 : 
var LA95_7 = input.LA(1);
var index95_7 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_7);
if ( s>=0 ) return s;
break;
case 7 : 
var LA95_8 = input.LA(1);
var index95_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_8);
if ( s>=0 ) return s;
break;
case 8 : 
var LA95_9 = input.LA(1);
var index95_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_9);
if ( s>=0 ) return s;
break;
case 9 : 
var LA95_10 = input.LA(1);
var index95_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_10);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 95, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA98_eotS:
"\u000e\uffff",
DFA98_eofS:
"\u000e\uffff",
DFA98_minS:
"\u0001\u004e\u0007\uffff\u0003\u0000\u0003\uffff",
DFA98_maxS:
"\u0001\u00d9\u0007\uffff\u0003\u0000\u0003\uffff",
DFA98_acceptS:
"\u0001\uffff\u0007\u0001\u0003\uffff\u0001\u0003\u0001\u0002\u0001"+
"\u0004",
DFA98_specialS:
"\u0001\u0000\u0007\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0003"+
"\uffff}>",
DFA98_transitionS: [
"\u0001\u0006\u0036\uffff\u0001\u0001\u0012\u0002\u0002\u0004"+
"\u0008\uffff\u0001\u0007\u0001\u0009\u0001\uffff\u0006\u0003"+
"\u000f\uffff\u0001\u0008\u000c\uffff\u0005\u0005\u0001\u000a"+
"\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA98_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_eotS),
DFA98_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_eofS),
DFA98_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA98_minS),
DFA98_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA98_maxS),
DFA98_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_acceptS),
DFA98_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_specialS),
DFA98_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA98_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA98 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 98;
this.eot = Ham4Parser.DFA98_eot;
this.eof = Ham4Parser.DFA98_eof;
this.min = Ham4Parser.DFA98_min;
this.max = Ham4Parser.DFA98_max;
this.accept = Ham4Parser.DFA98_accept;
this.special = Ham4Parser.DFA98_special;
this.transition = Ham4Parser.DFA98_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA98, org.antlr.runtime.DFA, {
getDescription: function() {
return "2553:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA98_0 = input.LA(1);
var index98_0 = input.index();
input.rewind();
s = -1;
if ( (LA98_0==HamNomotion) && (this.synpred31_Ham4Parser())) {s = 1;}
else if ( ((LA98_0>=HamMoveu && LA98_0<=HamMoveuo)) && (this.synpred31_Ham4Parser())) {s = 2;}
else if ( ((LA98_0>=HamCircleo && LA98_0<=HamCircler)||(LA98_0>=HamCircleul && LA98_0<=HamCircleuo)) && (this.synpred31_Ham4Parser())) {s = 3;}
else if ( ((LA98_0>=HamMovecross && LA98_0<=HamMovex)) && (this.synpred31_Ham4Parser())) {s = 4;}
else if ( ((LA98_0>=HamNodding && LA98_0<=HamStirccw)) && (this.synpred31_Ham4Parser())) {s = 5;}
else if ( (LA98_0==HamReplace) && (this.synpred31_Ham4Parser())) {s = 6;}
else if ( (LA98_0==HamFingerplay) && (this.synpred31_Ham4Parser())) {s = 7;}
else if ( (LA98_0==HamSeqbegin) ) {s = 8;}
else if ( (LA98_0==HamParbegin) ) {s = 9;}
else if ( (LA98_0==HamFusionbegin) ) {s = 10;}
input.seek(index98_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA98_8 = input.LA(1);
var index98_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 11;}
input.seek(index98_8);
if ( s>=0 ) return s;
break;
case 2 : 
var LA98_9 = input.LA(1);
var index98_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 12;}
input.seek(index98_9);
if ( s>=0 ) return s;
break;
case 3 : 
var LA98_10 = input.LA(1);
var index98_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 13;}
input.seek(index98_10);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 98, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA97_eotS:
"\u002c\uffff",
DFA97_eofS:
"\u0001\u001d\u002b\uffff",
DFA97_minS:
"\u0001\u000f\u0001\u0000\u0002\uffff\u0001\u0000\u0027\uffff",
DFA97_maxS:
"\u0001\u00d9\u0001\u0000\u0002\uffff\u0001\u0000\u0027\uffff",
DFA97_acceptS:
"\u0002\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0017\uffff\u0001"+
"\u0003\u000e\uffff",
DFA97_specialS:
"\u0001\u0000\u0001\u0001\u0002\uffff\u0001\u0002\u0027\uffff}>",
DFA97_transitionS: [
"\u0001\u001d\u0033\uffff\u0003\u0005\u0008\uffff\u0001\u001d"+
"\u0004\uffff\u0025\u0005\u0001\uffff\u0006\u0005\u0006\uffff"+
"\u0015\u001d\u0008\uffff\u0001\u001d\u0001\u0001\u0007\u001d"+
"\u0002\uffff\u0002\u0002\u0002\u0003\u0005\uffff\u0004\u001d"+
"\u0001\u0004\u0003\u001d\u0009\uffff\u0013\u001d",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA97_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_eotS),
DFA97_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_eofS),
DFA97_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA97_minS),
DFA97_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA97_maxS),
DFA97_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_acceptS),
DFA97_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_specialS),
DFA97_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA97_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA97 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 97;
this.eot = Ham4Parser.DFA97_eot;
this.eof = Ham4Parser.DFA97_eof;
this.min = Ham4Parser.DFA97_min;
this.max = Ham4Parser.DFA97_max;
this.accept = Ham4Parser.DFA97_accept;
this.special = Ham4Parser.DFA97_special;
this.transition = Ham4Parser.DFA97_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA97, org.antlr.runtime.DFA, {
getDescription: function() {
return "2558:17: ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA97_0 = input.LA(1);
var index97_0 = input.index();
input.rewind();
s = -1;
if ( (LA97_0==HamParbegin) ) {s = 1;}
else if ( ((LA97_0>=HamClose && LA97_0<=HamTouch)) && (this.synpred32_Ham4Parser())) {s = 2;}
else if ( ((LA97_0>=HamInterlock && LA97_0<=HamCross)) && (this.synpred32_Ham4Parser())) {s = 3;}
else if ( (LA97_0==HamSeqbegin) ) {s = 4;}
else if ( ((LA97_0>=HamEarlobe && LA97_0<=HamShouldertop)||(LA97_0>=HamTongue && LA97_0<=HamPinkyside)||(LA97_0>=HamFingertip && LA97_0<=HamFingerside)) ) {s = 5;}
else if ( (LA97_0==EOF||LA97_0==HamPlus||LA97_0==HamReplace||(LA97_0>=HamNomotion && LA97_0<=HamMovex)||LA97_0==HamFingerplay||(LA97_0>=HamParend && LA97_0<=HamCircler)||(LA97_0>=HamRepeatfromstart && LA97_0<=HamRepeatcontinueseveral)||(LA97_0>=HamSeqend && LA97_0<=HamRepeatreverse)||(LA97_0>=HamNodding && LA97_0<=HamCircleuo)) ) {s = 29;}
input.seek(index97_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA97_1 = input.LA(1);
var index97_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred32_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 29;}
input.seek(index97_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA97_4 = input.LA(1);
var index97_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred32_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 29;}
input.seek(index97_4);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 97, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA96_eotS:
"\u0013\uffff",
DFA96_eofS:
"\u0001\u0002\u0012\uffff",
DFA96_minS:
"\u0001\u000f\u0012\uffff",
DFA96_maxS:
"\u0001\u00d9\u0012\uffff",
DFA96_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0010\uffff",
DFA96_specialS:
"\u0013\uffff}>",
DFA96_transitionS: [
"\u0001\u0002\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0001\uffff\u0001\u0001\u0006\uffff\u0009\u0002\u000b\uffff"+
"\u0008\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA96_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_eotS),
DFA96_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_eofS),
DFA96_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA96_minS),
DFA96_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA96_maxS),
DFA96_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_acceptS),
DFA96_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_specialS),
DFA96_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA96_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA96 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 96;
this.eot = Ham4Parser.DFA96_eot;
this.eof = Ham4Parser.DFA96_eof;
this.min = Ham4Parser.DFA96_min;
this.max = Ham4Parser.DFA96_max;
this.accept = Ham4Parser.DFA96_accept;
this.special = Ham4Parser.DFA96_special;
this.transition = Ham4Parser.DFA96_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA96, org.antlr.runtime.DFA, {
getDescription: function() {
return "2564:21: ( HamLargemod )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA102_eotS:
"\u000d\uffff",
DFA102_eofS:
"\u000d\uffff",
DFA102_minS:
"\u0001\u004e\u0007\uffff\u0001\u0000\u0004\uffff",
DFA102_maxS:
"\u0001\u00d9\u0007\uffff\u0001\u0000\u0004\uffff",
DFA102_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0006\uffff\u0001\u0004\u0001"+
"\u0006\u0001\u0003\u0001\u0005",
DFA102_specialS:
"\u0008\uffff\u0001\u0000\u0004\uffff}>",
DFA102_transitionS: [
"\u0001\u0002\u0036\uffff\u0001\u0001\u0014\u0002\u0008\uffff"+
"\u0001\u0002\u0001\u0009\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0008\u000c\uffff\u0005\u0002\u0001\u000a\u0001\uffff"+
"\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA102_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_eotS),
DFA102_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_eofS),
DFA102_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA102_minS),
DFA102_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA102_maxS),
DFA102_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_acceptS),
DFA102_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_specialS),
DFA102_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA102_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA102 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 102;
this.eot = Ham4Parser.DFA102_eot;
this.eof = Ham4Parser.DFA102_eof;
this.min = Ham4Parser.DFA102_min;
this.max = Ham4Parser.DFA102_max;
this.accept = Ham4Parser.DFA102_accept;
this.special = Ham4Parser.DFA102_special;
this.transition = Ham4Parser.DFA102_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA102, org.antlr.runtime.DFA, {
getDescription: function() {
return "2624:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA102_8 = input.LA(1);
var index102_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred33_Ham4Parser()) ) {s = 11;}
else if ( (true) ) {s = 12;}
input.seek(index102_8);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 102, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA103_eotS:
"\u000d\uffff",
DFA103_eofS:
"\u000d\uffff",
DFA103_minS:
"\u0001\u000f\u000c\uffff",
DFA103_maxS:
"\u0001\u00d9\u000c\uffff",
DFA103_acceptS:
"\u0001\uffff\u0001\u0002\u0001\uffff\u0001\u0001\u0009\uffff",
DFA103_specialS:
"\u000d\uffff}>",
DFA103_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0003\u0036\uffff\u0015\u0003"+
"\u0008\uffff\u0002\u0003\u0001\u0001\u0006\u0003\u000f\uffff"+
"\u0001\u0003\u000c\uffff\u0006\u0003\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA103_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_eotS),
DFA103_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_eofS),
DFA103_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA103_minS),
DFA103_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA103_maxS),
DFA103_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_acceptS),
DFA103_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_specialS),
DFA103_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA103_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA103 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 103;
this.eot = Ham4Parser.DFA103_eot;
this.eof = Ham4Parser.DFA103_eof;
this.min = Ham4Parser.DFA103_min;
this.max = Ham4Parser.DFA103_max;
this.accept = Ham4Parser.DFA103_accept;
this.special = Ham4Parser.DFA103_special;
this.transition = Ham4Parser.DFA103_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA103, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2655:4: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA104_eotS:
"\u000d\uffff",
DFA104_eofS:
"\u000d\uffff",
DFA104_minS:
"\u0001\u000f\u000c\uffff",
DFA104_maxS:
"\u0001\u00d9\u000c\uffff",
DFA104_acceptS:
"\u0001\uffff\u0001\u0002\u0001\uffff\u0001\u0001\u0009\uffff",
DFA104_specialS:
"\u000d\uffff}>",
DFA104_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0003\u0036\uffff\u0015\u0003"+
"\u0008\uffff\u0002\u0003\u0001\u0001\u0006\u0003\u000f\uffff"+
"\u0001\u0003\u000c\uffff\u0006\u0003\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA104_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_eotS),
DFA104_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_eofS),
DFA104_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA104_minS),
DFA104_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA104_maxS),
DFA104_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_acceptS),
DFA104_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_specialS),
DFA104_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA104_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA104 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 104;
this.eot = Ham4Parser.DFA104_eot;
this.eof = Ham4Parser.DFA104_eof;
this.min = Ham4Parser.DFA104_min;
this.max = Ham4Parser.DFA104_max;
this.accept = Ham4Parser.DFA104_accept;
this.special = Ham4Parser.DFA104_special;
this.transition = Ham4Parser.DFA104_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA104, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2659:4: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA105_eotS:
"\u000c\uffff",
DFA105_eofS:
"\u000c\uffff",
DFA105_minS:
"\u0001\u004e\u000b\uffff",
DFA105_maxS:
"\u0001\u00d9\u000b\uffff",
DFA105_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA105_specialS:
"\u000c\uffff}>",
DFA105_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA105_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_eotS),
DFA105_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_eofS),
DFA105_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA105_minS),
DFA105_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA105_maxS),
DFA105_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_acceptS),
DFA105_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_specialS),
DFA105_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA105_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA105 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 105;
this.eot = Ham4Parser.DFA105_eot;
this.eof = Ham4Parser.DFA105_eof;
this.min = Ham4Parser.DFA105_min;
this.max = Ham4Parser.DFA105_max;
this.accept = Ham4Parser.DFA105_accept;
this.special = Ham4Parser.DFA105_special;
this.transition = Ham4Parser.DFA105_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA105, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2681:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA106_eotS:
"\u000c\uffff",
DFA106_eofS:
"\u000c\uffff",
DFA106_minS:
"\u0001\u004e\u000b\uffff",
DFA106_maxS:
"\u0001\u00d9\u000b\uffff",
DFA106_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA106_specialS:
"\u000c\uffff}>",
DFA106_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA106_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_eotS),
DFA106_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_eofS),
DFA106_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA106_minS),
DFA106_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA106_maxS),
DFA106_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_acceptS),
DFA106_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_specialS),
DFA106_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA106_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA106 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 106;
this.eot = Ham4Parser.DFA106_eot;
this.eof = Ham4Parser.DFA106_eof;
this.min = Ham4Parser.DFA106_min;
this.max = Ham4Parser.DFA106_max;
this.accept = Ham4Parser.DFA106_accept;
this.special = Ham4Parser.DFA106_special;
this.transition = Ham4Parser.DFA106_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA106, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2706:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA107_eotS:
"\u000c\uffff",
DFA107_eofS:
"\u000c\uffff",
DFA107_minS:
"\u0001\u004e\u000b\uffff",
DFA107_maxS:
"\u0001\u00d9\u000b\uffff",
DFA107_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA107_specialS:
"\u000c\uffff}>",
DFA107_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA107_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_eotS),
DFA107_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_eofS),
DFA107_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA107_minS),
DFA107_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA107_maxS),
DFA107_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_acceptS),
DFA107_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_specialS),
DFA107_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA107_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA107 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 107;
this.eot = Ham4Parser.DFA107_eot;
this.eof = Ham4Parser.DFA107_eof;
this.min = Ham4Parser.DFA107_min;
this.max = Ham4Parser.DFA107_max;
this.accept = Ham4Parser.DFA107_accept;
this.special = Ham4Parser.DFA107_special;
this.transition = Ham4Parser.DFA107_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA107, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2731:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA108_eotS:
"\u000c\uffff",
DFA108_eofS:
"\u000c\uffff",
DFA108_minS:
"\u0001\u004e\u000b\uffff",
DFA108_maxS:
"\u0001\u00d9\u000b\uffff",
DFA108_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA108_specialS:
"\u000c\uffff}>",
DFA108_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA108_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_eotS),
DFA108_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_eofS),
DFA108_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA108_minS),
DFA108_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA108_maxS),
DFA108_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_acceptS),
DFA108_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_specialS),
DFA108_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA108_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA108 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 108;
this.eot = Ham4Parser.DFA108_eot;
this.eof = Ham4Parser.DFA108_eof;
this.min = Ham4Parser.DFA108_min;
this.max = Ham4Parser.DFA108_max;
this.accept = Ham4Parser.DFA108_accept;
this.special = Ham4Parser.DFA108_special;
this.transition = Ham4Parser.DFA108_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA108, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2818:9: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA111_eotS:
"\u001e\uffff",
DFA111_eofS:
"\u001e\uffff",
DFA111_minS:
"\u0001\u0043\u001d\uffff",
DFA111_maxS:
"\u0001\u00d9\u001d\uffff",
DFA111_acceptS:
"\u0001\uffff\u0001\u0001\u0012\uffff\u0001\u0002\u0009\uffff",
DFA111_specialS:
"\u001e\uffff}>",
DFA111_transitionS: [
"\u0003\u0001\u0008\uffff\u0001\u0014\u0004\uffff\u0003\u0001"+
"\u0001\uffff\u0015\u0001\u0019\uffff\u0015\u0014\u0008\uffff"+
"\u0002\u0014\u0001\uffff\u0006\u0014\u000f\uffff\u0001\u0014"+
"\u000c\uffff\u0006\u0014\u0001\uffff\u000c\u0014",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA111_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_eotS),
DFA111_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_eofS),
DFA111_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA111_minS),
DFA111_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA111_maxS),
DFA111_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_acceptS),
DFA111_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_specialS),
DFA111_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA111_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA111 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 111;
this.eot = Ham4Parser.DFA111_eot;
this.eof = Ham4Parser.DFA111_eof;
this.min = Ham4Parser.DFA111_min;
this.max = Ham4Parser.DFA111_max;
this.accept = Ham4Parser.DFA111_accept;
this.special = Ham4Parser.DFA111_special;
this.transition = Ham4Parser.DFA111_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA111, org.antlr.runtime.DFA, {
getDescription: function() {
return "2855:9: ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA109_eotS:
"\u0014\uffff",
DFA109_eofS:
"\u0014\uffff",
DFA109_minS:
"\u0001\u0043\u0011\uffff\u0001\u0000\u0001\uffff",
DFA109_maxS:
"\u0001\u006b\u0011\uffff\u0001\u0000\u0001\uffff",
DFA109_acceptS:
"\u0001\uffff\u0011\u0001\u0001\uffff\u0001\u0002",
DFA109_specialS:
"\u0001\u0000\u0011\uffff\u0001\u0001\u0001\uffff}>",
DFA109_transitionS: [
"\u0001\u0011\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007"+
"\u0001\u0008\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002"+
"\u0001\u0003\u0001\u0004\u0001\u0008\u0001\u0005\u0002\u0011"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d"+
"\u0001\u000e\u0001\u0010\u0002\u0012\u0004\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA109_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_eotS),
DFA109_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_eofS),
DFA109_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA109_minS),
DFA109_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA109_maxS),
DFA109_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_acceptS),
DFA109_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_specialS),
DFA109_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA109_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA109 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 109;
this.eot = Ham4Parser.DFA109_eot;
this.eof = Ham4Parser.DFA109_eof;
this.min = Ham4Parser.DFA109_min;
this.max = Ham4Parser.DFA109_max;
this.accept = Ham4Parser.DFA109_accept;
this.special = Ham4Parser.DFA109_special;
this.transition = Ham4Parser.DFA109_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA109, org.antlr.runtime.DFA, {
getDescription: function() {
return "2856:4: ( ( levelbody )=> levelbody | levelarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA109_0 = input.LA(1);
var index109_0 = input.index();
input.rewind();
s = -1;
if ( (LA109_0==HamHead) && (this.synpred34_Ham4Parser())) {s = 1;}
else if ( (LA109_0==HamHeadtop) && (this.synpred34_Ham4Parser())) {s = 2;}
else if ( (LA109_0==HamForehead) && (this.synpred34_Ham4Parser())) {s = 3;}
else if ( (LA109_0==HamEyebrows) && (this.synpred34_Ham4Parser())) {s = 4;}
else if ( (LA109_0==HamNose) && (this.synpred34_Ham4Parser())) {s = 5;}
else if ( (LA109_0==HamNostrils) && (this.synpred34_Ham4Parser())) {s = 6;}
else if ( (LA109_0==HamTongue) && (this.synpred34_Ham4Parser())) {s = 7;}
else if ( (LA109_0==HamTeeth||LA109_0==HamEyes||LA109_0==HamLips) && (this.synpred34_Ham4Parser())) {s = 8;}
else if ( (LA109_0==HamChin) && (this.synpred34_Ham4Parser())) {s = 9;}
else if ( (LA109_0==HamUnderchin) && (this.synpred34_Ham4Parser())) {s = 10;}
else if ( (LA109_0==HamNeck) && (this.synpred34_Ham4Parser())) {s = 11;}
else if ( (LA109_0==HamShouldertop) && (this.synpred34_Ham4Parser())) {s = 12;}
else if ( (LA109_0==HamShoulders) && (this.synpred34_Ham4Parser())) {s = 13;}
else if ( (LA109_0==HamChest) && (this.synpred34_Ham4Parser())) {s = 14;}
else if ( (LA109_0==HamStomach) && (this.synpred34_Ham4Parser())) {s = 15;}
else if ( (LA109_0==HamBelowstomach) && (this.synpred34_Ham4Parser())) {s = 16;}
else if ( (LA109_0==HamEarlobe||(LA109_0>=HamEar && LA109_0<=HamCheek)) && (this.synpred34_Ham4Parser())) {s = 17;}
else if ( ((LA109_0>=HamLrbeside && LA109_0<=HamLrat)) ) {s = 18;}
else if ( ((LA109_0>=HamUpperarm && LA109_0<=HamLowerarm)) ) {s = 19;}
input.seek(index109_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA109_18 = input.LA(1);
var index109_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred34_Ham4Parser()) ) {s = 17;}
else if ( (true) ) {s = 19;}
input.seek(index109_18);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 109, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA110_eotS:
"\u000c\uffff",
DFA110_eofS:
"\u000c\uffff",
DFA110_minS:
"\u0001\u004e\u000b\uffff",
DFA110_maxS:
"\u0001\u00d9\u000b\uffff",
DFA110_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA110_specialS:
"\u000c\uffff}>",
DFA110_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA110_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_eotS),
DFA110_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_eofS),
DFA110_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA110_minS),
DFA110_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA110_maxS),
DFA110_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_acceptS),
DFA110_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_specialS),
DFA110_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA110_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA110 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 110;
this.eot = Ham4Parser.DFA110_eot;
this.eof = Ham4Parser.DFA110_eof;
this.min = Ham4Parser.DFA110_min;
this.max = Ham4Parser.DFA110_max;
this.accept = Ham4Parser.DFA110_accept;
this.special = Ham4Parser.DFA110_special;
this.transition = Ham4Parser.DFA110_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA110, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2864:10: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA112_eotS:
"\u000c\uffff",
DFA112_eofS:
"\u000c\uffff",
DFA112_minS:
"\u0001\u004e\u000b\uffff",
DFA112_maxS:
"\u0001\u00d9\u000b\uffff",
DFA112_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA112_specialS:
"\u000c\uffff}>",
DFA112_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA112_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_eotS),
DFA112_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_eofS),
DFA112_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA112_minS),
DFA112_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA112_maxS),
DFA112_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_acceptS),
DFA112_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_specialS),
DFA112_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA112_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA112 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 112;
this.eot = Ham4Parser.DFA112_eot;
this.eof = Ham4Parser.DFA112_eof;
this.min = Ham4Parser.DFA112_min;
this.max = Ham4Parser.DFA112_max;
this.accept = Ham4Parser.DFA112_accept;
this.special = Ham4Parser.DFA112_special;
this.transition = Ham4Parser.DFA112_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA112, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2892:9: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA113_eotS:
"\u000c\uffff",
DFA113_eofS:
"\u000c\uffff",
DFA113_minS:
"\u0001\u004e\u000b\uffff",
DFA113_maxS:
"\u0001\u00d9\u000b\uffff",
DFA113_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA113_specialS:
"\u000c\uffff}>",
DFA113_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA113_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_eotS),
DFA113_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_eofS),
DFA113_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA113_minS),
DFA113_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA113_maxS),
DFA113_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_acceptS),
DFA113_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_specialS),
DFA113_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA113_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA113 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 113;
this.eot = Ham4Parser.DFA113_eot;
this.eof = Ham4Parser.DFA113_eof;
this.min = Ham4Parser.DFA113_min;
this.max = Ham4Parser.DFA113_max;
this.accept = Ham4Parser.DFA113_accept;
this.special = Ham4Parser.DFA113_special;
this.transition = Ham4Parser.DFA113_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA113, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2919:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA114_eotS:
"\u000c\uffff",
DFA114_eofS:
"\u000c\uffff",
DFA114_minS:
"\u0001\u004e\u000b\uffff",
DFA114_maxS:
"\u0001\u00d9\u000b\uffff",
DFA114_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA114_specialS:
"\u000c\uffff}>",
DFA114_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA114_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_eotS),
DFA114_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_eofS),
DFA114_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA114_minS),
DFA114_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA114_maxS),
DFA114_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_acceptS),
DFA114_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_specialS),
DFA114_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA114_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA114 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 114;
this.eot = Ham4Parser.DFA114_eot;
this.eof = Ham4Parser.DFA114_eof;
this.min = Ham4Parser.DFA114_min;
this.max = Ham4Parser.DFA114_max;
this.accept = Ham4Parser.DFA114_accept;
this.special = Ham4Parser.DFA114_special;
this.transition = Ham4Parser.DFA114_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA114, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2946:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA115_eotS:
"\u000c\uffff",
DFA115_eofS:
"\u000c\uffff",
DFA115_minS:
"\u0001\u004e\u000b\uffff",
DFA115_maxS:
"\u0001\u00d9\u000b\uffff",
DFA115_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA115_specialS:
"\u000c\uffff}>",
DFA115_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA115_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_eotS),
DFA115_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_eofS),
DFA115_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA115_minS),
DFA115_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA115_maxS),
DFA115_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_acceptS),
DFA115_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_specialS),
DFA115_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA115_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA115 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 115;
this.eot = Ham4Parser.DFA115_eot;
this.eof = Ham4Parser.DFA115_eof;
this.min = Ham4Parser.DFA115_min;
this.max = Ham4Parser.DFA115_max;
this.accept = Ham4Parser.DFA115_accept;
this.special = Ham4Parser.DFA115_special;
this.transition = Ham4Parser.DFA115_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA115, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2973:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA116_eotS:
"\u0012\uffff",
DFA116_eofS:
"\u0001\u0004\u0011\uffff",
DFA116_minS:
"\u0001\u000f\u0001\u0000\u0010\uffff",
DFA116_maxS:
"\u0001\u00d9\u0001\u0000\u0010\uffff",
DFA116_acceptS:
"\u0002\uffff\u0002\u0001\u0001\u0002\u000d\uffff",
DFA116_specialS:
"\u0001\u0000\u0001\u0001\u0010\uffff}>",
DFA116_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0036\uffff\u0015\u0004"+
"\u0008\uffff\u0009\u0004\u000b\uffff\u0004\u0002\u0001\u0001"+
"\u0001\u0004\u0001\u0003\u0001\u0002\u0009\uffff\u0013\u0004",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA116_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_eotS),
DFA116_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_eofS),
DFA116_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA116_minS),
DFA116_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA116_maxS),
DFA116_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_acceptS),
DFA116_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_specialS),
DFA116_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA116_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA116 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 116;
this.eot = Ham4Parser.DFA116_eot;
this.eof = Ham4Parser.DFA116_eof;
this.min = Ham4Parser.DFA116_min;
this.max = Ham4Parser.DFA116_max;
this.accept = Ham4Parser.DFA116_accept;
this.special = Ham4Parser.DFA116_special;
this.transition = Ham4Parser.DFA116_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA116, org.antlr.runtime.DFA, {
getDescription: function() {
return "2999:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA116_0 = input.LA(1);
var index116_0 = input.index();
input.rewind();
s = -1;
if ( (LA116_0==HamSeqbegin) ) {s = 1;}
else if ( ((LA116_0>=HamRepeatfromstart && LA116_0<=HamRepeatcontinueseveral)||LA116_0==HamRepeatreverse) && (this.synpred35_Ham4Parser())) {s = 2;}
else if ( (LA116_0==HamAlternatingmotion) && (this.synpred35_Ham4Parser())) {s = 3;}
else if ( (LA116_0==EOF||LA116_0==HamPlus||LA116_0==HamReplace||(LA116_0>=HamNomotion && LA116_0<=HamMovex)||(LA116_0>=HamFingerplay && LA116_0<=HamCircler)||LA116_0==HamSeqend||(LA116_0>=HamNodding && LA116_0<=HamCircleuo)) ) {s = 4;}
input.seek(index116_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA116_1 = input.LA(1);
var index116_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred35_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 4;}
input.seek(index116_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 116, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA127_eotS:
"\u0030\uffff",
DFA127_eofS:
"\u0001\u0002\u002f\uffff",
DFA127_minS:
"\u0001\u000f\u002f\uffff",
DFA127_maxS:
"\u0001\u00d9\u002f\uffff",
DFA127_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002d\uffff",
DFA127_specialS:
"\u0030\uffff}>",
DFA127_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u000f\u0002\u0002\uffff\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA127_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_eotS),
DFA127_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_eofS),
DFA127_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA127_minS),
DFA127_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA127_maxS),
DFA127_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_acceptS),
DFA127_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_specialS),
DFA127_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA127_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA127 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 127;
this.eot = Ham4Parser.DFA127_eot;
this.eof = Ham4Parser.DFA127_eof;
this.min = Ham4Parser.DFA127_min;
this.max = Ham4Parser.DFA127_max;
this.accept = Ham4Parser.DFA127_accept;
this.special = Ham4Parser.DFA127_special;
this.transition = Ham4Parser.DFA127_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA127, org.antlr.runtime.DFA, {
getDescription: function() {
return "3198:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA128_eotS:
"\u002f\uffff",
DFA128_eofS:
"\u0001\u0003\u002e\uffff",
DFA128_minS:
"\u0001\u000f\u002e\uffff",
DFA128_maxS:
"\u0001\u00d9\u002e\uffff",
DFA128_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u002b\uffff",
DFA128_specialS:
"\u002f\uffff}>",
DFA128_transitionS: [
"\u0001\u0003\u0033\uffff\u0003\u0003\u0008\uffff\u0001\u0003"+
"\u0004\uffff\u0025\u0003\u0001\uffff\u0006\u0003\u0006\uffff"+
"\u0015\u0003\u0002\uffff\u0004\u0001\u0002\u0002\u0009\u0003"+
"\u0002\uffff\u0011\u0003\u0009\uffff\u0013\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA128_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_eotS),
DFA128_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_eofS),
DFA128_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA128_minS),
DFA128_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA128_maxS),
DFA128_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_acceptS),
DFA128_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_specialS),
DFA128_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA128_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA128 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 128;
this.eot = Ham4Parser.DFA128_eot;
this.eof = Ham4Parser.DFA128_eof;
this.min = Ham4Parser.DFA128_min;
this.max = Ham4Parser.DFA128_max;
this.accept = Ham4Parser.DFA128_accept;
this.special = Ham4Parser.DFA128_special;
this.transition = Ham4Parser.DFA128_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA128, org.antlr.runtime.DFA, {
getDescription: function() {
return "3199:13: ( arckind | zigzag )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA129_eotS:
"\u0032\uffff",
DFA129_eofS:
"\u0001\u0002\u0031\uffff",
DFA129_minS:
"\u0001\u000f\u0031\uffff",
DFA129_maxS:
"\u0001\u00d9\u0031\uffff",
DFA129_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002f\uffff",
DFA129_specialS:
"\u0032\uffff}>",
DFA129_transitionS: [
"\u0001\u0002\u0001\uffff\u0009\u0002\u0029\uffff\u0003\u0002"+
"\u0008\uffff\u0001\u0002\u0004\uffff\u0025\u0002\u0001\uffff"+
"\u0006\u0002\u0006\uffff\u0015\u0002\u0002\u0001\u0006\uffff"+
"\u001c\u0002\u0002\uffff\u0004\u0002\u0003\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA129_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_eotS),
DFA129_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_eofS),
DFA129_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA129_minS),
DFA129_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA129_maxS),
DFA129_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_acceptS),
DFA129_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_specialS),
DFA129_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA129_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA129 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 129;
this.eot = Ham4Parser.DFA129_eot;
this.eof = Ham4Parser.DFA129_eof;
this.min = Ham4Parser.DFA129_min;
this.max = Ham4Parser.DFA129_max;
this.accept = Ham4Parser.DFA129_accept;
this.special = Ham4Parser.DFA129_special;
this.transition = Ham4Parser.DFA129_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA129, org.antlr.runtime.DFA, {
getDescription: function() {
return "3206:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA130_eotS:
"\u0031\uffff",
DFA130_eofS:
"\u0001\u0003\u0030\uffff",
DFA130_minS:
"\u0001\u000f\u0030\uffff",
DFA130_maxS:
"\u0001\u00d9\u0030\uffff",
DFA130_acceptS:
"\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0002\u002d\uffff",
DFA130_specialS:
"\u0031\uffff}>",
DFA130_transitionS: [
"\u0001\u0003\u0001\uffff\u0009\u0001\u0029\uffff\u0003\u0003"+
"\u0008\uffff\u0001\u0003\u0004\uffff\u0025\u0003\u0001\uffff"+
"\u0006\u0003\u0006\uffff\u0015\u0003\u0008\uffff\u001c\u0003"+
"\u0002\uffff\u0004\u0003\u0003\uffff\u0013\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA130_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_eotS),
DFA130_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_eofS),
DFA130_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA130_minS),
DFA130_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA130_maxS),
DFA130_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_acceptS),
DFA130_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_specialS),
DFA130_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA130_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA130 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 130;
this.eot = Ham4Parser.DFA130_eot;
this.eof = Ham4Parser.DFA130_eof;
this.min = Ham4Parser.DFA130_min;
this.max = Ham4Parser.DFA130_max;
this.accept = Ham4Parser.DFA130_accept;
this.special = Ham4Parser.DFA130_special;
this.transition = Ham4Parser.DFA130_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA130, org.antlr.runtime.DFA, {
getDescription: function() {
return "3207:13: ( revolutions )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA131_eotS:
"\u002f\uffff",
DFA131_eofS:
"\u0001\u0002\u002e\uffff",
DFA131_minS:
"\u0001\u000f\u002e\uffff",
DFA131_maxS:
"\u0001\u00d9\u002e\uffff",
DFA131_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002c\uffff",
DFA131_specialS:
"\u002f\uffff}>",
DFA131_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u001c\u0002\u0002\uffff\u0004\u0001"+
"\u0003\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA131_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_eotS),
DFA131_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_eofS),
DFA131_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA131_minS),
DFA131_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA131_maxS),
DFA131_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_acceptS),
DFA131_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_specialS),
DFA131_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA131_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA131 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 131;
this.eot = Ham4Parser.DFA131_eot;
this.eof = Ham4Parser.DFA131_eof;
this.min = Ham4Parser.DFA131_min;
this.max = Ham4Parser.DFA131_max;
this.accept = Ham4Parser.DFA131_accept;
this.special = Ham4Parser.DFA131_special;
this.transition = Ham4Parser.DFA131_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA131, org.antlr.runtime.DFA, {
getDescription: function() {
return "3208:13: ( ellipse )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA132_eotS:
"\u002e\uffff",
DFA132_eofS:
"\u0001\u0002\u002d\uffff",
DFA132_minS:
"\u0001\u000f\u002d\uffff",
DFA132_maxS:
"\u0001\u00d9\u002d\uffff",
DFA132_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA132_specialS:
"\u002e\uffff}>",
DFA132_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u0009\u0002\u0002\u0001\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA132_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_eotS),
DFA132_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_eofS),
DFA132_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA132_minS),
DFA132_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA132_maxS),
DFA132_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_acceptS),
DFA132_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_specialS),
DFA132_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA132_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA132 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 132;
this.eot = Ham4Parser.DFA132_eot;
this.eof = Ham4Parser.DFA132_eof;
this.min = Ham4Parser.DFA132_min;
this.max = Ham4Parser.DFA132_max;
this.accept = Ham4Parser.DFA132_accept;
this.special = Ham4Parser.DFA132_special;
this.transition = Ham4Parser.DFA132_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA132, org.antlr.runtime.DFA, {
getDescription: function() {
return "3209:13: ( sizechangenonlinear )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA133_eotS:
"\u002e\uffff",
DFA133_eofS:
"\u0001\u0002\u002d\uffff",
DFA133_minS:
"\u0001\u000f\u002d\uffff",
DFA133_maxS:
"\u0001\u00d9\u002d\uffff",
DFA133_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA133_specialS:
"\u002e\uffff}>",
DFA133_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u0006\uffff\u0009\u0002\u0002\uffff"+
"\u0011\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA133_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_eotS),
DFA133_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_eofS),
DFA133_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA133_minS),
DFA133_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA133_maxS),
DFA133_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_acceptS),
DFA133_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_specialS),
DFA133_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA133_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA133 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 133;
this.eot = Ham4Parser.DFA133_eot;
this.eof = Ham4Parser.DFA133_eof;
this.min = Ham4Parser.DFA133_min;
this.max = Ham4Parser.DFA133_max;
this.accept = Ham4Parser.DFA133_accept;
this.special = Ham4Parser.DFA133_special;
this.transition = Ham4Parser.DFA133_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA133, org.antlr.runtime.DFA, {
getDescription: function() {
return "3212:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA134_eotS:
"\u002e\uffff",
DFA134_eofS:
"\u0001\u0002\u002d\uffff",
DFA134_minS:
"\u0001\u000f\u002d\uffff",
DFA134_maxS:
"\u0001\u00d9\u002d\uffff",
DFA134_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA134_specialS:
"\u002e\uffff}>",
DFA134_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u0006\uffff\u0009\u0002\u0002\uffff"+
"\u0011\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA134_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_eotS),
DFA134_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_eofS),
DFA134_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA134_minS),
DFA134_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA134_maxS),
DFA134_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_acceptS),
DFA134_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_specialS),
DFA134_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA134_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA134 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 134;
this.eot = Ham4Parser.DFA134_eot;
this.eof = Ham4Parser.DFA134_eof;
this.min = Ham4Parser.DFA134_min;
this.max = Ham4Parser.DFA134_max;
this.accept = Ham4Parser.DFA134_accept;
this.special = Ham4Parser.DFA134_special;
this.transition = Ham4Parser.DFA134_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA134, org.antlr.runtime.DFA, {
getDescription: function() {
return "3215:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA136_eotS:
"\u002e\uffff",
DFA136_eofS:
"\u0001\u0002\u002d\uffff",
DFA136_minS:
"\u0001\u000f\u0001\u0000\u002c\uffff",
DFA136_maxS:
"\u0001\u00d9\u0001\u0000\u002c\uffff",
DFA136_acceptS:
"\u0002\uffff\u0001\u0002\u002a\uffff\u0001\u0001",
DFA136_specialS:
"\u0001\uffff\u0001\u0000\u002c\uffff}>",
DFA136_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u0009\u0002\u0002\uffff\u000d\u0002"+
"\u0001\u0001\u0003\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA136_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_eotS),
DFA136_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_eofS),
DFA136_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA136_minS),
DFA136_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA136_maxS),
DFA136_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_acceptS),
DFA136_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_specialS),
DFA136_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA136_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA136 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 136;
this.eot = Ham4Parser.DFA136_eot;
this.eof = Ham4Parser.DFA136_eof;
this.min = Ham4Parser.DFA136_min;
this.max = Ham4Parser.DFA136_max;
this.accept = Ham4Parser.DFA136_accept;
this.special = Ham4Parser.DFA136_special;
this.transition = Ham4Parser.DFA136_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA136, org.antlr.runtime.DFA, {
getDescription: function() {
return "3221:9: ( ( HamSeqbegin HamBrushing )=> brushingcontact )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA136_1 = input.LA(1);
var index136_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred37_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 2;}
input.seek(index136_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 136, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA137_eotS:
"\u002e\uffff",
DFA137_eofS:
"\u0001\u0003\u002d\uffff",
DFA137_minS:
"\u0001\u000f\u0002\u0000\u002b\uffff",
DFA137_maxS:
"\u0001\u00d9\u0002\u0000\u002b\uffff",
DFA137_acceptS:
"\u0003\uffff\u0001\u0002\u0029\uffff\u0001\u0001",
DFA137_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u002b\uffff}>",
DFA137_transitionS: [
"\u0001\u0003\u0033\uffff\u0003\u0003\u0008\uffff\u0001\u0003"+
"\u0004\uffff\u001e\u0003\u0001\u0001\u0004\u0002\u0002\u0003"+
"\u0001\uffff\u0006\u0003\u0006\uffff\u0015\u0003\u0008\uffff"+
"\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA137_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_eotS),
DFA137_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_eofS),
DFA137_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA137_minS),
DFA137_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA137_maxS),
DFA137_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_acceptS),
DFA137_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_specialS),
DFA137_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA137_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA137 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 137;
this.eot = Ham4Parser.DFA137_eot;
this.eof = Ham4Parser.DFA137_eof;
this.min = Ham4Parser.DFA137_min;
this.max = Ham4Parser.DFA137_max;
this.accept = Ham4Parser.DFA137_accept;
this.special = Ham4Parser.DFA137_special;
this.transition = Ham4Parser.DFA137_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA137, org.antlr.runtime.DFA, {
getDescription: function() {
return "3226:9: ( ( locationindexdefine )=> locationindexdefine )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA137_1 = input.LA(1);
var index137_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred38_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 3;}
input.seek(index137_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA137_2 = input.LA(1);
var index137_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred38_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 3;}
input.seek(index137_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 137, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA157_eotS:
"\u0041\uffff",
DFA157_eofS:
"\u0001\u0002\u0040\uffff",
DFA157_minS:
"\u0001\u000f\u0001\u0000\u003f\uffff",
DFA157_maxS:
"\u0001\u00d9\u0001\u0000\u003f\uffff",
DFA157_acceptS:
"\u0002\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA157_specialS:
"\u0001\uffff\u0001\u0000\u003f\uffff}>",
DFA157_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u0025\u0002"+
"\u0001\uffff\u0006\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0001\u0002\u0001\u0001\u0007\u0002\u0002\uffff\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA157_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_eotS),
DFA157_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_eofS),
DFA157_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA157_minS),
DFA157_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA157_maxS),
DFA157_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_acceptS),
DFA157_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_specialS),
DFA157_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA157_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA157 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 157;
this.eot = Ham4Parser.DFA157_eot;
this.eof = Ham4Parser.DFA157_eof;
this.min = Ham4Parser.DFA157_min;
this.max = Ham4Parser.DFA157_max;
this.accept = Ham4Parser.DFA157_accept;
this.special = Ham4Parser.DFA157_special;
this.transition = Ham4Parser.DFA157_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA157, org.antlr.runtime.DFA, {
getDescription: function() {
return "3492:13: ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA157_1 = input.LA(1);
var index157_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred39_Ham4Parser()) ) {s = 64;}
else if ( (true) ) {s = 2;}
input.seek(index157_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 157, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA171_eotS:
"\u0013\uffff",
DFA171_eofS:
"\u0013\uffff",
DFA171_minS:
"\u0001\u0031\u0012\uffff",
DFA171_maxS:
"\u0001\u0042\u0012\uffff",
DFA171_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
"\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
"\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001"+
"\u0011\u0001\u0012",
DFA171_specialS:
"\u0013\uffff}>",
DFA171_transitionS: [
"\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005"+
"\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a"+
"\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f"+
"\u0001\u0010\u0001\u0011\u0001\u0012",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA171_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_eotS),
DFA171_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_eofS),
DFA171_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA171_minS),
DFA171_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA171_maxS),
DFA171_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_acceptS),
DFA171_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_specialS),
DFA171_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA171_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA171 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 171;
this.eot = Ham4Parser.DFA171_eot;
this.eof = Ham4Parser.DFA171_eof;
this.min = Ham4Parser.DFA171_min;
this.max = Ham4Parser.DFA171_max;
this.accept = Ham4Parser.DFA171_accept;
this.special = Ham4Parser.DFA171_special;
this.transition = Ham4Parser.DFA171_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA171, org.antlr.runtime.DFA, {
getDescription: function() {
return "3875:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA173_eotS:
"\u0011\uffff",
DFA173_eofS:
"\u0011\uffff",
DFA173_minS:
"\u0001\u0044\u0010\uffff",
DFA173_maxS:
"\u0001\u0065\u0010\uffff",
DFA173_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
"\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
"\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010",
DFA173_specialS:
"\u0011\uffff}>",
DFA173_transitionS: [
"\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007\u0001\u0008"+
"\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003"+
"\u0001\u0004\u0001\u0008\u0001\u0005\u0002\uffff\u0001\u0008"+
"\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d\u0001\u000e"+
"\u0001\u0010",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA173_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_eotS),
DFA173_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_eofS),
DFA173_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA173_minS),
DFA173_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA173_maxS),
DFA173_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_acceptS),
DFA173_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_specialS),
DFA173_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA173_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA173 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 173;
this.eot = Ham4Parser.DFA173_eot;
this.eof = Ham4Parser.DFA173_eof;
this.min = Ham4Parser.DFA173_min;
this.max = Ham4Parser.DFA173_max;
this.accept = Ham4Parser.DFA173_accept;
this.special = Ham4Parser.DFA173_special;
this.transition = Ham4Parser.DFA173_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA173, org.antlr.runtime.DFA, {
getDescription: function() {
return "4048:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA180_eotS:
"\u000c\uffff",
DFA180_eofS:
"\u000c\uffff",
DFA180_minS:
"\u0001\u000f\u000b\uffff",
DFA180_maxS:
"\u0001\u00d9\u000b\uffff",
DFA180_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA180_specialS:
"\u000c\uffff}>",
DFA180_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0008\uffff\u0002\u0002\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0002\u000c\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA180_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_eotS),
DFA180_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_eofS),
DFA180_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA180_minS),
DFA180_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA180_maxS),
DFA180_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_acceptS),
DFA180_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_specialS),
DFA180_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA180_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA180 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 180;
this.eot = Ham4Parser.DFA180_eot;
this.eof = Ham4Parser.DFA180_eof;
this.min = Ham4Parser.DFA180_min;
this.max = Ham4Parser.DFA180_max;
this.accept = Ham4Parser.DFA180_accept;
this.special = Ham4Parser.DFA180_special;
this.transition = Ham4Parser.DFA180_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA180, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2489:27: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA181_eotS:
"\u000c\uffff",
DFA181_eofS:
"\u000c\uffff",
DFA181_minS:
"\u0001\u004e\u000b\uffff",
DFA181_maxS:
"\u0001\u00d9\u000b\uffff",
DFA181_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA181_specialS:
"\u000c\uffff}>",
DFA181_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA181_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_eotS),
DFA181_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_eofS),
DFA181_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA181_minS),
DFA181_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA181_maxS),
DFA181_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_acceptS),
DFA181_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_specialS),
DFA181_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA181_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA181 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 181;
this.eot = Ham4Parser.DFA181_eot;
this.eof = Ham4Parser.DFA181_eof;
this.min = Ham4Parser.DFA181_min;
this.max = Ham4Parser.DFA181_max;
this.accept = Ham4Parser.DFA181_accept;
this.special = Ham4Parser.DFA181_special;
this.transition = Ham4Parser.DFA181_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA181, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2490:15: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA182_eotS:
"\u000c\uffff",
DFA182_eofS:
"\u000c\uffff",
DFA182_minS:
"\u0001\u000f\u000b\uffff",
DFA182_maxS:
"\u0001\u00d9\u000b\uffff",
DFA182_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA182_specialS:
"\u000c\uffff}>",
DFA182_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0008\uffff\u0002\u0002\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0002\u000c\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA182_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_eotS),
DFA182_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_eofS),
DFA182_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA182_minS),
DFA182_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA182_maxS),
DFA182_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_acceptS),
DFA182_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_specialS),
DFA182_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA182_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA182 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 182;
this.eot = Ham4Parser.DFA182_eot;
this.eof = Ham4Parser.DFA182_eof;
this.min = Ham4Parser.DFA182_min;
this.max = Ham4Parser.DFA182_max;
this.accept = Ham4Parser.DFA182_accept;
this.special = Ham4Parser.DFA182_special;
this.transition = Ham4Parser.DFA182_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA182, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2494:27: ( action1t )+";
},
dummy: null
});
// public class variables
org.antlr.lang.augmentObject(Ham4Parser, {
tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "WS", "HamTab", "HamLinefeed", "HamPagebreak", "HamReturn", "HamVersion40", "HamSpace", "HamExclaim", "HamQuery", "HamFullstop", "HamComma", "HamPlus", "HamMetaalt", "HamClocku", "HamClockul", "HamClockl", "HamClockdl", "HamClockd", "HamClockdr", "HamClockr", "HamClockur", "HamClockfull", "HamSymmpar", "HamSymmlr", "HamFist", "HamFlathand", "HamFinger2", "HamFinger23", "HamFinger23spread", "HamFinger2345", "HamThumboutmod", "HamThumbacrossmod", "HamPinch12", "HamPinchall", "HamPinch12open", "HamCee12", "HamCeeall", "HamCee12open", "HamThumbopenmod", "HamFingerstraightmod", "HamFingerbendmod", "HamFingerhookedmod", "HamNondominant", "HamDoublebent", "HamDoublehooked", "HamExtfingeru", "HamExtfingerur", "HamExtfingerr", "HamExtfingerdr", "HamExtfingerd", "HamExtfingerdl", "HamExtfingerl", "HamExtfingerul", "HamExtfingerol", "HamExtfingero", "HamExtfingeror", "HamExtfingeril", "HamExtfingeri", "HamExtfingerir", "HamExtfingerui", "HamExtfingerdi", "HamExtfingerdo", "HamExtfingeruo", "HamEarlobe", "HamNostrils", "HamShouldertop", "HamPalmu", "HamPalmur", "HamPalmr", "HamPalmdr", "HamPalmd", "HamPalmdl", "HamPalml", "HamPalmul", "HamReplace", "HamArmextended", "HamBehind", "HamEtc", "HamOrirelative", "HamTongue", "HamTeeth", "HamStomach", "HamNeutralspace", "HamHead", "HamHeadtop", "HamForehead", "HamEyebrows", "HamEyes", "HamNose", "HamEar", "HamCheek", "HamLips", "HamChin", "HamUnderchin", "HamNeck", "HamShoulders", "HamChest", "HamBelowstomach", "HamLrbeside", "HamLrat", "HamUpperarm", "HamElbow", "HamElbowinside", "HamLowerarm", "HamWristback", "HamWristpulse", "HamThumbball", "HamPalm", "HamHandback", "HamThumb", "HamIndexfinger", "HamMiddlefinger", "HamRingfinger", "HamPinky", "HamThumbside", "HamPinkyside", "HamBetween", "HamFingertip", "HamFingernail", "HamFingerpad", "HamFingermidjoint", "HamFingerbase", "HamFingerside", "HamWristtopulse", "HamWristtoback", "HamWristtothumb", "HamWristtopinky", "HamCoreftag", "HamCorefref", "HamNomotion", "HamMoveu", "HamMoveur", "HamMover", "HamMovedr", "HamMoved", "HamMovedl", "HamMovel", "HamMoveul", "HamMoveol", "HamMoveo", "HamMoveor", "HamMoveil", "HamMovei", "HamMoveir", "HamMoveui", "HamMovedi", "HamMovedo", "HamMoveuo", "HamMovecross", "HamMovex", "HamSmallmod", "HamLargemod", "HamArcl", "HamArcu", "HamArcr", "HamArcd", "HamWavy", "HamZigzag", "HamFingerplay", "HamParbegin", "HamParend", "HamCircleo", "HamCirclei", "HamCircled", "HamCircleu", "HamCirclel", "HamCircler", "HamIncreasing", "HamDecreasing", "HamClose", "HamTouch", "HamInterlock", "HamCross", "HamFast", "HamSlow", "HamTense", "HamRest", "HamHalt", "HamRepeatfromstart", "HamRepeatfromstartseveral", "HamRepeatcontinue", "HamRepeatcontinueseveral", "HamSeqbegin", "HamSeqend", "HamAlternatingmotion", "HamRepeatreverse", "HamBrushing", "HamNonipsi", "HamEllipseh", "HamEllipseur", "HamEllipsev", "HamEllipseul", "HamMime", "HamAltbegin", "HamAltend", "HamNodding", "HamSwinging", "HamTwisting", "HamStircw", "HamStirccw", "HamFusionbegin", "HamFusionend", "HamCircleul", "HamCircledr", "HamCircleur", "HamCircledl", "HamCircleol", "HamCircleir", "HamCircleor", "HamCircleil", "HamCircledo", "HamCircleui", "HamCircledi", "HamCircleuo", "HamNbs", "HAMSIGNS", "SIGN2", "SIGN1", "ICFG2", "ICFG1", "NMICLIST", "NMICUNIT", "MICFG2", "MICFG1", "HDCONFIG2", "HDCONFIG1", "SPLITHDCFG2", "HDCFGTAIL2", "HSHAPE2", "HSHAPE1", "BASICHDSHP1", "BASICHDSHP", "HSCLASS", "FIBENDING", "THUMBPOS", "FINGERLIST", "FISHPLIST", "FICRSSLIST", "FSHAPE", "FCROSSING", "THSPECIAL", "EXTFIDIR2", "EXTFIDIR1", "EXTFIDIR", "PALMOR2", "PALMOR1", "LOC2", "LOC1", "LOCTNBODYARM", "LOCTNBODY", "LOCTNHAND", "LOCTNARM", "LEVBODY", "LEVHAND", "LEVARM", "HCONSTLLN", "CNTCTBODY", "CNTCTHAND", "CNTCTOFHAND", "A2TLIST", "A1TLIST", "A1LIST", "ACTION2T", "ACTION1T", "ACTION2", "ACTION1", "PARACT2T", "SEQACT2T", "SPLITACT2LOC2", "SPLITACT2T", "PARACT1T", "SEQACT1T", "NMACT1T", "PARACT1", "REPETITIONS", "SIMPLEMVMT", "STRGHTMVMT", "CRCLRMVMT", "REPLACE", "SPLITREPLACETL", "REPLACETAIL1", "HSFINGERITEM", "LOCBODY", "MOVINGREPETITION", "SEQACT1", "SEQFUSEDACT2T", "SEQFUSEDACT1T", "SEQFUSEDACT1", "CNTCTOHHAND", "CNTCTOHARM"],
FOLLOW_hamsignseq_in_hamsinglesign735: new org.antlr.runtime.BitSet([0x00000000, 0x00000000]),
FOLLOW_EOF_in_hamsinglesign745: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sign2or1_in_hamsignseq813: new org.antlr.runtime.BitSet([0x00008002, 0x00000000]),
FOLLOW_HamPlus_in_hamsignseq845: new org.antlr.runtime.BitSet([0xFC000000, 0x000043F3,0x00000000, 0x00000000,0x00000020, 0x04000008]),
FOLLOW_sign2or1_in_hamsignseq865: new org.antlr.runtime.BitSet([0x00008002, 0x00000000]),
FOLLOW_nondomsign1_in_sign2or1952: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sign2_in_sign2or1968: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_symmoperator_in_sign21009: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000008]),
FOLLOW_initialconfig2_in_sign21019: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a2tstar_in_sign21029: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_initialconfig2_in_sign21062: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21072: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_sign21138: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
FOLLOW_HamNondominant_in_sign21148: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_sign21158: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21168: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_sign21203: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_sign21213: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21223: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNondominant_in_nondomsign11275: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_nondomsign11285: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_nondomsign11295: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_symmoperator1353: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator1425: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator1441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator1468: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator1484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamAlternatingmotion_in_symmoperator1510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
FOLLOW_HamNonipsi_in_symmoperator1525: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig21562: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000008]),
FOLLOW_minitialconfig2_in_initialconfig21575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig11634: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_minitialconfig1_in_initialconfig11647: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nmicunit_in_nminitialconfig1718: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_HamSeqbegin_in_nmicunit1781: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x00000FFF]),
FOLLOW_levelbody_in_nmicunit1812: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelarm_in_nmicunit1834: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_nmicunit1854: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_nmicunit1864: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig2_in_minitialconfig21965: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_minitialconfig22021: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_minitialconfig22064: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_minitialconfig22075: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_HamPlus_in_minitialconfig22131: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_minitialconfig22146: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_minitialconfig22160: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1_in_minitialconfig22204: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_minitialconfig22218: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x00000010]),
FOLLOW_location1_in_minitialconfig22237: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_minitialconfig22254: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig12328: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_minitialconfig12340: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_handconfig22445: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_handconfigtail2_in_handconfig22455: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_handconfig22510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splithandconfig2_in_handconfig22539: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape1_in_handconfig12588: new org.antlr.runtime.BitSet([0x00000002, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfig12612: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfig12626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splithandconfig22696: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_splithandconfig22707: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splithandconfig22717: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_splithandconfig22728: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splithandconfig22738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir2_in_handconfigtail22827: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_palmor2_in_handconfigtail22837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handconfigtail22867: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22880: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfigtail22892: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handconfigtail22902: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22915: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfigtail22927: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handconfigtail22937: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape1_in_handshape23010: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handshape23039: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_handshape1_in_handshape23054: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handshape23064: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_handshape1_in_handshape23079: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handshape23089: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_basichandshape1_in_handshape13140: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_cautiousfingerlist_in_handshape13205: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13219: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13233: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_thumbbetweenexplicit_in_handshape13247: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_cautiousfingerlist_in_handshape13325: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13339: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13353: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbspecial_in_handshape13377: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerlist_in_handshape13458: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13472: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13486: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbbetweendefault_in_handshape13502: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_handshape13506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerlist_in_handshape13539: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13553: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13567: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_basichandshape_in_basichandshape13654: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_basichandshape13719: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_basichandshape_in_basichandshape13734: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshapeclass_in_basichandshape3802: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C,0x00020000, 0x00000000]),
FOLLOW_HamNondominant_in_basichandshape3826: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_basichandshape3848: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C]),
FOLLOW_handbendandthumb_in_basichandshape3861: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbpos_in_handbendandthumb3932: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C]),
FOLLOW_fingerbending_in_handbendandthumb3944: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerbending_in_handbendandthumb3963: new org.antlr.runtime.BitSet([0x00000002, 0x0000040C]),
FOLLOW_thumbpos_in_handbendandthumb3975: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingerlist_in_fingerlist4007: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_recfingerlist4116: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingerlist_in_recfingerlist4130: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_reccautiousfingerlist_in_cautiousfingerlist4170: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_reccautiousfingerlist4273: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_reccautiousfingerlist_in_reccautiousfingerlist4287: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingershapelist_in_fingershapelist4327: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingershape_in_recfingershapelist4431: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingershapelist_in_recfingershapelist4445: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingercrossinglist_in_fingercrossinglist4485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingercrossing_in_recfingercrossinglist4586: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingercrossinglist_in_recfingercrossinglist4600: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_hsfingeritem4656: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000]),
FOLLOW_HamLargemod_in_hsfingeritem4668: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_digit4728: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_digit4738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_hsdigit4788: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_hsdigit4798: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_fingershape4827: new org.antlr.runtime.BitSet([0x00000000, 0x0001BC0C]),
FOLLOW_fingerbending_in_fingershape4837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_fingercrossing4897: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7E000000]),
FOLLOW_fingerpart_in_fingercrossing4907: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_fingercrossing4921: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetween_in_thumbspecial4981: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_thumbspecial4991: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetweenexplicit_in_thumbbetween5020: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetweendefault_in_thumbbetween5030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_thumbbetweenexplicit5059: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_thumbbetweenexplicit5069: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_thumbbetweenexplicit5080: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBetween_in_thumbbetweendefault5139: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_thumbextra5205: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_thumbextra5221: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_extfidir25287: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitextfidir2_in_extfidir25303: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitextfidir25354: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_splitextfidir25366: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitextfidir25376: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_splitextfidir25388: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitextfidir25398: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir_in_extfidir15429: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x01000000]),
FOLLOW_HamBetween_in_extfidir15453: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir_in_extfidir15467: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_extfidir15502: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_palmor25574: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitpalmor2_in_palmor25590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitpalmor25641: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_splitpalmor25653: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitpalmor25663: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_splitpalmor25675: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitpalmor25685: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor_in_palmor15716: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00060000, 0x01000000]),
FOLLOW_HamBetween_in_palmor15740: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor_in_palmor15754: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamEtc_in_palmor15772: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_palmor15807: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1as2_in_location25882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location2not1_in_location25898: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1_in_location1as25933: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_location2not16011: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x000000FF]),
FOLLOW_HamNeutralspace_in_location2not16035: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000]),
FOLLOW_HamArmextended_in_location2not16051: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbody_in_location2not16080: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_location2not16128: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_location2not16138: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_location2not16148: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_location2not16158: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_location2not16168: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexuse_in_location16273: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationhand_in_location16313: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbodyarm_in_location16329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_locationindexdefine6389: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000008, 0x00000000]),
FOLLOW_HamCoreftag_in_locationindexdefine6399: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_locationindexuse6436: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamCorefref_in_locationindexuse6446: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNeutralspace_in_locationbodyarm6489: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000]),
FOLLOW_HamArmextended_in_locationbodyarm6501: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbody_in_locationbodyarm6544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationarm_in_locationbodyarm6560: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexbody_in_locationbody6614: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00018000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_HamBehind_in_locationbody6626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contactbody_in_locationbody6649: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexhand_in_locationhand6710: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contacthand_in_locationhand6728: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexarm_in_locationarm6786: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00018000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_HamBehind_in_locationarm6798: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contactbody_in_locationarm6821: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody6882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexbody6906: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_levelbody_in_levelcomplexbody6922: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand6962: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexhand6986: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_levelhand_in_levelcomplexhand7002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm7042: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexarm7066: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x00000FFF]),
FOLLOW_levelarm_in_levelcomplexarm7082: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locbody_in_levelbody7134: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000000FF]),
FOLLOW_HamEtc_in_levelbody7146: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelbody7161: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locsided_in_levelbody7199: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000000FF]),
FOLLOW_HamEtc_in_levelbody7211: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelbody7226: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelbody7264: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x0000003F]),
FOLLOW_locbody_in_levelbody7288: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_levelbody7304: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locsided_in_levelbody7331: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_levelbody7347: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_lochand_in_levelhand7429: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000180FF]),
FOLLOW_dorsalorpalmar_in_levelhand7441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelhand7456: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelhand7496: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7EFFF000]),
FOLLOW_lochand_in_levelhand7506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00018000]),
FOLLOW_dorsalorpalmar_in_levelhand7518: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locarm_in_levelarm7585: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000180FF]),
FOLLOW_HamEtc_in_levelarm7597: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000180FF]),
FOLLOW_dorsalorpalmar_in_levelarm7612: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelarm7627: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelarm7668: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000F00]),
FOLLOW_locarm_in_levelarm7678: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00018000]),
FOLLOW_HamEtc_in_levelarm7690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00018000]),
FOLLOW_dorsalorpalmar_in_levelarm7705: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_pcontact_in_contactbody7776: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArmextended_in_contactbody7792: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactofhand_in_contactbody7808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_pcontact_in_contacthand7874: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ccontact_in_contacthand7890: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactofhand_in_contacthand7906: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handconstellation7974: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_locationhand_in_handconstellation7989: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handconstellation8003: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_locationhand_in_handconstellation8018: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handconstellation8032: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contacthand_in_handconstellation8054: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_contactofhand8108: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0001E000]),
FOLLOW_pcontact_in_contactofhand8133: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_ccontact_in_contactofhand8157: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_contactohhand_in_contactofhand8223: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_contactoharm_in_contactofhand8247: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_contactofhand8267: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexhand_in_contactohhand8329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexarm_in_contactoharm8380: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handpart_in_lochand8443: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_lochand8459: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_lochand8471: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_lochand8492: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x7E3E0000]),
FOLLOW_fingerpart_in_lochand8507: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_a2tlist_in_a2tstar8548: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_a1tlist_in_a1tstar8600: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action2t_in_a2tlist8672: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a2tlist_in_a2tlist8686: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_a1tlist8746: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tlist_in_a1tlist8760: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action2t8838: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2not1_in_action2t8848: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action2t8858: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_action2t8916: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitaction2loc2_in_action2t9025: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_splitaction2t_in_action2t9090: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_paraction2t_in_action2t9114: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqaction2t_in_action2t9138: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqfusedaction2t_in_action2t9162: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action2t9182: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action1t9316: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x37C1E008]),
FOLLOW_handconstellation_in_action1t9404: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_location1_in_action1t9444: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x37C00000]),
FOLLOW_HamLargemod_in_action1t9468: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_paraction1t_in_action1t9528: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqnmoraction1t_in_action1t9552: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqfusedaction1t_in_action1t9577: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action1t9597: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_action19733: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_simplemovement_in_action19762: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_modifier_in_action19788: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x003E0000]),
FOLLOW_HamLargemod_in_action19807: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_specialfingerplaymovement_in_action19882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_paraction1_in_action19911: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_seqaction1_in_action19940: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_seqfusedaction1_in_action19969: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action1seq10005: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_action1tseq10017: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParbegin_in_paraction2t10044: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_paraction2t10057: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction2t10070: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqaction2t10123: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_seqaction2t10136: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqaction2t10149: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction2t10202: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_seqfusedaction2t10215: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction2t10228: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitaction2loc210281: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1seq_in_splitaction2loc210294: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2loc210304: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1seq_in_splitaction2loc210316: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitaction2loc210326: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_splitaction2loc210337: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitaction2t10396: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1tseq_in_splitaction2t10409: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2t10419: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1tseq_in_splitaction2t10431: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitaction2t10441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_paraction1t10505: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_paraction1t10518: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction1t10531: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqnmoraction1t10590: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB84038, 0x00000FFF,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelbody_in_seqnmoraction1t10621: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelarm_in_seqnmoraction1t10633: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_seqnmoraction1t10643: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_action1t_in_seqnmoraction1t10679: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqnmoraction1t10716: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction1t10761: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_seqfusedaction1t10774: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction1t10787: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_paraction110845: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_paraction110858: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction110871: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqaction110929: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_seqaction110942: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqaction110955: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction111013: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_seqfusedaction111026: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction111039: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_repetitions_in_repetitionsoption11154: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_repetitions11234: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_HamRepeatfromstartseveral_in_repetitions11245: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_repetitions11255: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_repetitions11265: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_repetitions11275: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_repetition_in_repetitions11322: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x33C01800]),
FOLLOW_HamEtc_in_repetitions11354: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_repetition_in_repetitions11386: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_movingrepetition_in_repetitions11425: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_sizechangenonlinear_in_repetitions11447: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11474: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11490: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11545: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11557: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_alternations11608: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_alternations11620: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_movingrepetition11658: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x23C00000]),
FOLLOW_repetition_in_movingrepetition11669: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_movingrepetition11679: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x08001800]),
FOLLOW_size_in_movingrepetition11691: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08001800]),
FOLLOW_sizechangenonlinear_in_movingrepetition11706: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_movingrepetition11719: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_straightmovement_in_simplemovement11800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0xFC000000, 0x04000003]),
FOLLOW_size_in_simplemovement11816: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0xF0000000, 0x04000003]),
FOLLOW_arckind_in_simplemovement11851: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_zigzag_in_simplemovement11883: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_circularmovement_in_simplemovement11922: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_simplemovement11938: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_revolutions_in_simplemovement11957: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_ellipse_in_simplemovement11976: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800]),
FOLLOW_sizechangenonlinear_in_simplemovement11995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_movementcross_in_simplemovement12022: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04000000]),
FOLLOW_size_in_simplemovement12038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_wristmovement_in_simplemovement12065: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04000000]),
FOLLOW_size_in_simplemovement12081: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_replacement_in_simplemovement12108: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_HamFingerplay_in_simplemovement12132: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_brushingcontact_in_simplemovement12194: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_locationindexdefine_in_simplemovement12289: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_specialfingerplaymovement12449: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_specialfingerplaymovement12462: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x00000004]),
FOLLOW_HamFingerplay_in_specialfingerplaymovement12475: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_specialfingerplaymovement12485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement12530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_straightmovement12554: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement12569: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement12622: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_circularmovement12646: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000007E0,0x03FFC000, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement12661: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_arc_in_arckind12714: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000000]),
FOLLOW_arc_in_arckind12726: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_arckind12741: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_zigzag12773: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_zigzag12833: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_zigzag12848: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_zigzag12863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sizechange_in_sizechangenonlinear12895: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_sizechangenonlinear12907: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ellipsedirection_in_ellipse12939: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_ellipse12951: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_clock_in_revolutions12995: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13019: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13035: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions13061: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13080: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13092: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions13107: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamReplace_in_replacement13145: new org.antlr.runtime.BitSet([0xF0000000, 0xFFFE43F3,0x00003FC7, 0x00000000,0x00000000, 0x00001808]),
FOLLOW_sizechange_in_replacement13158: new org.antlr.runtime.BitSet([0xF0000000, 0xFFFE43F3,0x00003FC7, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_handshape1_in_replacement13185: new org.antlr.runtime.BitSet([0x00000002, 0xFFFE0000,0x00003FC7, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_splitreplacetail_in_replacement13257: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacement13291: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacement13314: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitreplacetail_in_replacement13380: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacement13419: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacement13435: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_replacement13480: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitreplacetail13534: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00003FC7, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail13545: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitreplacetail13555: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00003FC7, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_HamNomotion_in_splitreplacetail13580: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_replacetail1_in_splitreplacetail13605: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitreplacetail13625: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacetail113689: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacetail113701: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_replacetail113720: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_brushingcontact13776: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_brushingcontact13788: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_brushingcontact13798: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_brushingcontact13808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_handshapeclasstok13844: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshapeclasstok_in_handshapeclass13980: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_fingerbendingtok14017: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerbendingtok_in_fingerbending14085: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_thumbpostok14127: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbpostok_in_thumbpos14171: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumb_in_thumb14211: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_finger0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_fingerpart0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeru_in_extfidirtok14384: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerur_in_extfidirtok14394: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerr_in_extfidirtok14404: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdr_in_extfidirtok14414: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerd_in_extfidirtok14424: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdl_in_extfidirtok14434: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerl_in_extfidirtok14444: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerul_in_extfidirtok14454: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerol_in_extfidirtok14478: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_set_in_extfidirtok14492: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingero_in_extfidirtok14563: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidirtok14587: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_set_in_extfidirtok14601: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeril_in_extfidirtok14686: new org.antlr.runtime.BitSet([0x00000002, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_set_in_extfidirtok14700: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeri_in_extfidirtok14771: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidirtok14795: new org.antlr.runtime.BitSet([0x00000002, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_set_in_extfidirtok14809: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidirtok14894: new org.antlr.runtime.BitSet([0x00000002, 0x50000000]),
FOLLOW_set_in_extfidirtok14908: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidirtok14993: new org.antlr.runtime.BitSet([0x00000002, 0x50000000]),
FOLLOW_set_in_extfidirtok15007: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidirtok15092: new org.antlr.runtime.BitSet([0x00000002, 0x0A000000]),
FOLLOW_set_in_extfidirtok15106: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidirtok15191: new org.antlr.runtime.BitSet([0x00000002, 0x0A000000]),
FOLLOW_set_in_extfidirtok15205: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidirtok_in_extfidir15286: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_palmor0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locarm0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHead_in_locbodytok15488: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHeadtop_in_locbodytok15498: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamForehead_in_locbodytok15508: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEyebrows_in_locbodytok15518: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNose_in_locbodytok15528: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNostrils_in_locbodytok15538: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTongue_in_locbodytok15548: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locbodytok15572: new org.antlr.runtime.BitSet([0x00000002, 0x00018000]),
FOLLOW_set_in_locbodytok15654: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamChin_in_locbodytok15725: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamUnderchin_in_locbodytok15735: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNeck_in_locbodytok15745: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamShouldertop_in_locbodytok15755: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamShoulders_in_locbodytok15765: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamChest_in_locbodytok15775: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStomach_in_locbodytok15785: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBelowstomach_in_locbodytok15795: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locbodytok_in_locbody15815: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locsided0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_handpart0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_side0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_dorsalorpalmar0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_pcontact0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_ccontact0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_sizechange0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_repetition0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementarrow0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementcross0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_wristmovement0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementcircle0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_ellipsedirection0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_clock0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_modifier0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_arc0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_size0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNondominant_in_synpred1_Ham4Parser928: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_synpred1_Ham4Parser930: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_synpred2_Ham4Parser1112: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
FOLLOW_HamNondominant_in_synpred2_Ham4Parser1114: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_synpred2_Ham4Parser1116: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred3_Ham4Parser1806: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig2_in_synpred4_Ham4Parser1943: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location2_in_synpred5_Ham4Parser1991: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPlus_in_synpred6_Ham4Parser2101: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_synpred7_Ham4Parser2414: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_HamParbegin_in_synpred7_Ham4Parser2418: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_synpred7_Ham4Parser2423: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_synpred8_Ham4Parser2488: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir2_in_synpred9_Ham4Parser2805: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred10_Ham4Parser3168: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x013E0000]),
FOLLOW_HamBetween_in_synpred10_Ham4Parser3173: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_synpred10_Ham4Parser3175: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsdigit_in_synpred11_Ham4Parser3282: new org.antlr.runtime.BitSet([0x00000000, 0x0001BC0C,0x00000000, 0x7E3E0000]),
FOLLOW_fingerbending_in_synpred11_Ham4Parser3289: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_synpred11_Ham4Parser3293: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbspecial_in_synpred12_Ham4Parser3371: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred13_Ham4Parser3415: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbbetweendefault_in_synpred13_Ham4Parser3422: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_synpred13_Ham4Parser3426: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBetween_in_synpred14_Ham4Parser3680: new org.antlr.runtime.BitSet([0xF0000000, 0x000003F3]),
FOLLOW_handshapeclass_in_synpred14_Ham4Parser3682: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred15_Ham4Parser4086: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred16_Ham4Parser4241: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_synpred16_Ham4Parser4243: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingershape_in_synpred17_Ham4Parser4401: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingercrossing_in_synpred18_Ham4Parser4556: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_synpred19_Ham4Parser5989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexuse_in_synpred20_Ham4Parser6231: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_synpred21_Ham4Parser6291: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred22_Ham4Parser6522: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactbody_in_synpred23_Ham4Parser6643: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contacthand_in_synpred24_Ham4Parser6723: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactbody_in_synpred25_Ham4Parser6815: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_synpred26_Ham4Parser8193: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_synpred27_Ham4Parser8814: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2not1_in_synpred27_Ham4Parser8816: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_synpred28_Ham4Parser8894: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_synpred29_Ham4Parser8961: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_synpred29_Ham4Parser8965: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamPlus_in_synpred29_Ham4Parser8970: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_synpred29_Ham4Parser8988: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_synpred29_Ham4Parser8993: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_synpred29_Ham4Parser8995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_synpred30_Ham4Parser9051: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_synpred30_Ham4Parser9055: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamPlus_in_synpred30_Ham4Parser9060: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_synpred31_Ham4Parser9268: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_synpred32_Ham4Parser9358: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred33_Ham4Parser9858: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_synpred33_Ham4Parser9860: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred34_Ham4Parser10615: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred35_Ham4Parser11115: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x23C00000]),
FOLLOW_repetition_in_synpred35_Ham4Parser11120: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_synpred35_Ham4Parser11124: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred36_Ham4Parser11208: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_HamRepeatfromstartseveral_in_synpred36_Ham4Parser11210: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_synpred36_Ham4Parser11212: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred37_Ham4Parser12166: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_synpred37_Ham4Parser12168: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexdefine_in_synpred38_Ham4Parser12263: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitreplacetail_in_synpred39_Ham4Parser13219: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});
})();//-------- js/Ham4HMLGen.js --------
// $ANTLR 3.3 Nov 30, 2010 12:50:56 Ham4HMLGen.g 2017-01-17 17:45:07
// TreeParser header
var Ham4HMLGen = function(input, state) {
if (!state) {
state = new org.antlr.runtime.RecognizerSharedState();
}
(function(){
// TreeParser members
var hBuilder = null;
var logLev = 0;
this.setLogLevel = function(lev) {
this.logLev = lev;
};
this.trace = function(str) {
if (this.logLev >= 440) {
console.log(str);
}
};
}).call(this);
Ham4HMLGen.superclass.constructor.call(this, input, state);
/* @todo only create adaptor if output=AST */
this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
};
org.antlr.lang.augmentObject(Ham4HMLGen, {
EOF: -1,
WS: 4,
HamTab: 5,
HamLinefeed: 6,
HamPagebreak: 7,
HamReturn: 8,
HamVersion40: 9,
HamSpace: 10,
HamExclaim: 11,
HamQuery: 12,
HamFullstop: 13,
HamComma: 14,
HamPlus: 15,
HamMetaalt: 16,
HamClocku: 17,
HamClockul: 18,
HamClockl: 19,
HamClockdl: 20,
HamClockd: 21,
HamClockdr: 22,
HamClockr: 23,
HamClockur: 24,
HamClockfull: 25,
HamSymmpar: 26,
HamSymmlr: 27,
HamFist: 28,
HamFlathand: 29,
HamFinger2: 30,
HamFinger23: 31,
HamFinger23spread: 32,
HamFinger2345: 33,
HamThumboutmod: 34,
HamThumbacrossmod: 35,
HamPinch12: 36,
HamPinchall: 37,
HamPinch12open: 38,
HamCee12: 39,
HamCeeall: 40,
HamCee12open: 41,
HamThumbopenmod: 42,
HamFingerstraightmod: 43,
HamFingerbendmod: 44,
HamFingerhookedmod: 45,
HamNondominant: 46,
HamDoublebent: 47,
HamDoublehooked: 48,
HamExtfingeru: 49,
HamExtfingerur: 50,
HamExtfingerr: 51,
HamExtfingerdr: 52,
HamExtfingerd: 53,
HamExtfingerdl: 54,
HamExtfingerl: 55,
HamExtfingerul: 56,
HamExtfingerol: 57,
HamExtfingero: 58,
HamExtfingeror: 59,
HamExtfingeril: 60,
HamExtfingeri: 61,
HamExtfingerir: 62,
HamExtfingerui: 63,
HamExtfingerdi: 64,
HamExtfingerdo: 65,
HamExtfingeruo: 66,
HamEarlobe: 67,
HamNostrils: 68,
HamShouldertop: 69,
HamPalmu: 70,
HamPalmur: 71,
HamPalmr: 72,
HamPalmdr: 73,
HamPalmd: 74,
HamPalmdl: 75,
HamPalml: 76,
HamPalmul: 77,
HamReplace: 78,
HamArmextended: 79,
HamBehind: 80,
HamEtc: 81,
HamOrirelative: 82,
HamTongue: 83,
HamTeeth: 84,
HamStomach: 85,
HamNeutralspace: 86,
HamHead: 87,
HamHeadtop: 88,
HamForehead: 89,
HamEyebrows: 90,
HamEyes: 91,
HamNose: 92,
HamEar: 93,
HamCheek: 94,
HamLips: 95,
HamChin: 96,
HamUnderchin: 97,
HamNeck: 98,
HamShoulders: 99,
HamChest: 100,
HamBelowstomach: 101,
HamLrbeside: 102,
HamLrat: 103,
HamUpperarm: 104,
HamElbow: 105,
HamElbowinside: 106,
HamLowerarm: 107,
HamWristback: 108,
HamWristpulse: 109,
HamThumbball: 110,
HamPalm: 111,
HamHandback: 112,
HamThumb: 113,
HamIndexfinger: 114,
HamMiddlefinger: 115,
HamRingfinger: 116,
HamPinky: 117,
HamThumbside: 118,
HamPinkyside: 119,
HamBetween: 120,
HamFingertip: 121,
HamFingernail: 122,
HamFingerpad: 123,
HamFingermidjoint: 124,
HamFingerbase: 125,
HamFingerside: 126,
HamWristtopulse: 127,
HamWristtoback: 128,
HamWristtothumb: 129,
HamWristtopinky: 130,
HamCoreftag: 131,
HamCorefref: 132,
HamNomotion: 133,
HamMoveu: 134,
HamMoveur: 135,
HamMover: 136,
HamMovedr: 137,
HamMoved: 138,
HamMovedl: 139,
HamMovel: 140,
HamMoveul: 141,
HamMoveol: 142,
HamMoveo: 143,
HamMoveor: 144,
HamMoveil: 145,
HamMovei: 146,
HamMoveir: 147,
HamMoveui: 148,
HamMovedi: 149,
HamMovedo: 150,
HamMoveuo: 151,
HamMovecross: 152,
HamMovex: 153,
HamSmallmod: 154,
HamLargemod: 155,
HamArcl: 156,
HamArcu: 157,
HamArcr: 158,
HamArcd: 159,
HamWavy: 160,
HamZigzag: 161,
HamFingerplay: 162,
HamParbegin: 163,
HamParend: 164,
HamCircleo: 165,
HamCirclei: 166,
HamCircled: 167,
HamCircleu: 168,
HamCirclel: 169,
HamCircler: 170,
HamIncreasing: 171,
HamDecreasing: 172,
HamClose: 173,
HamTouch: 174,
HamInterlock: 175,
HamCross: 176,
HamFast: 177,
HamSlow: 178,
HamTense: 179,
HamRest: 180,
HamHalt: 181,
HamRepeatfromstart: 182,
HamRepeatfromstartseveral: 183,
HamRepeatcontinue: 184,
HamRepeatcontinueseveral: 185,
HamSeqbegin: 186,
HamSeqend: 187,
HamAlternatingmotion: 188,
HamRepeatreverse: 189,
HamBrushing: 190,
HamNonipsi: 191,
HamEllipseh: 192,
HamEllipseur: 193,
HamEllipsev: 194,
HamEllipseul: 195,
HamMime: 196,
HamAltbegin: 197,
HamAltend: 198,
HamNodding: 199,
HamSwinging: 200,
HamTwisting: 201,
HamStircw: 202,
HamStirccw: 203,
HamFusionbegin: 204,
HamFusionend: 205,
HamCircleul: 206,
HamCircledr: 207,
HamCircleur: 208,
HamCircledl: 209,
HamCircleol: 210,
HamCircleir: 211,
HamCircleor: 212,
HamCircleil: 213,
HamCircledo: 214,
HamCircleui: 215,
HamCircledi: 216,
HamCircleuo: 217,
HamNbs: 218,
HAMSIGNS: 219,
SIGN2: 220,
SIGN1: 221,
ICFG2: 222,
ICFG1: 223,
NMICLIST: 224,
NMICUNIT: 225,
MICFG2: 226,
MICFG1: 227,
HDCONFIG2: 228,
HDCONFIG1: 229,
SPLITHDCFG2: 230,
HDCFGTAIL2: 231,
HSHAPE2: 232,
HSHAPE1: 233,
BASICHDSHP1: 234,
BASICHDSHP: 235,
HSCLASS: 236,
FIBENDING: 237,
THUMBPOS: 238,
FINGERLIST: 239,
FISHPLIST: 240,
FICRSSLIST: 241,
FSHAPE: 242,
FCROSSING: 243,
THSPECIAL: 244,
EXTFIDIR2: 245,
EXTFIDIR1: 246,
EXTFIDIR: 247,
PALMOR2: 248,
PALMOR1: 249,
LOC2: 250,
LOC1: 251,
LOCTNBODYARM: 252,
LOCTNBODY: 253,
LOCTNHAND: 254,
LOCTNARM: 255,
LEVBODY: 256,
LEVHAND: 257,
LEVARM: 258,
HCONSTLLN: 259,
CNTCTBODY: 260,
CNTCTHAND: 261,
CNTCTOFHAND: 262,
A2TLIST: 263,
A1TLIST: 264,
A1LIST: 265,
ACTION2T: 266,
ACTION1T: 267,
ACTION2: 268,
ACTION1: 269,
PARACT2T: 270,
SEQACT2T: 271,
SPLITACT2LOC2: 272,
SPLITACT2T: 273,
PARACT1T: 274,
SEQACT1T: 275,
NMACT1T: 276,
PARACT1: 277,
REPETITIONS: 278,
SIMPLEMVMT: 279,
STRGHTMVMT: 280,
CRCLRMVMT: 281,
REPLACE: 282,
SPLITREPLACETL: 283,
REPLACETAIL1: 284,
HSFINGERITEM: 285,
LOCBODY: 286,
MOVINGREPETITION: 287,
SEQACT1: 288,
SEQFUSEDACT2T: 289,
SEQFUSEDACT1T: 290,
SEQFUSEDACT1: 291,
CNTCTOHHAND: 292,
CNTCTOHARM: 293
});
(function(){
// public class variables
var EOF= -1,
WS= 4,
HamTab= 5,
HamLinefeed= 6,
HamPagebreak= 7,
HamReturn= 8,
HamVersion40= 9,
HamSpace= 10,
HamExclaim= 11,
HamQuery= 12,
HamFullstop= 13,
HamComma= 14,
HamPlus= 15,
HamMetaalt= 16,
HamClocku= 17,
HamClockul= 18,
HamClockl= 19,
HamClockdl= 20,
HamClockd= 21,
HamClockdr= 22,
HamClockr= 23,
HamClockur= 24,
HamClockfull= 25,
HamSymmpar= 26,
HamSymmlr= 27,
HamFist= 28,
HamFlathand= 29,
HamFinger2= 30,
HamFinger23= 31,
HamFinger23spread= 32,
HamFinger2345= 33,
HamThumboutmod= 34,
HamThumbacrossmod= 35,
HamPinch12= 36,
HamPinchall= 37,
HamPinch12open= 38,
HamCee12= 39,
HamCeeall= 40,
HamCee12open= 41,
HamThumbopenmod= 42,
HamFingerstraightmod= 43,
HamFingerbendmod= 44,
HamFingerhookedmod= 45,
HamNondominant= 46,
HamDoublebent= 47,
HamDoublehooked= 48,
HamExtfingeru= 49,
HamExtfingerur= 50,
HamExtfingerr= 51,
HamExtfingerdr= 52,
HamExtfingerd= 53,
HamExtfingerdl= 54,
HamExtfingerl= 55,
HamExtfingerul= 56,
HamExtfingerol= 57,
HamExtfingero= 58,
HamExtfingeror= 59,
HamExtfingeril= 60,
HamExtfingeri= 61,
HamExtfingerir= 62,
HamExtfingerui= 63,
HamExtfingerdi= 64,
HamExtfingerdo= 65,
HamExtfingeruo= 66,
HamEarlobe= 67,
HamNostrils= 68,
HamShouldertop= 69,
HamPalmu= 70,
HamPalmur= 71,
HamPalmr= 72,
HamPalmdr= 73,
HamPalmd= 74,
HamPalmdl= 75,
HamPalml= 76,
HamPalmul= 77,
HamReplace= 78,
HamArmextended= 79,
HamBehind= 80,
HamEtc= 81,
HamOrirelative= 82,
HamTongue= 83,
HamTeeth= 84,
HamStomach= 85,
HamNeutralspace= 86,
HamHead= 87,
HamHeadtop= 88,
HamForehead= 89,
HamEyebrows= 90,
HamEyes= 91,
HamNose= 92,
HamEar= 93,
HamCheek= 94,
HamLips= 95,
HamChin= 96,
HamUnderchin= 97,
HamNeck= 98,
HamShoulders= 99,
HamChest= 100,
HamBelowstomach= 101,
HamLrbeside= 102,
HamLrat= 103,
HamUpperarm= 104,
HamElbow= 105,
HamElbowinside= 106,
HamLowerarm= 107,
HamWristback= 108,
HamWristpulse= 109,
HamThumbball= 110,
HamPalm= 111,
HamHandback= 112,
HamThumb= 113,
HamIndexfinger= 114,
HamMiddlefinger= 115,
HamRingfinger= 116,
HamPinky= 117,
HamThumbside= 118,
HamPinkyside= 119,
HamBetween= 120,
HamFingertip= 121,
HamFingernail= 122,
HamFingerpad= 123,
HamFingermidjoint= 124,
HamFingerbase= 125,
HamFingerside= 126,
HamWristtopulse= 127,
HamWristtoback= 128,
HamWristtothumb= 129,
HamWristtopinky= 130,
HamCoreftag= 131,
HamCorefref= 132,
HamNomotion= 133,
HamMoveu= 134,
HamMoveur= 135,
HamMover= 136,
HamMovedr= 137,
HamMoved= 138,
HamMovedl= 139,
HamMovel= 140,
HamMoveul= 141,
HamMoveol= 142,
HamMoveo= 143,
HamMoveor= 144,
HamMoveil= 145,
HamMovei= 146,
HamMoveir= 147,
HamMoveui= 148,
HamMovedi= 149,
HamMovedo= 150,
HamMoveuo= 151,
HamMovecross= 152,
HamMovex= 153,
HamSmallmod= 154,
HamLargemod= 155,
HamArcl= 156,
HamArcu= 157,
HamArcr= 158,
HamArcd= 159,
HamWavy= 160,
HamZigzag= 161,
HamFingerplay= 162,
HamParbegin= 163,
HamParend= 164,
HamCircleo= 165,
HamCirclei= 166,
HamCircled= 167,
HamCircleu= 168,
HamCirclel= 169,
HamCircler= 170,
HamIncreasing= 171,
HamDecreasing= 172,
HamClose= 173,
HamTouch= 174,
HamInterlock= 175,
HamCross= 176,
HamFast= 177,
HamSlow= 178,
HamTense= 179,
HamRest= 180,
HamHalt= 181,
HamRepeatfromstart= 182,
HamRepeatfromstartseveral= 183,
HamRepeatcontinue= 184,
HamRepeatcontinueseveral= 185,
HamSeqbegin= 186,
HamSeqend= 187,
HamAlternatingmotion= 188,
HamRepeatreverse= 189,
HamBrushing= 190,
HamNonipsi= 191,
HamEllipseh= 192,
HamEllipseur= 193,
HamEllipsev= 194,
HamEllipseul= 195,
HamMime= 196,
HamAltbegin= 197,
HamAltend= 198,
HamNodding= 199,
HamSwinging= 200,
HamTwisting= 201,
HamStircw= 202,
HamStirccw= 203,
HamFusionbegin= 204,
HamFusionend= 205,
HamCircleul= 206,
HamCircledr= 207,
HamCircleur= 208,
HamCircledl= 209,
HamCircleol= 210,
HamCircleir= 211,
HamCircleor= 212,
HamCircleil= 213,
HamCircledo= 214,
HamCircleui= 215,
HamCircledi= 216,
HamCircleuo= 217,
HamNbs= 218,
HAMSIGNS= 219,
SIGN2= 220,
SIGN1= 221,
ICFG2= 222,
ICFG1= 223,
NMICLIST= 224,
NMICUNIT= 225,
MICFG2= 226,
MICFG1= 227,
HDCONFIG2= 228,
HDCONFIG1= 229,
SPLITHDCFG2= 230,
HDCFGTAIL2= 231,
HSHAPE2= 232,
HSHAPE1= 233,
BASICHDSHP1= 234,
BASICHDSHP= 235,
HSCLASS= 236,
FIBENDING= 237,
THUMBPOS= 238,
FINGERLIST= 239,
FISHPLIST= 240,
FICRSSLIST= 241,
FSHAPE= 242,
FCROSSING= 243,
THSPECIAL= 244,
EXTFIDIR2= 245,
EXTFIDIR1= 246,
EXTFIDIR= 247,
PALMOR2= 248,
PALMOR1= 249,
LOC2= 250,
LOC1= 251,
LOCTNBODYARM= 252,
LOCTNBODY= 253,
LOCTNHAND= 254,
LOCTNARM= 255,
LEVBODY= 256,
LEVHAND= 257,
LEVARM= 258,
HCONSTLLN= 259,
CNTCTBODY= 260,
CNTCTHAND= 261,
CNTCTOFHAND= 262,
A2TLIST= 263,
A1TLIST= 264,
A1LIST= 265,
ACTION2T= 266,
ACTION1T= 267,
ACTION2= 268,
ACTION1= 269,
PARACT2T= 270,
SEQACT2T= 271,
SPLITACT2LOC2= 272,
SPLITACT2T= 273,
PARACT1T= 274,
SEQACT1T= 275,
NMACT1T= 276,
PARACT1= 277,
REPETITIONS= 278,
SIMPLEMVMT= 279,
STRGHTMVMT= 280,
CRCLRMVMT= 281,
REPLACE= 282,
SPLITREPLACETL= 283,
REPLACETAIL1= 284,
HSFINGERITEM= 285,
LOCBODY= 286,
MOVINGREPETITION= 287,
SEQACT1= 288,
SEQFUSEDACT2T= 289,
SEQFUSEDACT1T= 290,
SEQFUSEDACT1= 291,
CNTCTOHHAND= 292,
CNTCTOHARM= 293;
var UP = org.antlr.runtime.Token.UP,
DOWN = org.antlr.runtime.Token.DOWN;
// public instance methods/vars
org.antlr.lang.extend(Ham4HMLGen, org.antlr.runtime.tree.TreeParser, {
getTokenNames: function() { return Ham4HMLGen.tokenNames; },
getGrammarFileName: function() { return "Ham4HMLGen.g"; }
});
org.antlr.lang.augmentObject(Ham4HMLGen.prototype, {
// Ham4HMLGen.g:45:1: hamsignseq[sb] returns [Element r = null] : ^( HAMSIGNS (s2or1= sign2or1 )* ) ;
// $ANTLR start "hamsignseq"
hamsignseq: function(sb) {
var r =  null;
var s2or1 = null;
// this.hBuilder = sb;     // Instance variable initialisation.
hBuilder = sb;     // Instance variable initialisation.
var     hss     = hBuilder.newHMLElement("hamnosys_sign");
//	Element     s2or1   = null
try {
// Ham4HMLGen.g:56:5: ( ^( HAMSIGNS (s2or1= sign2or1 )* ) )
// Ham4HMLGen.g:57:2: ^( HAMSIGNS (s2or1= sign2or1 )* )
this.match(this.input,HAMSIGNS,Ham4HMLGen.FOLLOW_HAMSIGNS_in_hamsignseq145); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:58:3: (s2or1= sign2or1 )*
loop1:
do {
var alt1=2;
var LA1_0 = this.input.LA(1);
if ( ((LA1_0>=SIGN2 && LA1_0<=SIGN1)) ) {
alt1=1;
}
switch (alt1) {
case 1 :
// Ham4HMLGen.g:59:4: s2or1= sign2or1
this.pushFollow(Ham4HMLGen.FOLLOW_sign2or1_in_hamsignseq160);
s2or1=this.sign2or1();
this.state._fsp--;
hss.appendChild(s2or1); 
break;
default :
break loop1;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
r = hBuilder.rootEl(hss);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return r;
},
// Ham4HMLGen.g:70:1: sign2or1 returns [Element rsgn = null] : (rsgn1= sign2 | rsgn2= nondomsign1 ) ;
// $ANTLR start "sign2or1"
sign2or1: function() {
var rsgn =  null;
var rsgn1 = null;
var rsgn2 = null;
try {
// Ham4HMLGen.g:74:5: ( (rsgn1= sign2 | rsgn2= nondomsign1 ) )
// Ham4HMLGen.g:75:5: (rsgn1= sign2 | rsgn2= nondomsign1 )
// Ham4HMLGen.g:75:5: (rsgn1= sign2 | rsgn2= nondomsign1 )
var alt2=2;
var LA2_0 = this.input.LA(1);
if ( (LA2_0==SIGN2) ) {
alt2=1;
}
else if ( (LA2_0==SIGN1) ) {
alt2=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 2, 0, this.input);
throw nvae;
}
switch (alt2) {
case 1 :
// Ham4HMLGen.g:76:9: rsgn1= sign2
this.pushFollow(Ham4HMLGen.FOLLOW_sign2_in_sign2or1242);
rsgn1=this.sign2();
this.state._fsp--;
rsgn = rsgn1; 
break;
case 2 :
// Ham4HMLGen.g:78:9: rsgn2= nondomsign1
this.pushFollow(Ham4HMLGen.FOLLOW_nondomsign1_in_sign2or1269);
rsgn2=this.nondomsign1();
this.state._fsp--;
rsgn = rsgn2; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:82:1: sign2 returns [Element rsgn = null] : ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) ) ;
// $ANTLR start "sign2"
sign2: function() {
var rsgn =  null;
var sym = null;
var icpair = null;
var atlst = null;
var     holdover    = false;
var     nondominant = false;
try {
// Ham4HMLGen.g:89:5: ( ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) ) )
// Ham4HMLGen.g:90:5: ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) )
this.match(this.input,SIGN2,Ham4HMLGen.FOLLOW_SIGN2_in_sign2320); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:91:9: (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar )
var alt4=3;
switch ( this.input.LA(1) ) {
case HamSymmpar:
case HamSymmlr:
alt4=1;
break;
case ICFG2:
alt4=2;
break;
case HamNomotion:
alt4=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);
throw nvae;
}
switch (alt4) {
case 1 :
// Ham4HMLGen.g:92:13: sym= symmoperator icpair= initialconfig2 atlst= a2tstar
this.pushFollow(Ham4HMLGen.FOLLOW_symmoperator_in_sign2352);
sym=this.symmoperator();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig2_in_sign2371);
icpair=this.initialconfig2();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a2tstar_in_sign2391);
atlst=this.a2tstar();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:96:13: icpair= initialconfig2 atlst= a1tstar
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig2_in_sign2420);
icpair=this.initialconfig2();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_sign2440);
atlst=this.a1tstar();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:100:13: HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar
this.match(this.input,HamNomotion,Ham4HMLGen.FOLLOW_HamNomotion_in_sign2477); 
holdover = true; 
// Ham4HMLGen.g:101:13: ( HamNondominant )?
var alt3=2;
var LA3_0 = this.input.LA(1);
if ( (LA3_0==HamNondominant) ) {
alt3=1;
}
switch (alt3) {
case 1 :
// Ham4HMLGen.g:101:15: HamNondominant
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_sign2511); 
nondominant = true; 
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig1_in_sign2546);
icpair=this.initialconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_sign2566);
atlst=this.a1tstar();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsgn = hBuilder.newHMLElement("sign2");
hBuilder.checkedAppendChild(rsgn, sym);
hBuilder.checkedAppendChild(rsgn, icpair[0]);
hBuilder.checkedAppendChild(rsgn, icpair[1]);
hBuilder.checkedAppendChildList(rsgn, atlst);
hBuilder.checkedSetFlagAttr(rsgn, "nondominant", nondominant);
hBuilder.checkedSetFlagAttr(rsgn, "holdover", holdover);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:117:1: nondomsign1 returns [Element rsgn = null] : ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar ) ;
// $ANTLR start "nondomsign1"
nondomsign1: function() {
var rsgn =  null;
var icpair = null;
var atlst = null;
try {
// Ham4HMLGen.g:121:5: ( ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar ) )
// Ham4HMLGen.g:122:5: ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar )
this.match(this.input,SIGN1,Ham4HMLGen.FOLLOW_SIGN1_in_nondomsign1620); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_nondomsign1640); 
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig1_in_nondomsign1655);
icpair=this.initialconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_nondomsign1671);
atlst=this.a1tstar();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsgn = hBuilder.newHMLElement("sign1");
hBuilder.checkedSetAttr(rsgn, "which_hand", "nondominant");
hBuilder.checkedAppendChild(rsgn, icpair[0]);
rsgn.appendChild(icpair[1]);
hBuilder.appendChildList(rsgn, atlst);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:136:1: symmoperator returns [Element rsym = null] : ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ) ;
// $ANTLR start "symmoperator"
symmoperator: function() {
var rsym =  null;
var  plr = null;
var  lg  = null;
var  fb  = null;
var alt = false;
var ni  = false;
try {
// Ham4HMLGen.g:146:5: ( ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ) )
// Ham4HMLGen.g:147:5: ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4HMLGen.g:147:5: ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4HMLGen.g:148:9: ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )?
// Ham4HMLGen.g:148:9: ( HamSymmpar | HamSymmlr )
var alt5=2;
var LA5_0 = this.input.LA(1);
if ( (LA5_0==HamSymmpar) ) {
alt5=1;
}
else if ( (LA5_0==HamSymmlr) ) {
alt5=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 5, 0, this.input);
throw nvae;
}
switch (alt5) {
case 1 :
// Ham4HMLGen.g:149:13: HamSymmpar
this.match(this.input,HamSymmpar,Ham4HMLGen.FOLLOW_HamSymmpar_in_symmoperator741); 
plr = "hamsymmpar"; 
break;
case 2 :
// Ham4HMLGen.g:151:13: HamSymmlr
this.match(this.input,HamSymmlr,Ham4HMLGen.FOLLOW_HamSymmlr_in_symmoperator776); 
plr = "hamsymmlr"; 
break;
}
// Ham4HMLGen.g:153:9: ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )?
var alt8=3;
var LA8_0 = this.input.LA(1);
if ( (LA8_0==HamLargemod) ) {
alt8=1;
}
else if ( (LA8_0==HamFingerstraightmod) ) {
alt8=2;
}
switch (alt8) {
case 1 :
// Ham4HMLGen.g:154:13: ( HamLargemod ) ( HamFingerstraightmod )?
// Ham4HMLGen.g:154:13: ( HamLargemod )
// Ham4HMLGen.g:154:15: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_symmoperator824); 
lg = "hamlargemod"; 
// Ham4HMLGen.g:155:13: ( HamFingerstraightmod )?
var alt6=2;
var LA6_0 = this.input.LA(1);
if ( (LA6_0==HamFingerstraightmod) ) {
alt6=1;
}
switch (alt6) {
case 1 :
// Ham4HMLGen.g:155:15: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_symmoperator859); 
fb = "hamfingerbent"; 
break;
}
break;
case 2 :
// Ham4HMLGen.g:157:13: ( HamFingerstraightmod ) ( HamLargemod )?
// Ham4HMLGen.g:157:13: ( HamFingerstraightmod )
// Ham4HMLGen.g:157:15: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_symmoperator893); 
fb = "hamfingerbent"; 
// Ham4HMLGen.g:158:13: ( HamLargemod )?
var alt7=2;
var LA7_0 = this.input.LA(1);
if ( (LA7_0==HamLargemod) ) {
alt7=1;
}
switch (alt7) {
case 1 :
// Ham4HMLGen.g:158:15: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_symmoperator916); 
lg = "hamlargemod"; 
break;
}
break;
}
// Ham4HMLGen.g:160:9: ( HamAlternatingmotion )?
var alt9=2;
var LA9_0 = this.input.LA(1);
if ( (LA9_0==HamAlternatingmotion) ) {
alt9=1;
}
switch (alt9) {
case 1 :
// Ham4HMLGen.g:160:13: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_symmoperator961); 
alt= true; 
break;
}
// Ham4HMLGen.g:161:9: ( HamNonipsi )?
var alt10=2;
var LA10_0 = this.input.LA(1);
if ( (LA10_0==HamNonipsi) ) {
alt10=1;
}
switch (alt10) {
case 1 :
// Ham4HMLGen.g:161:13: HamNonipsi
this.match(this.input,HamNonipsi,Ham4HMLGen.FOLLOW_HamNonipsi_in_symmoperator983); 
ni = true; 
break;
}
rsym = hBuilder.newHMLElement("symmoperator");
hBuilder.checkedSetAttr(rsym, "att_par_or_lr", plr);
hBuilder.checkedSetAttr(rsym, "attrib_oi_symm", fb);
hBuilder.checkedSetAttr(rsym, "attrib_ud_symm", lg);
hBuilder.checkedSetFlagAttr(rsym, "outofphase", alt);
hBuilder.checkedSetFlagAttr(rsym, "nonipsi", ni);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsym;
},
// Ham4HMLGen.g:176:1: initialconfig2 returns [Element[] ricpair] : ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 ) ;
// $ANTLR start "initialconfig2"
initialconfig2: function() {
var ricpair = null;
var nmic = null;
var mic = null;
try {
// Ham4HMLGen.g:181:5: ( ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 ) )
// Ham4HMLGen.g:182:5: ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 )
this.match(this.input,ICFG2,Ham4HMLGen.FOLLOW_ICFG2_in_initialconfig21044); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:183:9: (nmic= nminitialconfig )?
var alt11=2;
var LA11_0 = this.input.LA(1);
if ( (LA11_0==NMICLIST) ) {
alt11=1;
}
switch (alt11) {
case 1 :
// Ham4HMLGen.g:183:11: nmic= nminitialconfig
this.pushFollow(Ham4HMLGen.FOLLOW_nminitialconfig_in_initialconfig21061);
nmic=this.nminitialconfig();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_minitialconfig2_in_initialconfig21082);
mic=this.minitialconfig2();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ricpair = [nmic, mic];
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ricpair;
},
// Ham4HMLGen.g:191:1: initialconfig1 returns [Element[] ricpair] : ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 ) ;
// $ANTLR start "initialconfig1"
initialconfig1: function() {
var ricpair = null;
var nmic = null;
var mic = null;
try {
// Ham4HMLGen.g:196:5: ( ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 ) )
// Ham4HMLGen.g:197:5: ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 )
this.match(this.input,ICFG1,Ham4HMLGen.FOLLOW_ICFG1_in_initialconfig11123); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:198:9: (nmic= nminitialconfig )?
var alt12=2;
var LA12_0 = this.input.LA(1);
if ( (LA12_0==NMICLIST) ) {
alt12=1;
}
switch (alt12) {
case 1 :
// Ham4HMLGen.g:198:11: nmic= nminitialconfig
this.pushFollow(Ham4HMLGen.FOLLOW_nminitialconfig_in_initialconfig11140);
nmic=this.nminitialconfig();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_minitialconfig1_in_initialconfig11161);
mic=this.minitialconfig1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ricpair = [nmic, mic];
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ricpair;
},
// Ham4HMLGen.g:206:1: nminitialconfig returns [Element rnmic = null] : ^( NMICLIST (nmpair= nmicunit )+ ) ;
// $ANTLR start "nminitialconfig"
nminitialconfig: function() {
var rnmic =  null;
var nmpair = null;
rnmic = hBuilder.newHMLElement("nminitialconfig");
try {
// Ham4HMLGen.g:212:5: ( ^( NMICLIST (nmpair= nmicunit )+ ) )
// Ham4HMLGen.g:213:5: ^( NMICLIST (nmpair= nmicunit )+ )
this.match(this.input,NMICLIST,Ham4HMLGen.FOLLOW_NMICLIST_in_nminitialconfig1209); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:214:9: (nmpair= nmicunit )+
var cnt13=0;
loop13:
do {
var alt13=2;
var LA13_0 = this.input.LA(1);
if ( (LA13_0==NMICUNIT) ) {
alt13=1;
}
switch (alt13) {
case 1 :
// Ham4HMLGen.g:215:13: nmpair= nmicunit
this.pushFollow(Ham4HMLGen.FOLLOW_nmicunit_in_nminitialconfig1238);
nmpair=this.nmicunit();
this.state._fsp--;
rnmic.appendChild(nmpair[0]);
rnmic.appendChild(nmpair[1]);
break;
default :
if ( cnt13 >= 1 ) {
break loop13;
}
var eee = new org.antlr.runtime.EarlyExitException(13, this.input);
throw eee;
}
cnt13++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnmic;
},
// Ham4HMLGen.g:224:1: nmicunit returns [Element[] rnmpair = [null,null]] : ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 ) ;
// $ANTLR start "nmicunit"
nmicunit: function() {
var rnmpair =  [null,null];
var nma = null;
var nmb = null;
try {
// Ham4HMLGen.g:230:5: ( ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 ) )
// Ham4HMLGen.g:231:5: ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 )
this.match(this.input,NMICUNIT,Ham4HMLGen.FOLLOW_NMICUNIT_in_nmicunit1304); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:232:9: (nma= levelbody | nma= levelarm )
var alt14=2;
var LA14_0 = this.input.LA(1);
if ( (LA14_0==LEVBODY) ) {
alt14=1;
}
else if ( (LA14_0==LEVARM) ) {
alt14=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 14, 0, this.input);
throw nvae;
}
switch (alt14) {
case 1 :
// Ham4HMLGen.g:233:13: nma= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_nmicunit1332);
nma=this.levelbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:235:13: nma= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_nmicunit1361);
nma=this.levelarm();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_nmicunit1385);
nmb=this.action1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rnmpair[0] = nma;
rnmpair[1] = nmb;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnmpair;
},
// Ham4HMLGen.g:245:1: minitialconfig2 returns [Element rmic = null] : ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) ) ;
// $ANTLR start "minitialconfig2"
minitialconfig2: function() {
var rmic =  null;
var hc2 = null;
var loc2 = null;
var hc1 = null;
var l1dom = null;
var l1sub = null;
try {
// Ham4HMLGen.g:248:5: ( ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) ) )
// Ham4HMLGen.g:249:5: ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) )
this.match(this.input,MICFG2,Ham4HMLGen.FOLLOW_MICFG2_in_minitialconfig21425); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:250:9: (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? )
var alt18=2;
var LA18_0 = this.input.LA(1);
if ( (LA18_0==HDCONFIG2) ) {
alt18=1;
}
else if ( (LA18_0==HDCONFIG1) ) {
alt18=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 18, 0, this.input);
throw nvae;
}
switch (alt18) {
case 1 :
// Ham4HMLGen.g:251:13: hc2= handconfig2 (loc2= location2 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig2_in_minitialconfig21457);
hc2=this.handconfig2();
this.state._fsp--;
// Ham4HMLGen.g:252:13: (loc2= location2 )?
var alt15=2;
var LA15_0 = this.input.LA(1);
if ( (LA15_0==LOC2) ) {
alt15=1;
}
switch (alt15) {
case 1 :
// Ham4HMLGen.g:252:15: loc2= location2
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_minitialconfig21478);
loc2=this.location2();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:254:13: hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_minitialconfig21513);
hc1=this.handconfig1();
this.state._fsp--;
// Ham4HMLGen.g:255:13: (l1dom= location1 )?
var alt16=2;
var LA16_0 = this.input.LA(1);
if ( (LA16_0==LOC1) ) {
alt16=1;
}
switch (alt16) {
case 1 :
// Ham4HMLGen.g:255:15: l1dom= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig21533);
l1dom=this.location1();
this.state._fsp--;
break;
}
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_minitialconfig21560); 
// Ham4HMLGen.g:257:13: (l1sub= location1 )?
var alt17=2;
var LA17_0 = this.input.LA(1);
if ( (LA17_0==LOC1) ) {
alt17=1;
}
switch (alt17) {
case 1 :
// Ham4HMLGen.g:257:15: l1sub= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig21580);
l1sub=this.location1();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (hc2 == null) {
hc2 = hBuilder.newHMLElement("handconfig2");
hc2.appendChild(hc1);
loc2 = hBuilder.newHMLElement("location2");
hBuilder.checkedAppendChild(loc2, l1dom);  // ???? valid?
hBuilder.checkedAppendChild(loc2, l1sub);  // ???? valid?
}
rmic = hBuilder.newHMLElement("minitialconfig2");
rmic.appendChild(hc2);
hBuilder.checkedAppendChild(rmic, loc2);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmic;
},
// Ham4HMLGen.g:274:1: minitialconfig1 returns [Element rmic = null] : ^( MICFG1 hc1= handconfig1 (loc1= location1 )? ) ;
// $ANTLR start "minitialconfig1"
minitialconfig1: function() {
var rmic =  null;
var hc1 = null;
var loc1 = null;
try {
// Ham4HMLGen.g:277:5: ( ^( MICFG1 hc1= handconfig1 (loc1= location1 )? ) )
// Ham4HMLGen.g:278:5: ^( MICFG1 hc1= handconfig1 (loc1= location1 )? )
this.match(this.input,MICFG1,Ham4HMLGen.FOLLOW_MICFG1_in_minitialconfig11633); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_minitialconfig11651);
hc1=this.handconfig1();
this.state._fsp--;
// Ham4HMLGen.g:280:9: (loc1= location1 )?
var alt19=2;
var LA19_0 = this.input.LA(1);
if ( (LA19_0==LOC1) ) {
alt19=1;
}
switch (alt19) {
case 1 :
// Ham4HMLGen.g:280:11: loc1= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig11668);
loc1=this.location1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rmic = hBuilder.newHMLElement("minitialconfig1");
rmic.appendChild(hc1);
hBuilder.checkedAppendChild(rmic, loc1);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmic;
},
// Ham4HMLGen.g:292:1: handconfig2 returns [Element rhc = null] : ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) ) ;
// $ANTLR start "handconfig2"
handconfig2: function() {
var rhc =  null;
var hs2 = null;
var tailpair = null;
var shc = null;
try {
// Ham4HMLGen.g:295:5: ( ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) ) )
// Ham4HMLGen.g:296:5: ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) )
this.match(this.input,HDCONFIG2,Ham4HMLGen.FOLLOW_HDCONFIG2_in_handconfig21718); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:297:9: (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 )
var alt21=2;
var LA21_0 = this.input.LA(1);
if ( (LA21_0==HSHAPE2) ) {
alt21=1;
}
else if ( (LA21_0==SPLITHDCFG2) ) {
alt21=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 21, 0, this.input);
throw nvae;
}
switch (alt21) {
case 1 :
// Ham4HMLGen.g:298:13: hs2= handshape2 (tailpair= handconfigtail2 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handshape2_in_handconfig21754);
hs2=this.handshape2();
this.state._fsp--;
// Ham4HMLGen.g:299:13: (tailpair= handconfigtail2 )?
var alt20=2;
var LA20_0 = this.input.LA(1);
if ( (LA20_0==HDCFGTAIL2) ) {
alt20=1;
}
switch (alt20) {
case 1 :
// Ham4HMLGen.g:299:15: tailpair= handconfigtail2
this.pushFollow(Ham4HMLGen.FOLLOW_handconfigtail2_in_handconfig21775);
tailpair=this.handconfigtail2();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:301:13: shc= splithandconfig2
this.pushFollow(Ham4HMLGen.FOLLOW_splithandconfig2_in_handconfig21814);
shc=this.splithandconfig2();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = shc;
if (rhc == null) {
rhc = hBuilder.newHMLElement("handconfig2");
rhc.appendChild(hs2);
if (tailpair != null) {
rhc.appendChild(tailpair[0]);   // efd2
rhc.appendChild(tailpair[1]);   // po2
}
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:318:1: handconfig1 returns [Element rhc = null] : ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? ) ;
// $ANTLR start "handconfig1"
handconfig1: function() {
var rhc =  null;
var hs = null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:321:5: ( ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? ) )
// Ham4HMLGen.g:322:5: ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? )
this.match(this.input,HDCONFIG1,Ham4HMLGen.FOLLOW_HDCONFIG1_in_handconfig11868); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handconfig11887);
hs=this.handshape1();
this.state._fsp--;
// Ham4HMLGen.g:324:9: (efd= extfidir1 )?
var alt22=2;
var LA22_0 = this.input.LA(1);
if ( (LA22_0==EXTFIDIR1) ) {
alt22=1;
}
switch (alt22) {
case 1 :
// Ham4HMLGen.g:324:11: efd= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfig11905);
efd=this.extfidir1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:325:9: (po= palmor1 )?
var alt23=2;
var LA23_0 = this.input.LA(1);
if ( (LA23_0==PALMOR1) ) {
alt23=1;
}
switch (alt23) {
case 1 :
// Ham4HMLGen.g:325:11: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfig11927);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconfig1");
rhc.appendChild(hs);
hBuilder.checkedAppendChild(rhc, efd);
hBuilder.checkedAppendChild(rhc, po);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:336:1: splithandconfig2 returns [Element rhc = null] : ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 ) ;
// $ANTLR start "splithandconfig2"
splithandconfig2: function() {
var rhc =  null;
var hcdom = null;
var hcnd = null;
try {
// Ham4HMLGen.g:339:5: ( ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 ) )
// Ham4HMLGen.g:340:5: ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 )
this.match(this.input,SPLITHDCFG2,Ham4HMLGen.FOLLOW_SPLITHDCFG2_in_splithandconfig21982); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_splithandconfig21998);
hcdom=this.handconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_splithandconfig22014);
hcnd=this.handconfig1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconfig2");
rhc.appendChild(hcdom);
rhc.appendChild(hcnd);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:351:1: handconfigtail2 returns [Element[] rtlpair = [null,null]] : ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) ) ;
// $ANTLR start "handconfigtail2"
handconfigtail2: function() {
var rtlpair =  [null,null];
var tmp = null;
var efd1d = null;
var po1d = null;
var efd1s = null;
var po1s = null;
try {
// Ham4HMLGen.g:356:5: ( ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) ) )
// Ham4HMLGen.g:357:5: ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) )
this.match(this.input,HDCFGTAIL2,Ham4HMLGen.FOLLOW_HDCFGTAIL2_in_handconfigtail22058); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:358:9: (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 )
var alt24=2;
var LA24_0 = this.input.LA(1);
if ( (LA24_0==EXTFIDIR2) ) {
alt24=1;
}
else if ( (LA24_0==EXTFIDIR1) ) {
alt24=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);
throw nvae;
}
switch (alt24) {
case 1 :
// Ham4HMLGen.g:359:13: tmp= extfidir2 tmp= palmor2
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir2_in_handconfigtail22092);
tmp=this.extfidir2();
this.state._fsp--;
rtlpair[0] = tmp; 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor2_in_handconfigtail22124);
tmp=this.palmor2();
this.state._fsp--;
rtlpair[1] = tmp; 
break;
case 2 :
// Ham4HMLGen.g:362:13: efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfigtail22166);
efd1d=this.extfidir1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfigtail22189);
po1d=this.palmor1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfigtail22211);
efd1s=this.extfidir1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfigtail22234);
po1s=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (efd1d != null) {
rtlpair[0]  =  hBuilder.newHMLElement("extfidir2");
rtlpair[0].appendChild(efd1d);
rtlpair[0].appendChild(efd1s);
rtlpair[1]  =  hBuilder.newHMLElement("palmor2");
rtlpair[1].appendChild(po1d);
rtlpair[1].appendChild(po1s);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rtlpair;
},
// Ham4HMLGen.g:385:1: handshape2 returns [Element rhs = null] : ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? ) ;
// $ANTLR start "handshape2"
handshape2: function() {
var rhs =  null;
var hsa = null;
var hsb = null;
try {
// Ham4HMLGen.g:388:5: ( ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? ) )
// Ham4HMLGen.g:389:5: ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? )
this.match(this.input,HSHAPE2,Ham4HMLGen.FOLLOW_HSHAPE2_in_handshape22292); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handshape22310);
hsa=this.handshape1();
this.state._fsp--;
// Ham4HMLGen.g:391:9: (hsb= handshape1 )?
var alt25=2;
var LA25_0 = this.input.LA(1);
if ( (LA25_0==HSHAPE1) ) {
alt25=1;
}
switch (alt25) {
case 1 :
// Ham4HMLGen.g:391:11: hsb= handshape1
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handshape22328);
hsb=this.handshape1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhs = hBuilder.newHMLElement("handshape2");
rhs.appendChild(hsa);
hBuilder.checkedAppendChild(rhs, hsb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhs;
},
// Ham4HMLGen.g:400:1: handshape1 returns [Element rhs = null] : ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? ) ;
// $ANTLR start "handshape1"
handshape1: function() {
var rhs =  null;
var attr24 = null;
var fnglst = null;
var fshlst = null;
var fcrlst = null;
var thspc = null;
try {
// Ham4HMLGen.g:403:5: ( ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? ) )
// Ham4HMLGen.g:404:5: ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? )
this.match(this.input,HSHAPE1,Ham4HMLGen.FOLLOW_HSHAPE1_in_handshape12376); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape1_in_handshape12395);
attr24=this.basichandshape1();
this.state._fsp--;
// Ham4HMLGen.g:406:9: (fnglst= fingerlist )?
var alt26=2;
var LA26_0 = this.input.LA(1);
if ( (LA26_0==FINGERLIST) ) {
alt26=1;
}
switch (alt26) {
case 1 :
// Ham4HMLGen.g:406:11: fnglst= fingerlist
this.pushFollow(Ham4HMLGen.FOLLOW_fingerlist_in_handshape12414);
fnglst=this.fingerlist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:407:9: (fshlst= fingershapelist )?
var alt27=2;
var LA27_0 = this.input.LA(1);
if ( (LA27_0==FISHPLIST) ) {
alt27=1;
}
switch (alt27) {
case 1 :
// Ham4HMLGen.g:407:11: fshlst= fingershapelist
this.pushFollow(Ham4HMLGen.FOLLOW_fingershapelist_in_handshape12436);
fshlst=this.fingershapelist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:408:9: (fcrlst= fingercrossinglist )?
var alt28=2;
var LA28_0 = this.input.LA(1);
if ( (LA28_0==FICRSSLIST) ) {
alt28=1;
}
switch (alt28) {
case 1 :
// Ham4HMLGen.g:408:11: fcrlst= fingercrossinglist
this.pushFollow(Ham4HMLGen.FOLLOW_fingercrossinglist_in_handshape12458);
fcrlst=this.fingercrossinglist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:409:9: (thspc= thumbspecial )?
var alt29=2;
var LA29_0 = this.input.LA(1);
if ( (LA29_0==THSPECIAL) ) {
alt29=1;
}
switch (alt29) {
case 1 :
// Ham4HMLGen.g:409:11: thspc= thumbspecial
this.pushFollow(Ham4HMLGen.FOLLOW_thumbspecial_in_handshape12481);
thspc=this.thumbspecial();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhs = hBuilder.newHMLElement("handshape1");
hBuilder.checkedSetAttr(
rhs,    "handshapeclass",   attr24[0][0]);
hBuilder.checkedSetAttr(
rhs,    "thumbpos",         attr24[0][1]);
hBuilder.checkedSetAttr(rhs,
"fingerbending",    attr24[0][2]);
hBuilder.checkedStringSetFlagAttr(rhs,
"approx_shape",     attr24[0][3]);
if (attr24[1] != null) {
hBuilder.checkedSetAttr(
rhs,    "second_handshapeclass",    attr24[1][0]);
hBuilder.checkedSetAttr(
rhs,    "second_thumbpos",          attr24[1][1]);
hBuilder.checkedSetAttr(
rhs,    "second_fingerbending",     attr24[1][2]);
}
hBuilder.checkedAppendChildList(rhs, fnglst);
hBuilder.checkedAppendChildList(rhs, fshlst);
hBuilder.checkedAppendChildList(rhs, fcrlst);
hBuilder.checkedAppendChild(rhs, thspc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhs;
},
// Ham4HMLGen.g:436:1: basichandshape1 returns [String[][] rbh = []] : ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? ) ;
// $ANTLR start "basichandshape1"
basichandshape1: function() {
var rbh =  [];
var bha = null;
var bhb = null;
try {
// Ham4HMLGen.g:440:5: ( ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? ) )
// Ham4HMLGen.g:441:5: ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? )
this.match(this.input,BASICHDSHP1,Ham4HMLGen.FOLLOW_BASICHDSHP1_in_basichandshape12524); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape_in_basichandshape12542);
bha=this.basichandshape();
this.state._fsp--;
rbh[0] = bha; 
// Ham4HMLGen.g:443:9: (bhb= basichandshape )?
var alt30=2;
var LA30_0 = this.input.LA(1);
if ( (LA30_0==BASICHDSHP) ) {
alt30=1;
}
switch (alt30) {
case 1 :
// Ham4HMLGen.g:443:11: bhb= basichandshape
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape_in_basichandshape12565);
bhb=this.basichandshape();
this.state._fsp--;
rbh[1] = bhb; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rbh;
},
// Ham4HMLGen.g:449:1: basichandshape returns [String[] rbhquad = [null,null,null,null]] : ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) ) ;
// $ANTLR start "basichandshape"
basichandshape: function() {
var rbhquad =  [null,null,null,null];
var tmp = null;
try {
// Ham4HMLGen.g:458:5: ( ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) ) )
// Ham4HMLGen.g:459:5: ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) )
this.match(this.input,BASICHDSHP,Ham4HMLGen.FOLLOW_BASICHDSHP_in_basichandshape2614); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:460:9: (tmp= handshapeclass | HamNondominant )
var alt31=2;
var LA31_0 = this.input.LA(1);
if ( (LA31_0==HSCLASS) ) {
alt31=1;
}
else if ( (LA31_0==HamNondominant) ) {
alt31=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 31, 0, this.input);
throw nvae;
}
switch (alt31) {
case 1 :
// Ham4HMLGen.g:460:11: tmp= handshapeclass
this.pushFollow(Ham4HMLGen.FOLLOW_handshapeclass_in_basichandshape2636);
tmp=this.handshapeclass();
this.state._fsp--;
rbhquad[0] = tmp; 
break;
case 2 :
// Ham4HMLGen.g:461:23: HamNondominant
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_basichandshape2665); 
rbhquad[0] = "ham_nondominant"; 
break;
}
// Ham4HMLGen.g:463:9: ( HamEtc )?
var alt32=2;
var LA32_0 = this.input.LA(1);
if ( (LA32_0==HamEtc) ) {
alt32=1;
}
switch (alt32) {
case 1 :
// Ham4HMLGen.g:463:11: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_basichandshape2692); 
rbhquad[3] = "true";  
break;
}
// Ham4HMLGen.g:464:9: ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? )
var alt35=3;
switch ( this.input.LA(1) ) {
case UP:
alt35=1;
break;
case THUMBPOS:
alt35=2;
break;
case FIBENDING:
alt35=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 35, 0, this.input);
throw nvae;
}
switch (alt35) {
case 1 :
// Ham4HMLGen.g:466:9: 
break;
case 2 :
// Ham4HMLGen.g:467:13: tmp= thumbpos (tmp= fingerbending )?
this.pushFollow(Ham4HMLGen.FOLLOW_thumbpos_in_basichandshape2776);
tmp=this.thumbpos();
this.state._fsp--;
rbhquad[1] = tmp; 
// Ham4HMLGen.g:468:13: (tmp= fingerbending )?
var alt33=2;
var LA33_0 = this.input.LA(1);
if ( (LA33_0==FIBENDING) ) {
alt33=1;
}
switch (alt33) {
case 1 :
// Ham4HMLGen.g:468:15: tmp= fingerbending
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_basichandshape2809);
tmp=this.fingerbending();
this.state._fsp--;
rbhquad[2] = tmp; 
break;
}
break;
case 3 :
// Ham4HMLGen.g:470:13: tmp= fingerbending (tmp= thumbpos )?
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_basichandshape2850);
tmp=this.fingerbending();
this.state._fsp--;
rbhquad[2] = tmp; 
// Ham4HMLGen.g:471:13: (tmp= thumbpos )?
var alt34=2;
var LA34_0 = this.input.LA(1);
if ( (LA34_0==THUMBPOS) ) {
alt34=1;
}
switch (alt34) {
case 1 :
// Ham4HMLGen.g:471:15: tmp= thumbpos
this.pushFollow(Ham4HMLGen.FOLLOW_thumbpos_in_basichandshape2878);
tmp=this.thumbpos();
this.state._fsp--;
rbhquad[1] = tmp; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rbhquad;
},
// Ham4HMLGen.g:476:1: handshapeclass returns [String rhsc = null] : ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ) ;
// $ANTLR start "handshapeclass"
handshapeclass: function() {
var rhsc =  null;
try {
// Ham4HMLGen.g:478:5: ( ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ) )
// Ham4HMLGen.g:479:5: ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) )
this.match(this.input,HSCLASS,Ham4HMLGen.FOLLOW_HSCLASS_in_handshapeclass2937); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:480:9: ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open )
var alt36=12;
switch ( this.input.LA(1) ) {
case HamFist:
alt36=1;
break;
case HamFlathand:
alt36=2;
break;
case HamFinger2:
alt36=3;
break;
case HamFinger23:
alt36=4;
break;
case HamFinger23spread:
alt36=5;
break;
case HamFinger2345:
alt36=6;
break;
case HamPinch12:
alt36=7;
break;
case HamPinchall:
alt36=8;
break;
case HamPinch12open:
alt36=9;
break;
case HamCee12:
alt36=10;
break;
case HamCeeall:
alt36=11;
break;
case HamCee12open:
alt36=12;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 36, 0, this.input);
throw nvae;
}
switch (alt36) {
case 1 :
// Ham4HMLGen.g:480:13: HamFist
this.match(this.input,HamFist,Ham4HMLGen.FOLLOW_HamFist_in_handshapeclass2951); 
rhsc = "ham_fist"; 
break;
case 2 :
// Ham4HMLGen.g:481:13: HamFlathand
this.match(this.input,HamFlathand,Ham4HMLGen.FOLLOW_HamFlathand_in_handshapeclass2979); 
rhsc = "ham_flathand"; 
break;
case 3 :
// Ham4HMLGen.g:482:13: HamFinger2
this.match(this.input,HamFinger2,Ham4HMLGen.FOLLOW_HamFinger2_in_handshapeclass3003); 
rhsc = "ham_finger2"; 
break;
case 4 :
// Ham4HMLGen.g:483:13: HamFinger23
this.match(this.input,HamFinger23,Ham4HMLGen.FOLLOW_HamFinger23_in_handshapeclass3028); 
rhsc = "ham_finger23"; 
break;
case 5 :
// Ham4HMLGen.g:484:13: HamFinger23spread
this.match(this.input,HamFinger23spread,Ham4HMLGen.FOLLOW_HamFinger23spread_in_handshapeclass3052); 
rhsc = "ham_finger23spread"; 
break;
case 6 :
// Ham4HMLGen.g:485:13: HamFinger2345
this.match(this.input,HamFinger2345,Ham4HMLGen.FOLLOW_HamFinger2345_in_handshapeclass3070); 
rhsc = "ham_finger2345"; 
break;
case 7 :
// Ham4HMLGen.g:486:13: HamPinch12
this.match(this.input,HamPinch12,Ham4HMLGen.FOLLOW_HamPinch12_in_handshapeclass3092); 
rhsc = "ham_pinch12"; 
break;
case 8 :
// Ham4HMLGen.g:487:13: HamPinchall
this.match(this.input,HamPinchall,Ham4HMLGen.FOLLOW_HamPinchall_in_handshapeclass3117); 
rhsc = "ham_pinchall"; 
break;
case 9 :
// Ham4HMLGen.g:488:13: HamPinch12open
this.match(this.input,HamPinch12open,Ham4HMLGen.FOLLOW_HamPinch12open_in_handshapeclass3141); 
rhsc = "ham_pinch12open"; 
break;
case 10 :
// Ham4HMLGen.g:489:13: HamCee12
this.match(this.input,HamCee12,Ham4HMLGen.FOLLOW_HamCee12_in_handshapeclass3162); 
rhsc = "ham_cee12"; 
break;
case 11 :
// Ham4HMLGen.g:490:13: HamCeeall
this.match(this.input,HamCeeall,Ham4HMLGen.FOLLOW_HamCeeall_in_handshapeclass3189); 
rhsc = "ham_ceeall"; 
break;
case 12 :
// Ham4HMLGen.g:491:13: HamCee12open
this.match(this.input,HamCee12open,Ham4HMLGen.FOLLOW_HamCee12open_in_handshapeclass3215); 
rhsc = "ham_cee12open"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhsc;
},
// Ham4HMLGen.g:496:1: fingerbending returns [String rfb = null] : ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ) ;
// $ANTLR start "fingerbending"
fingerbending: function() {
var rfb =  null;
try {
// Ham4HMLGen.g:498:5: ( ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ) )
// Ham4HMLGen.g:499:5: ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) )
this.match(this.input,FIBENDING,Ham4HMLGen.FOLLOW_FIBENDING_in_fingerbending3270); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:500:9: ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked )
var alt37=5;
switch ( this.input.LA(1) ) {
case HamFingerstraightmod:
alt37=1;
break;
case HamFingerbendmod:
alt37=2;
break;
case HamFingerhookedmod:
alt37=3;
break;
case HamDoublebent:
alt37=4;
break;
case HamDoublehooked:
alt37=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 37, 0, this.input);
throw nvae;
}
switch (alt37) {
case 1 :
// Ham4HMLGen.g:500:13: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_fingerbending3284); 
rfb = "ham_finger_straight"; 
break;
case 2 :
// Ham4HMLGen.g:501:13: HamFingerbendmod
this.match(this.input,HamFingerbendmod,Ham4HMLGen.FOLLOW_HamFingerbendmod_in_fingerbending3303); 
rfb = "ham_finger_bend"; 
break;
case 3 :
// Ham4HMLGen.g:502:13: HamFingerhookedmod
this.match(this.input,HamFingerhookedmod,Ham4HMLGen.FOLLOW_HamFingerhookedmod_in_fingerbending3326); 
rfb = "ham_finger_hooked"; 
break;
case 4 :
// Ham4HMLGen.g:503:13: HamDoublebent
this.match(this.input,HamDoublebent,Ham4HMLGen.FOLLOW_HamDoublebent_in_fingerbending3347); 
rfb = "ham_finger_dblbent"; 
break;
case 5 :
// Ham4HMLGen.g:504:13: HamDoublehooked
this.match(this.input,HamDoublehooked,Ham4HMLGen.FOLLOW_HamDoublehooked_in_fingerbending3373); 
rfb = "ham_finger_dblhooked"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfb;
},
// Ham4HMLGen.g:509:1: thumbpos returns [String rtp = null] : ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ) ;
// $ANTLR start "thumbpos"
thumbpos: function() {
var rtp =  null;
try {
// Ham4HMLGen.g:511:5: ( ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ) )
// Ham4HMLGen.g:512:5: ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) )
this.match(this.input,THUMBPOS,Ham4HMLGen.FOLLOW_THUMBPOS_in_thumbpos3434); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:513:9: ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod )
var alt38=3;
switch ( this.input.LA(1) ) {
case HamThumboutmod:
alt38=1;
break;
case HamThumbacrossmod:
alt38=2;
break;
case HamThumbopenmod:
alt38=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 38, 0, this.input);
throw nvae;
}
switch (alt38) {
case 1 :
// Ham4HMLGen.g:513:13: HamThumboutmod
this.match(this.input,HamThumboutmod,Ham4HMLGen.FOLLOW_HamThumboutmod_in_thumbpos3448); 
rtp = "ham_thumb_out"; 
break;
case 2 :
// Ham4HMLGen.g:514:13: HamThumbacrossmod
this.match(this.input,HamThumbacrossmod,Ham4HMLGen.FOLLOW_HamThumbacrossmod_in_thumbpos3469); 
rtp = "ham_thumb_across"; 
break;
case 3 :
// Ham4HMLGen.g:515:13: HamThumbopenmod
this.match(this.input,HamThumbopenmod,Ham4HMLGen.FOLLOW_HamThumbopenmod_in_thumbpos3487); 
rtp = "ham_thumb_open"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rtp;
},
// Ham4HMLGen.g:520:1: thumb returns [Element rth = null] : HamThumb ;
// $ANTLR start "thumb"
thumb: function() {
var rth =  null;
try {
// Ham4HMLGen.g:523:5: ( HamThumb )
// Ham4HMLGen.g:523:9: HamThumb
this.match(this.input,HamThumb,Ham4HMLGen.FOLLOW_HamThumb_in_thumb3544); 
rth = hBuilder.newHMLElement("thumb");
rth.setAttribute("fingerid", "ham_digit_1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rth;
},
// Ham4HMLGen.g:530:1: finger returns [Element rfngr = null] : ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky ) ;
// $ANTLR start "finger"
finger: function() {
var rfngr =  null;
var fi = null;
try {
// Ham4HMLGen.g:536:5: ( ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky ) )
// Ham4HMLGen.g:537:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
// Ham4HMLGen.g:537:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
var alt39=4;
switch ( this.input.LA(1) ) {
case HamIndexfinger:
alt39=1;
break;
case HamMiddlefinger:
alt39=2;
break;
case HamRingfinger:
alt39=3;
break;
case HamPinky:
alt39=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 39, 0, this.input);
throw nvae;
}
switch (alt39) {
case 1 :
// Ham4HMLGen.g:537:9: HamIndexfinger
this.match(this.input,HamIndexfinger,Ham4HMLGen.FOLLOW_HamIndexfinger_in_finger3594); 
fi = "2"; 
break;
case 2 :
// Ham4HMLGen.g:538:9: HamMiddlefinger
this.match(this.input,HamMiddlefinger,Ham4HMLGen.FOLLOW_HamMiddlefinger_in_finger3615); 
fi = "3"; 
break;
case 3 :
// Ham4HMLGen.g:539:9: HamRingfinger
this.match(this.input,HamRingfinger,Ham4HMLGen.FOLLOW_HamRingfinger_in_finger3635); 
fi = "4"; 
break;
case 4 :
// Ham4HMLGen.g:540:9: HamPinky
this.match(this.input,HamPinky,Ham4HMLGen.FOLLOW_HamPinky_in_finger3657); 
fi = "5"; 
break;
}
rfngr = hBuilder.newHMLElement("fingernothumb");
rfngr.setAttribute("fingerid", "ham_digit_" + fi);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngr;
},
// Ham4HMLGen.g:548:1: hsfingeritem returns [Element rfngr = null] : ^( HSFINGERITEM fngr= finger ( HamLargemod )? ) ;
// $ANTLR start "hsfingeritem"
hsfingeritem: function() {
var rfngr =  null;
var fngr = null;
var opthumb = false;
try {
// Ham4HMLGen.g:554:5: ( ^( HSFINGERITEM fngr= finger ( HamLargemod )? ) )
// Ham4HMLGen.g:555:5: ^( HSFINGERITEM fngr= finger ( HamLargemod )? )
this.match(this.input,HSFINGERITEM,Ham4HMLGen.FOLLOW_HSFINGERITEM_in_hsfingeritem3721); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_hsfingeritem3735);
fngr=this.finger();
this.state._fsp--;
rfngr = fngr; 
// Ham4HMLGen.g:557:9: ( HamLargemod )?
var alt40=2;
var LA40_0 = this.input.LA(1);
if ( (LA40_0==HamLargemod) ) {
alt40=1;
}
switch (alt40) {
case 1 :
// Ham4HMLGen.g:557:11: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_hsfingeritem3755); 
opthumb = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
hBuilder.checkedSetFlagAttr(rfngr, "thumbopp", opthumb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngr;
},
// Ham4HMLGen.g:564:1: digit returns [Element rd = null] : (fi= thumb | fi= finger ) ;
// $ANTLR start "digit"
digit: function() {
var rd =  null;
var fi = null;
try {
// Ham4HMLGen.g:567:5: ( (fi= thumb | fi= finger ) )
// Ham4HMLGen.g:568:5: (fi= thumb | fi= finger )
// Ham4HMLGen.g:568:5: (fi= thumb | fi= finger )
var alt41=2;
var LA41_0 = this.input.LA(1);
if ( (LA41_0==HamThumb) ) {
alt41=1;
}
else if ( ((LA41_0>=HamIndexfinger && LA41_0<=HamPinky)) ) {
alt41=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);
throw nvae;
}
switch (alt41) {
case 1 :
// Ham4HMLGen.g:568:9: fi= thumb
this.pushFollow(Ham4HMLGen.FOLLOW_thumb_in_digit3823);
fi=this.thumb();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:569:9: fi= finger
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_digit3837);
fi=this.finger();
this.state._fsp--;
break;
}
rd = hBuilder.newHMLElement("finger");
rd.setAttribute("fingerid", fi.getAttribute("fingerid"));
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rd;
},
// Ham4HMLGen.g:577:1: fingerlist returns [Element[] rfngl = null] : ^( FINGERLIST (fng= hsfingeritem )* ) ;
// $ANTLR start "fingerlist"
fingerlist: function() {
var rfngl =  null;
var fng = null;
var      al  = [];
try {
// Ham4HMLGen.g:583:5: ( ^( FINGERLIST (fng= hsfingeritem )* ) )
// Ham4HMLGen.g:584:5: ^( FINGERLIST (fng= hsfingeritem )* )
this.match(this.input,FINGERLIST,Ham4HMLGen.FOLLOW_FINGERLIST_in_fingerlist3886); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:585:9: (fng= hsfingeritem )*
loop42:
do {
var alt42=2;
var LA42_0 = this.input.LA(1);
if ( (LA42_0==HSFINGERITEM) ) {
alt42=1;
}
switch (alt42) {
case 1 :
// Ham4HMLGen.g:585:11: fng= hsfingeritem
this.pushFollow(Ham4HMLGen.FOLLOW_hsfingeritem_in_fingerlist3902);
fng=this.hsfingeritem();
this.state._fsp--;
al.push(fng); 
break;
default :
break loop42;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfngl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngl;
},
// Ham4HMLGen.g:592:1: fingershapelist returns [Element[] rfsl = null] : ^( FISHPLIST (fs= fingershape )* ) ;
// $ANTLR start "fingershapelist"
fingershapelist: function() {
var rfsl =  null;
var fs = null;
var    al  = [];
try {
// Ham4HMLGen.g:598:5: ( ^( FISHPLIST (fs= fingershape )* ) )
// Ham4HMLGen.g:599:5: ^( FISHPLIST (fs= fingershape )* )
this.match(this.input,FISHPLIST,Ham4HMLGen.FOLLOW_FISHPLIST_in_fingershapelist3966); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:600:9: (fs= fingershape )*
loop43:
do {
var alt43=2;
var LA43_0 = this.input.LA(1);
if ( (LA43_0==FSHAPE) ) {
alt43=1;
}
switch (alt43) {
case 1 :
// Ham4HMLGen.g:600:11: fs= fingershape
this.pushFollow(Ham4HMLGen.FOLLOW_fingershape_in_fingershapelist3982);
fs=this.fingershape();
this.state._fsp--;
al.push(fs); 
break;
default :
break loop43;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfsl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfsl;
},
// Ham4HMLGen.g:607:1: fingercrossinglist returns [Element[] rfcl = null] : ^( FICRSSLIST (fc= fingercrossing )* ) ;
// $ANTLR start "fingercrossinglist"
fingercrossinglist: function() {
var rfcl =  null;
var fc = null;
var    al  = [];
try {
// Ham4HMLGen.g:613:5: ( ^( FICRSSLIST (fc= fingercrossing )* ) )
// Ham4HMLGen.g:614:5: ^( FICRSSLIST (fc= fingercrossing )* )
this.match(this.input,FICRSSLIST,Ham4HMLGen.FOLLOW_FICRSSLIST_in_fingercrossinglist4045); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:615:9: (fc= fingercrossing )*
loop44:
do {
var alt44=2;
var LA44_0 = this.input.LA(1);
if ( (LA44_0==FCROSSING) ) {
alt44=1;
}
switch (alt44) {
case 1 :
// Ham4HMLGen.g:615:11: fc= fingercrossing
this.pushFollow(Ham4HMLGen.FOLLOW_fingercrossing_in_fingercrossinglist4061);
fc=this.fingercrossing();
this.state._fsp--;
al.push(fc); 
break;
default :
break loop44;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfcl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfcl;
},
// Ham4HMLGen.g:622:1: fingershape returns [Element rfs = null] : ^( FSHAPE d= digit fb= fingerbending ) ;
// $ANTLR start "fingershape"
fingershape: function() {
var rfs =  null;
var d = null;
var fb = null;
try {
// Ham4HMLGen.g:625:5: ( ^( FSHAPE d= digit fb= fingerbending ) )
// Ham4HMLGen.g:626:5: ^( FSHAPE d= digit fb= fingerbending )
this.match(this.input,FSHAPE,Ham4HMLGen.FOLLOW_FSHAPE_in_fingershape4116); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingershape4131);
d=this.digit();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_fingershape4145);
fb=this.fingerbending();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rfs = hBuilder.newHMLElement("fingershape");
rfs.appendChild(d);
rfs.setAttribute("fingerbending", fb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfs;
},
// Ham4HMLGen.g:637:1: fingercrossing returns [Element rfc = null] : ^( FCROSSING d0= digit fip= fingerpart d1= digit ) ;
// $ANTLR start "fingercrossing"
fingercrossing: function() {
var rfc =  null;
var d0 = null;
var fip = null;
var d1 = null;
try {
// Ham4HMLGen.g:640:5: ( ^( FCROSSING d0= digit fip= fingerpart d1= digit ) )
// Ham4HMLGen.g:641:5: ^( FCROSSING d0= digit fip= fingerpart d1= digit )
this.match(this.input,FCROSSING,Ham4HMLGen.FOLLOW_FCROSSING_in_fingercrossing4186); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingercrossing4200);
d0=this.digit();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_fingercrossing4214);
fip=this.fingerpart();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingercrossing4228);
d1=this.digit();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rfc = hBuilder.newHMLElement("fingercrossing");
rfc.appendChild(d0);
rfc.appendChild(fip);
rfc.appendChild(d1);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfc;
},
// Ham4HMLGen.g:654:1: thumbspecial returns [Element rts = null] : ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) ) ;
// $ANTLR start "thumbspecial"
thumbspecial: function() {
var rts =  null;
var fng0 = null;
var fng1 = null;
var th = null;
var fp = null;
rts = hBuilder.newHMLElement("thumbspecial");
try {
// Ham4HMLGen.g:660:5: ( ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) ) )
// Ham4HMLGen.g:661:5: ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) )
this.match(this.input,THSPECIAL,Ham4HMLGen.FOLLOW_THSPECIAL_in_thumbspecial4274); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:662:9: ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart )
var alt46=3;
switch ( this.input.LA(1) ) {
case HamBetween:
alt46=1;
break;
case HamThumb:
alt46=2;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt46=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 46, 0, this.input);
throw nvae;
}
switch (alt46) {
case 1 :
// Ham4HMLGen.g:662:13: ^( HamBetween (fng0= finger fng1= finger )? )
this.match(this.input,HamBetween,Ham4HMLGen.FOLLOW_HamBetween_in_thumbspecial4289); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:663:17: (fng0= finger fng1= finger )?
var alt45=2;
var LA45_0 = this.input.LA(1);
if ( ((LA45_0>=HamIndexfinger && LA45_0<=HamPinky)) ) {
alt45=1;
}
switch (alt45) {
case 1 :
// Ham4HMLGen.g:663:21: fng0= finger fng1= finger
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_thumbspecial4315);
fng0=this.finger();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_thumbspecial4341);
fng1=this.finger();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
if (fng0 == null) {
var btwn = hBuilder.newHMLElement("hambetween");
rts.appendChild(btwn);
}
else {
rts.appendChild(fng0);
rts.appendChild(fng1);
}
break;
case 2 :
// Ham4HMLGen.g:677:13: th= thumb
this.pushFollow(Ham4HMLGen.FOLLOW_thumb_in_thumbspecial4406);
th=this.thumb();
this.state._fsp--;
rts.appendChild(th); 
break;
case 3 :
// Ham4HMLGen.g:678:13: fp= fingerpart
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_thumbspecial4439);
fp=this.fingerpart();
this.state._fsp--;
rts.appendChild(fp); 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rts;
},
// Ham4HMLGen.g:683:1: fingerpart returns [Element rfp = null] : ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside ) ;
// $ANTLR start "fingerpart"
fingerpart: function() {
var rfp =  null;
var  fp = null;
try {
// Ham4HMLGen.g:689:5: ( ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside ) )
// Ham4HMLGen.g:690:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
// Ham4HMLGen.g:690:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
var alt47=6;
switch ( this.input.LA(1) ) {
case HamFingertip:
alt47=1;
break;
case HamFingernail:
alt47=2;
break;
case HamFingerpad:
alt47=3;
break;
case HamFingermidjoint:
alt47=4;
break;
case HamFingerbase:
alt47=5;
break;
case HamFingerside:
alt47=6;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 47, 0, this.input);
throw nvae;
}
switch (alt47) {
case 1 :
// Ham4HMLGen.g:690:9: HamFingertip
this.match(this.input,HamFingertip,Ham4HMLGen.FOLLOW_HamFingertip_in_fingerpart4505); 
fp = "ham_finger_tip"; 
break;
case 2 :
// Ham4HMLGen.g:691:9: HamFingernail
this.match(this.input,HamFingernail,Ham4HMLGen.FOLLOW_HamFingernail_in_fingerpart4528); 
fp = "ham_finger_nail"; 
break;
case 3 :
// Ham4HMLGen.g:692:9: HamFingerpad
this.match(this.input,HamFingerpad,Ham4HMLGen.FOLLOW_HamFingerpad_in_fingerpart4550); 
fp = "ham_finger_pad"; 
break;
case 4 :
// Ham4HMLGen.g:693:9: HamFingermidjoint
this.match(this.input,HamFingermidjoint,Ham4HMLGen.FOLLOW_HamFingermidjoint_in_fingerpart4573); 
fp = "ham_finger_midjoint"; 
break;
case 5 :
// Ham4HMLGen.g:694:9: HamFingerbase
this.match(this.input,HamFingerbase,Ham4HMLGen.FOLLOW_HamFingerbase_in_fingerpart4591); 
fp = "ham_finger_base"; 
break;
case 6 :
// Ham4HMLGen.g:695:9: HamFingerside
this.match(this.input,HamFingerside,Ham4HMLGen.FOLLOW_HamFingerside_in_fingerpart4613); 
fp = "ham_finger_side"; 
break;
}
rfp = hBuilder.newHMLElement("fingerpart");
rfp.setAttribute("fingerpart", fp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfp;
},
// Ham4HMLGen.g:706:1: extfidir2 returns [Element refd = null] : ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? ) ;
// $ANTLR start "extfidir2"
extfidir2: function() {
var refd =  null;
var da = null;
var db = null;
try {
// Ham4HMLGen.g:709:5: ( ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? ) )
// Ham4HMLGen.g:710:5: ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? )
this.match(this.input,EXTFIDIR2,Ham4HMLGen.FOLLOW_EXTFIDIR2_in_extfidir24674); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_extfidir24693);
da=this.extfidir1();
this.state._fsp--;
// Ham4HMLGen.g:712:9: (db= extfidir1 )?
var alt48=2;
var LA48_0 = this.input.LA(1);
if ( (LA48_0==EXTFIDIR1) ) {
alt48=1;
}
switch (alt48) {
case 1 :
// Ham4HMLGen.g:712:11: db= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_extfidir24712);
db=this.extfidir1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd = hBuilder.newHMLElement("extfidir2");
refd.appendChild(da);
hBuilder.checkedAppendChild(refd, db);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd;
},
// Ham4HMLGen.g:721:1: extfidir1 returns [Element refd1 = null] : ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? ) ;
// $ANTLR start "extfidir1"
extfidir1: function() {
var refd1 =  null;
var efda = null;
var efdb = null;
var orirel = false;
try {
// Ham4HMLGen.g:727:5: ( ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? ) )
// Ham4HMLGen.g:728:5: ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? )
this.match(this.input,EXTFIDIR1,Ham4HMLGen.FOLLOW_EXTFIDIR1_in_extfidir14765); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir_in_extfidir14782);
efda=this.extfidir();
this.state._fsp--;
// Ham4HMLGen.g:730:9: (efdb= extfidir )?
var alt49=2;
var LA49_0 = this.input.LA(1);
if ( (LA49_0==EXTFIDIR) ) {
alt49=1;
}
switch (alt49) {
case 1 :
// Ham4HMLGen.g:730:11: efdb= extfidir
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir_in_extfidir14799);
efdb=this.extfidir();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:731:9: ( HamOrirelative )?
var alt50=2;
var LA50_0 = this.input.LA(1);
if ( (LA50_0==HamOrirelative) ) {
alt50=1;
}
switch (alt50) {
case 1 :
// Ham4HMLGen.g:731:19: HamOrirelative
this.match(this.input,HamOrirelative,Ham4HMLGen.FOLLOW_HamOrirelative_in_extfidir14822); 
orirel = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd1 = hBuilder.newHMLElement("extfidir1");
refd1.setAttribute("extfidir", efda);
hBuilder.checkedSetAttr(refd1, "second_extfidir", efdb);
hBuilder.checkedSetFlagAttr(refd1, "rel_extfidir", orirel);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd1;
},
// Ham4HMLGen.g:741:1: extfidir returns [String refd = null] : ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) ) ;
// $ANTLR start "extfidir"
extfidir: function() {
var refd =  null;
var dir = null;
try {
// Ham4HMLGen.g:748:5: ( ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) ) )
// Ham4HMLGen.g:749:5: ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) )
this.match(this.input,EXTFIDIR,Ham4HMLGen.FOLLOW_EXTFIDIR_in_extfidir4885); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:750:9: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) )
var alt59=18;
switch ( this.input.LA(1) ) {
case HamExtfingeru:
alt59=1;
break;
case HamExtfingerur:
alt59=2;
break;
case HamExtfingerr:
alt59=3;
break;
case HamExtfingerdr:
alt59=4;
break;
case HamExtfingerd:
alt59=5;
break;
case HamExtfingerdl:
alt59=6;
break;
case HamExtfingerl:
alt59=7;
break;
case HamExtfingerul:
alt59=8;
break;
case HamExtfingerol:
alt59=9;
break;
case HamExtfingero:
alt59=10;
break;
case HamExtfingeror:
alt59=11;
break;
case HamExtfingeril:
alt59=12;
break;
case HamExtfingeri:
alt59=13;
break;
case HamExtfingerir:
alt59=14;
break;
case HamExtfingeruo:
alt59=15;
break;
case HamExtfingerdo:
alt59=16;
break;
case HamExtfingerui:
alt59=17;
break;
case HamExtfingerdi:
alt59=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 59, 0, this.input);
throw nvae;
}
switch (alt59) {
case 1 :
// Ham4HMLGen.g:752:13: HamExtfingeru
this.match(this.input,HamExtfingeru,Ham4HMLGen.FOLLOW_HamExtfingeru_in_extfidir4919); 
dir = "u"; 
break;
case 2 :
// Ham4HMLGen.g:753:13: HamExtfingerur
this.match(this.input,HamExtfingerur,Ham4HMLGen.FOLLOW_HamExtfingerur_in_extfidir4949); 
dir = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:754:13: HamExtfingerr
this.match(this.input,HamExtfingerr,Ham4HMLGen.FOLLOW_HamExtfingerr_in_extfidir4978); 
dir = "r"; 
break;
case 4 :
// Ham4HMLGen.g:755:13: HamExtfingerdr
this.match(this.input,HamExtfingerdr,Ham4HMLGen.FOLLOW_HamExtfingerdr_in_extfidir5008); 
dir = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:756:13: HamExtfingerd
this.match(this.input,HamExtfingerd,Ham4HMLGen.FOLLOW_HamExtfingerd_in_extfidir5037); 
dir = "d"; 
break;
case 6 :
// Ham4HMLGen.g:757:13: HamExtfingerdl
this.match(this.input,HamExtfingerdl,Ham4HMLGen.FOLLOW_HamExtfingerdl_in_extfidir5067); 
dir = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:758:13: HamExtfingerl
this.match(this.input,HamExtfingerl,Ham4HMLGen.FOLLOW_HamExtfingerl_in_extfidir5096); 
dir = "l"; 
break;
case 8 :
// Ham4HMLGen.g:759:13: HamExtfingerul
this.match(this.input,HamExtfingerul,Ham4HMLGen.FOLLOW_HamExtfingerul_in_extfidir5126); 
dir = "ul"; 
break;
case 9 :
// Ham4HMLGen.g:761:13: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:761:13: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:762:17: HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )?
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir5183); 
dir = "ol"; 
// Ham4HMLGen.g:763:17: ( HamExtfingeruo | HamExtfingerdo )?
var alt51=3;
var LA51_0 = this.input.LA(1);
if ( (LA51_0==HamExtfingeruo) ) {
alt51=1;
}
else if ( (LA51_0==HamExtfingerdo) ) {
alt51=2;
}
switch (alt51) {
case 1 :
// Ham4HMLGen.g:764:21: HamExtfingeruo
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5234); 
dir = "uol"; 
break;
case 2 :
// Ham4HMLGen.g:765:21: HamExtfingerdo
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir5263); 
dir = "dol"; 
break;
}
break;
case 10 :
// Ham4HMLGen.g:768:13: HamExtfingero
this.match(this.input,HamExtfingero,Ham4HMLGen.FOLLOW_HamExtfingero_in_extfidir5317); 
dir = "o"; 
break;
case 11 :
// Ham4HMLGen.g:769:13: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:769:13: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:770:17: HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )?
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir5365); 
dir = "or"; 
// Ham4HMLGen.g:771:17: ( HamExtfingeruo | HamExtfingerdo )?
var alt52=3;
var LA52_0 = this.input.LA(1);
if ( (LA52_0==HamExtfingeruo) ) {
alt52=1;
}
else if ( (LA52_0==HamExtfingerdo) ) {
alt52=2;
}
switch (alt52) {
case 1 :
// Ham4HMLGen.g:772:21: HamExtfingeruo
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5416); 
dir = "uor"; 
break;
case 2 :
// Ham4HMLGen.g:773:21: HamExtfingerdo
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir5445); 
dir = "dor"; 
break;
}
break;
case 12 :
// Ham4HMLGen.g:776:13: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:776:13: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:777:17: HamExtfingeril ( HamExtfingerui | HamExtfingerdi )?
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir5517); 
dir = "il"; 
// Ham4HMLGen.g:778:17: ( HamExtfingerui | HamExtfingerdi )?
var alt53=3;
var LA53_0 = this.input.LA(1);
if ( (LA53_0==HamExtfingerui) ) {
alt53=1;
}
else if ( (LA53_0==HamExtfingerdi) ) {
alt53=2;
}
switch (alt53) {
case 1 :
// Ham4HMLGen.g:779:21: HamExtfingerui
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir5568); 
dir = "uil"; 
break;
case 2 :
// Ham4HMLGen.g:780:21: HamExtfingerdi
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir5597); 
dir = "dil"; 
break;
}
break;
case 13 :
// Ham4HMLGen.g:783:13: HamExtfingeri
this.match(this.input,HamExtfingeri,Ham4HMLGen.FOLLOW_HamExtfingeri_in_extfidir5651); 
dir = "i"; 
break;
case 14 :
// Ham4HMLGen.g:784:13: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:784:13: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:785:17: HamExtfingerir ( HamExtfingerui | HamExtfingerdi )?
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir5699); 
dir = "ir"; 
// Ham4HMLGen.g:786:17: ( HamExtfingerui | HamExtfingerdi )?
var alt54=3;
var LA54_0 = this.input.LA(1);
if ( (LA54_0==HamExtfingerui) ) {
alt54=1;
}
else if ( (LA54_0==HamExtfingerdi) ) {
alt54=2;
}
switch (alt54) {
case 1 :
// Ham4HMLGen.g:787:21: HamExtfingerui
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir5750); 
dir = "uir"; 
break;
case 2 :
// Ham4HMLGen.g:788:21: HamExtfingerdi
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir5779); 
dir = "dir"; 
break;
}
break;
case 15 :
// Ham4HMLGen.g:792:13: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:792:13: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:793:17: HamExtfingeruo ( HamExtfingerol | HamExtfingeror )?
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5861); 
dir = "uo"; 
// Ham4HMLGen.g:794:17: ( HamExtfingerol | HamExtfingeror )?
var alt55=3;
var LA55_0 = this.input.LA(1);
if ( (LA55_0==HamExtfingerol) ) {
alt55=1;
}
else if ( (LA55_0==HamExtfingeror) ) {
alt55=2;
}
switch (alt55) {
case 1 :
// Ham4HMLGen.g:795:21: HamExtfingerol
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir5912); 
dir = "uol"; 
break;
case 2 :
// Ham4HMLGen.g:796:21: HamExtfingeror
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir5941); 
dir = "uor"; 
break;
}
break;
case 16 :
// Ham4HMLGen.g:799:13: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:799:13: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:800:17: HamExtfingerdo ( HamExtfingerol | HamExtfingeror )?
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir6013); 
dir = "do"; 
// Ham4HMLGen.g:801:17: ( HamExtfingerol | HamExtfingeror )?
var alt56=3;
var LA56_0 = this.input.LA(1);
if ( (LA56_0==HamExtfingerol) ) {
alt56=1;
}
else if ( (LA56_0==HamExtfingeror) ) {
alt56=2;
}
switch (alt56) {
case 1 :
// Ham4HMLGen.g:802:21: HamExtfingerol
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir6064); 
dir = "dol"; 
break;
case 2 :
// Ham4HMLGen.g:803:21: HamExtfingeror
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir6093); 
dir = "dor"; 
break;
}
break;
case 17 :
// Ham4HMLGen.g:806:13: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:806:13: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:807:17: HamExtfingerui ( HamExtfingeril | HamExtfingerir )?
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir6165); 
dir = "ui"; 
// Ham4HMLGen.g:808:17: ( HamExtfingeril | HamExtfingerir )?
var alt57=3;
var LA57_0 = this.input.LA(1);
if ( (LA57_0==HamExtfingeril) ) {
alt57=1;
}
else if ( (LA57_0==HamExtfingerir) ) {
alt57=2;
}
switch (alt57) {
case 1 :
// Ham4HMLGen.g:809:21: HamExtfingeril
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir6216); 
dir = "uil"; 
break;
case 2 :
// Ham4HMLGen.g:810:21: HamExtfingerir
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir6245); 
dir = "uir"; 
break;
}
break;
case 18 :
// Ham4HMLGen.g:813:13: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:813:13: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:814:17: HamExtfingerdi ( HamExtfingeril | HamExtfingerir )?
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir6317); 
dir = "di"; 
// Ham4HMLGen.g:815:17: ( HamExtfingeril | HamExtfingerir )?
var alt58=3;
var LA58_0 = this.input.LA(1);
if ( (LA58_0==HamExtfingeril) ) {
alt58=1;
}
else if ( (LA58_0==HamExtfingerir) ) {
alt58=2;
}
switch (alt58) {
case 1 :
// Ham4HMLGen.g:816:21: HamExtfingeril
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir6368); 
dir = "dil"; 
break;
case 2 :
// Ham4HMLGen.g:817:21: HamExtfingerir
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir6397); 
dir = "dir"; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd = "direction_" + dir;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd;
},
// Ham4HMLGen.g:830:1: palmor2 returns [Element rpo = null] : ^( PALMOR2 poa= palmor1 (pob= palmor1 )? ) ;
// $ANTLR start "palmor2"
palmor2: function() {
var rpo =  null;
var poa = null;
var pob = null;
try {
// Ham4HMLGen.g:833:5: ( ^( PALMOR2 poa= palmor1 (pob= palmor1 )? ) )
// Ham4HMLGen.g:834:5: ^( PALMOR2 poa= palmor1 (pob= palmor1 )? )
this.match(this.input,PALMOR2,Ham4HMLGen.FOLLOW_PALMOR2_in_palmor26498); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_palmor26516);
poa=this.palmor1();
this.state._fsp--;
// Ham4HMLGen.g:836:9: (pob= palmor1 )?
var alt60=2;
var LA60_0 = this.input.LA(1);
if ( (LA60_0==PALMOR1) ) {
alt60=1;
}
switch (alt60) {
case 1 :
// Ham4HMLGen.g:836:11: pob= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_palmor26534);
pob=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpo = hBuilder.newHMLElement("palmor2");
rpo.appendChild(poa);
hBuilder.checkedAppendChild(rpo, pob);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo;
},
// Ham4HMLGen.g:845:1: palmor1 returns [Element rpo1 = null] : ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? ) ;
// $ANTLR start "palmor1"
palmor1: function() {
var rpo1 =  null;
var poa = null;
var pob = null;
var approxpo = false;
var orirel = false;
try {
// Ham4HMLGen.g:852:5: ( ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? ) )
// Ham4HMLGen.g:853:5: ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? )
this.match(this.input,PALMOR1,Ham4HMLGen.FOLLOW_PALMOR1_in_palmor16589); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor_in_palmor16607);
poa=this.palmor();
this.state._fsp--;
// Ham4HMLGen.g:855:9: (pob= palmor | HamEtc )?
var alt61=3;
var LA61_0 = this.input.LA(1);
if ( ((LA61_0>=HamPalmu && LA61_0<=HamPalmul)) ) {
alt61=1;
}
else if ( (LA61_0==HamEtc) ) {
alt61=2;
}
switch (alt61) {
case 1 :
// Ham4HMLGen.g:856:13: pob= palmor
this.pushFollow(Ham4HMLGen.FOLLOW_palmor_in_palmor16635);
pob=this.palmor();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:858:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_palmor16665); 
approxpo = true; 
break;
}
// Ham4HMLGen.g:860:9: ( HamOrirelative )?
var alt62=2;
var LA62_0 = this.input.LA(1);
if ( (LA62_0==HamOrirelative) ) {
alt62=1;
}
switch (alt62) {
case 1 :
// Ham4HMLGen.g:860:19: HamOrirelative
this.match(this.input,HamOrirelative,Ham4HMLGen.FOLLOW_HamOrirelative_in_palmor16707); 
orirel = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpo1 = hBuilder.newHMLElement("palmor1");
rpo1.setAttribute("palmor", poa);
hBuilder.checkedSetAttr(rpo1, "second_palmor", pob);
hBuilder.checkedSetFlagAttr(rpo1, "approx_palmor", approxpo);
hBuilder.checkedSetFlagAttr(rpo1, "rel_palmor", orirel);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo1;
},
// Ham4HMLGen.g:872:1: palmor returns [String rpo = null] : ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul ) ;
// $ANTLR start "palmor"
palmor: function() {
var rpo =  null;
var  dir = null;
try {
// Ham4HMLGen.g:879:5: ( ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul ) )
// Ham4HMLGen.g:880:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
// Ham4HMLGen.g:880:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
var alt63=8;
switch ( this.input.LA(1) ) {
case HamPalmu:
alt63=1;
break;
case HamPalmur:
alt63=2;
break;
case HamPalmr:
alt63=3;
break;
case HamPalmdr:
alt63=4;
break;
case HamPalmd:
alt63=5;
break;
case HamPalmdl:
alt63=6;
break;
case HamPalml:
alt63=7;
break;
case HamPalmul:
alt63=8;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 63, 0, this.input);
throw nvae;
}
switch (alt63) {
case 1 :
// Ham4HMLGen.g:880:9: HamPalmu
this.match(this.input,HamPalmu,Ham4HMLGen.FOLLOW_HamPalmu_in_palmor6776); 
dir = "u"; 
break;
case 2 :
// Ham4HMLGen.g:881:9: HamPalmur
this.match(this.input,HamPalmur,Ham4HMLGen.FOLLOW_HamPalmur_in_palmor6799); 
dir = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:882:9: HamPalmr
this.match(this.input,HamPalmr,Ham4HMLGen.FOLLOW_HamPalmr_in_palmor6821); 
dir = "r"; 
break;
case 4 :
// Ham4HMLGen.g:883:9: HamPalmdr
this.match(this.input,HamPalmdr,Ham4HMLGen.FOLLOW_HamPalmdr_in_palmor6844); 
dir = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:884:9: HamPalmd
this.match(this.input,HamPalmd,Ham4HMLGen.FOLLOW_HamPalmd_in_palmor6866); 
dir = "d"; 
break;
case 6 :
// Ham4HMLGen.g:885:9: HamPalmdl
this.match(this.input,HamPalmdl,Ham4HMLGen.FOLLOW_HamPalmdl_in_palmor6889); 
dir = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:886:9: HamPalml
this.match(this.input,HamPalml,Ham4HMLGen.FOLLOW_HamPalml_in_palmor6911); 
dir = "l"; 
break;
case 8 :
// Ham4HMLGen.g:887:9: HamPalmul
this.match(this.input,HamPalmul,Ham4HMLGen.FOLLOW_HamPalmul_in_palmor6934); 
dir = "ul"; 
break;
}
rpo = "ham_palm_" + dir;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo;
},
// Ham4HMLGen.g:897:1: location2 returns [Element rloc = null] : ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) ) ;
// $ANTLR start "location2"
location2: function() {
var rloc =  null;
var lc1 = null;
var lc1x = null;
var hc = null;
var lb = null;
var  ext = null;
try {
// Ham4HMLGen.g:903:5: ( ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) ) )
// Ham4HMLGen.g:904:5: ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) )
this.match(this.input,LOC2,Ham4HMLGen.FOLLOW_LOC2_in_location26999); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:905:9: (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? )
var alt66=2;
var LA66_0 = this.input.LA(1);
if ( (LA66_0==LOC1) ) {
alt66=1;
}
else if ( (LA66_0==HCONSTLLN) ) {
alt66=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 66, 0, this.input);
throw nvae;
}
switch (alt66) {
case 1 :
// Ham4HMLGen.g:906:13: lc1= location1 (lc1x= location1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_location27031);
lc1=this.location1();
this.state._fsp--;
// Ham4HMLGen.g:907:13: (lc1x= location1 )?
var alt64=2;
var LA64_0 = this.input.LA(1);
if ( (LA64_0==LOC1) ) {
alt64=1;
}
switch (alt64) {
case 1 :
// Ham4HMLGen.g:907:15: lc1x= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_location27052);
lc1x=this.location1();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:909:13: hc= handconstellation ( HamArmextended | lb= locationbody )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconstellation_in_location27088);
hc=this.handconstellation();
this.state._fsp--;
// Ham4HMLGen.g:910:13: ( HamArmextended | lb= locationbody )?
var alt65=3;
var LA65_0 = this.input.LA(1);
if ( (LA65_0==HamArmextended) ) {
alt65=1;
}
else if ( (LA65_0==LOCTNBODY) ) {
alt65=2;
}
switch (alt65) {
case 1 :
// Ham4HMLGen.g:911:23: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_location27126); 
ext = "true"; 
break;
case 2 :
// Ham4HMLGen.g:913:17: lb= locationbody
this.pushFollow(Ham4HMLGen.FOLLOW_locationbody_in_location27172);
lb=this.locationbody();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rloc = hBuilder.newHMLElement("location2");
if (lc1 != null) {
rloc.appendChild(lc1);
hBuilder.checkedAppendChild(rloc, lc1x);
}
else {
rloc.appendChild(hc);
if (lb != null) {
rloc.appendChild(lb);
}
else if (ext != null) {
var neut = hBuilder.newHMLElement("hamneutral");
hBuilder.checkedSetAttr(neut, "armextended", ext);
rloc.appendChild(neut);
}
/* else nothing */
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rloc;
},
// Ham4HMLGen.g:938:1: location1 returns [Element rloc = null] : ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) ) ;
// $ANTLR start "location1"
location1: function() {
var rloc =  null;
var dig = null;
var loc = null;
try {
// Ham4HMLGen.g:941:5: ( ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) ) )
// Ham4HMLGen.g:942:5: ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) )
this.match(this.input,LOC1,Ham4HMLGen.FOLLOW_LOC1_in_location17243); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:943:9: (dig= digit | loc= locationhand | loc= locationbodyarm )
var alt67=3;
switch ( this.input.LA(1) ) {
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt67=1;
break;
case LOCTNHAND:
alt67=2;
break;
case LOCTNBODYARM:
alt67=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 67, 0, this.input);
throw nvae;
}
switch (alt67) {
case 1 :
// Ham4HMLGen.g:944:13: dig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_location17271);
dig=this.digit();
this.state._fsp--;
var dstr = dig.getAttribute("fingerid");
var ipos = "ham_digit_".length();
var locstr = "loc" + dstr.substring(ipos);
loc = hBuilder.newHMLElement("use_locname");
loc.setAttribute("use_locname", locstr);
break;
case 2 :
// Ham4HMLGen.g:953:13: loc= locationhand
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_location17313);
loc=this.locationhand();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:955:13: loc= locationbodyarm
this.pushFollow(Ham4HMLGen.FOLLOW_locationbodyarm_in_location17341);
loc=this.locationbodyarm();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rloc = hBuilder.newHMLElement("location1");
rloc.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rloc;
},
// Ham4HMLGen.g:965:1: locationbodyarm returns [Element rlba = null] : ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) ) ;
// $ANTLR start "locationbodyarm"
locationbodyarm: function() {
var rlba =  null;
var loc = null;
var  ext = null;
try {
// Ham4HMLGen.g:971:5: ( ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) ) )
// Ham4HMLGen.g:972:5: ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) )
this.match(this.input,LOCTNBODYARM,Ham4HMLGen.FOLLOW_LOCTNBODYARM_in_locationbodyarm7395); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:973:9: (loc= locationbody | loc= locationarm | ( HamArmextended )? )
var alt69=3;
switch ( this.input.LA(1) ) {
case LOCTNBODY:
alt69=1;
break;
case LOCTNARM:
alt69=2;
break;
case UP:
case HamArmextended:
alt69=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 69, 0, this.input);
throw nvae;
}
switch (alt69) {
case 1 :
// Ham4HMLGen.g:974:13: loc= locationbody
this.pushFollow(Ham4HMLGen.FOLLOW_locationbody_in_locationbodyarm7423);
loc=this.locationbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:976:13: loc= locationarm
this.pushFollow(Ham4HMLGen.FOLLOW_locationarm_in_locationbodyarm7451);
loc=this.locationarm();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:978:13: ( HamArmextended )?
// Ham4HMLGen.g:978:13: ( HamArmextended )?
var alt68=2;
var LA68_0 = this.input.LA(1);
if ( (LA68_0==HamArmextended) ) {
alt68=1;
}
switch (alt68) {
case 1 :
// Ham4HMLGen.g:978:15: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_locationbodyarm7477); 
ext = "true"; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
if (loc == null) {
loc =  hBuilder.newHMLElement("hamneutral");
hBuilder.checkedSetAttr(loc, "armextended", ext);
}
rlba = hBuilder.newHMLElement("locationbodyarm");
rlba.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlba;
},
// Ham4HMLGen.g:991:1: locationbody returns [Element rlb = null] : ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? ) ;
// $ANTLR start "locationbody"
locationbody: function() {
var rlb =  null;
var lcb = null;
var cb = null;
var hb  = null;
try {
// Ham4HMLGen.g:997:5: ( ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? ) )
// Ham4HMLGen.g:998:5: ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? )
this.match(this.input,LOCTNBODY,Ham4HMLGen.FOLLOW_LOCTNBODY_in_locationbody7546); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexbody_in_locationbody7564);
lcb=this.levelcomplexbody();
this.state._fsp--;
// Ham4HMLGen.g:1000:9: ( HamBehind )?
var alt70=2;
var LA70_0 = this.input.LA(1);
if ( (LA70_0==HamBehind) ) {
alt70=1;
}
switch (alt70) {
case 1 :
// Ham4HMLGen.g:1000:19: HamBehind
this.match(this.input,HamBehind,Ham4HMLGen.FOLLOW_HamBehind_in_locationbody7584); 
hb = hBuilder.newHMLElement("hambehind"); 
break;
}
// Ham4HMLGen.g:1003:9: (cb= contactbody )?
var alt71=2;
var LA71_0 = this.input.LA(1);
if ( (LA71_0==CNTCTBODY) ) {
alt71=1;
}
switch (alt71) {
case 1 :
// Ham4HMLGen.g:1003:11: cb= contactbody
this.pushFollow(Ham4HMLGen.FOLLOW_contactbody_in_locationbody7640);
cb=this.contactbody();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlb = hBuilder.newHMLElement("locationbody");
rlb.appendChild(lcb);
hBuilder.checkedAppendChild(rlb, hb);
hBuilder.checkedAppendChild(rlb, cb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1013:1: locationhand returns [Element rlh = null] : ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? ) ;
// $ANTLR start "locationhand"
locationhand: function() {
var rlh =  null;
var lch = null;
var ch = null;
try {
// Ham4HMLGen.g:1016:5: ( ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? ) )
// Ham4HMLGen.g:1017:5: ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? )
this.match(this.input,LOCTNHAND,Ham4HMLGen.FOLLOW_LOCTNHAND_in_locationhand7686); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexhand_in_locationhand7704);
lch=this.levelcomplexhand();
this.state._fsp--;
// Ham4HMLGen.g:1019:9: (ch= contacthand )?
var alt72=2;
var LA72_0 = this.input.LA(1);
if ( (LA72_0==CNTCTHAND) ) {
alt72=1;
}
switch (alt72) {
case 1 :
// Ham4HMLGen.g:1019:11: ch= contacthand
this.pushFollow(Ham4HMLGen.FOLLOW_contacthand_in_locationhand7723);
ch=this.contacthand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlh = hBuilder.newHMLElement("locationhand");
rlh.appendChild(lch);
hBuilder.checkedAppendChild(rlh, ch);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlh;
},
// Ham4HMLGen.g:1028:1: locationarm returns [Element rla = null] : ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? ) ;
// $ANTLR start "locationarm"
locationarm: function() {
var rla =  null;
var lca = null;
var cb = null;
var hb  = null;
try {
// Ham4HMLGen.g:1034:5: ( ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? ) )
// Ham4HMLGen.g:1035:5: ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? )
this.match(this.input,LOCTNARM,Ham4HMLGen.FOLLOW_LOCTNARM_in_locationarm7774); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexarm_in_locationarm7792);
lca=this.levelcomplexarm();
this.state._fsp--;
// Ham4HMLGen.g:1037:9: ( HamBehind )?
var alt73=2;
var LA73_0 = this.input.LA(1);
if ( (LA73_0==HamBehind) ) {
alt73=1;
}
switch (alt73) {
case 1 :
// Ham4HMLGen.g:1037:19: HamBehind
this.match(this.input,HamBehind,Ham4HMLGen.FOLLOW_HamBehind_in_locationarm7812); 
hb = hBuilder.newHMLElement("hambehind"); 
break;
}
// Ham4HMLGen.g:1040:9: (cb= contactbody )?
var alt74=2;
var LA74_0 = this.input.LA(1);
if ( (LA74_0==CNTCTBODY) ) {
alt74=1;
}
switch (alt74) {
case 1 :
// Ham4HMLGen.g:1040:11: cb= contactbody
this.pushFollow(Ham4HMLGen.FOLLOW_contactbody_in_locationarm7868);
cb=this.contactbody();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rla = hBuilder.newHMLElement("locationarm");
rla.appendChild(lca);
hBuilder.checkedAppendChild(rla, hb);
hBuilder.checkedAppendChild(rla, cb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1050:1: levelcomplexbody returns [Element rlcb = null] : lba= levelbody (lbb= levelbody )? ;
// $ANTLR start "levelcomplexbody"
levelcomplexbody: function() {
var rlcb =  null;
var lba = null;
var lbb = null;
try {
// Ham4HMLGen.g:1053:5: (lba= levelbody (lbb= levelbody )? )
// Ham4HMLGen.g:1053:9: lba= levelbody (lbb= levelbody )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_levelcomplexbody7919);
lba=this.levelbody();
this.state._fsp--;
// Ham4HMLGen.g:1054:9: (lbb= levelbody )?
var alt75=2;
var LA75_0 = this.input.LA(1);
if ( (LA75_0==LEVBODY) ) {
alt75=1;
}
switch (alt75) {
case 1 :
// Ham4HMLGen.g:1054:11: lbb= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_levelcomplexbody7937);
lbb=this.levelbody();
this.state._fsp--;
break;
}
rlcb = hBuilder.newHMLElement("levelcomplexbody");
rlcb.appendChild(lba);
hBuilder.checkedAppendChild(rlcb, lbb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlcb;
},
// Ham4HMLGen.g:1062:1: levelcomplexhand returns [Element rlch = null] : lha= levelhand (lhb= levelhand )? ;
// $ANTLR start "levelcomplexhand"
levelcomplexhand: function() {
var rlch =  null;
var lha = null;
var lhb = null;
try {
// Ham4HMLGen.g:1065:5: (lha= levelhand (lhb= levelhand )? )
// Ham4HMLGen.g:1065:9: lha= levelhand (lhb= levelhand )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelhand_in_levelcomplexhand7982);
lha=this.levelhand();
this.state._fsp--;
// Ham4HMLGen.g:1066:9: (lhb= levelhand )?
var alt76=2;
var LA76_0 = this.input.LA(1);
if ( (LA76_0==LEVHAND) ) {
alt76=1;
}
switch (alt76) {
case 1 :
// Ham4HMLGen.g:1066:11: lhb= levelhand
this.pushFollow(Ham4HMLGen.FOLLOW_levelhand_in_levelcomplexhand8000);
lhb=this.levelhand();
this.state._fsp--;
break;
}
rlch = hBuilder.newHMLElement("levelcomplexhand");
rlch.appendChild(lha);
hBuilder.checkedAppendChild(rlch, lhb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlch;
},
// Ham4HMLGen.g:1074:1: levelcomplexarm returns [Element rlca = null] : laa= levelarm (lab= levelarm )? ;
// $ANTLR start "levelcomplexarm"
levelcomplexarm: function() {
var rlca =  null;
var laa = null;
var lab = null;
try {
// Ham4HMLGen.g:1077:5: (laa= levelarm (lab= levelarm )? )
// Ham4HMLGen.g:1077:9: laa= levelarm (lab= levelarm )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_levelcomplexarm8046);
laa=this.levelarm();
this.state._fsp--;
// Ham4HMLGen.g:1078:9: (lab= levelarm )?
var alt77=2;
var LA77_0 = this.input.LA(1);
if ( (LA77_0==LEVARM) ) {
alt77=1;
}
switch (alt77) {
case 1 :
// Ham4HMLGen.g:1078:11: lab= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_levelcomplexarm8064);
lab=this.levelarm();
this.state._fsp--;
break;
}
rlca = hBuilder.newHMLElement("levelcomplexarm");
rlca.appendChild(laa);
hBuilder.checkedAppendChild(rlca, lab);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlca;
},
// Ham4HMLGen.g:1086:1: levelbody returns [Element rlb = null] : ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelbody"
levelbody: function() {
var rlb =  null;
var sd = null;
var lb = null;
var approxlb = false;
try {
// Ham4HMLGen.g:1092:5: ( ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1093:5: ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? )
this.match(this.input,LEVBODY,Ham4HMLGen.FOLLOW_LEVBODY_in_levelbody8111); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1094:9: (sd= side[\"left\"] )?
var alt78=2;
var LA78_0 = this.input.LA(1);
if ( ((LA78_0>=HamLrbeside && LA78_0<=HamLrat)) ) {
alt78=1;
}
switch (alt78) {
case 1 :
// Ham4HMLGen.g:1094:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelbody8130);
sd=this.side("left");
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1095:9: (lb= locbody | lb= locsided )
var alt79=2;
var LA79_0 = this.input.LA(1);
if ( (LA79_0==LOCBODY) ) {
alt79=1;
}
else if ( (LA79_0==HamEarlobe||(LA79_0>=HamEar && LA79_0<=HamCheek)) ) {
alt79=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 79, 0, this.input);
throw nvae;
}
switch (alt79) {
case 1 :
// Ham4HMLGen.g:1096:13: lb= locbody
this.pushFollow(Ham4HMLGen.FOLLOW_locbody_in_levelbody8163);
lb=this.locbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1098:13: lb= locsided
this.pushFollow(Ham4HMLGen.FOLLOW_locsided_in_levelbody8192);
lb=this.locsided();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1100:9: ( HamEtc )?
var alt80=2;
var LA80_0 = this.input.LA(1);
if ( (LA80_0==HamEtc) ) {
alt80=1;
}
switch (alt80) {
case 1 :
// Ham4HMLGen.g:1100:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_levelbody8222); 
approxlb = true; 
break;
}
// Ham4HMLGen.g:1101:9: (sd= side[\"right\"] )?
var alt81=2;
var LA81_0 = this.input.LA(1);
if ( ((LA81_0>=HamLrbeside && LA81_0<=HamLrat)) ) {
alt81=1;
}
switch (alt81) {
case 1 :
// Ham4HMLGen.g:1101:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelbody8257);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlb = hBuilder.newHMLElement("levelbody");
rlb.setAttribute("locbody", lb);
hBuilder.checkedSetAttr(rlb, "side", sd);
hBuilder.checkedSetFlagAttr(rlb, "approx_location", approxlb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1111:1: levelhand returns [Element rlh = null] : ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelhand"
levelhand: function() {
var rlh =  null;
var sd = null;
var hp = null;
var fp = null;
var d = null;
var dp = null;
rlh = hBuilder.newHMLElement("levelhand");
try {
// Ham4HMLGen.g:1117:5: ( ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1118:5: ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? )
this.match(this.input,LEVHAND,Ham4HMLGen.FOLLOW_LEVHAND_in_levelhand8311); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1119:9: (sd= side[\"left\"] )?
var alt82=2;
var LA82_0 = this.input.LA(1);
if ( ((LA82_0>=HamLrbeside && LA82_0<=HamLrat)) ) {
alt82=1;
}
switch (alt82) {
case 1 :
// Ham4HMLGen.g:1119:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelhand8330);
sd=this.side("left");
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1120:9: (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? )
var alt86=3;
switch ( this.input.LA(1) ) {
case HamWristback:
case HamWristpulse:
case HamThumbball:
case HamPalm:
case HamHandback:
case HamThumbside:
case HamPinkyside:
alt86=1;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt86=2;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt86=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 86, 0, this.input);
throw nvae;
}
switch (alt86) {
case 1 :
// Ham4HMLGen.g:1121:13: hp= handpart
this.pushFollow(Ham4HMLGen.FOLLOW_handpart_in_levelhand8363);
hp=this.handpart();
this.state._fsp--;
rlh.appendChild(hp); 
break;
case 2 :
// Ham4HMLGen.g:1124:13: fp= fingerpart (d= digit )*
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_levelhand8402);
fp=this.fingerpart();
this.state._fsp--;
rlh.appendChild(fp); 
// Ham4HMLGen.g:1125:13: (d= digit )*
loop83:
do {
var alt83=2;
var LA83_0 = this.input.LA(1);
if ( ((LA83_0>=HamThumb && LA83_0<=HamPinky)) ) {
alt83=1;
}
switch (alt83) {
case 1 :
// Ham4HMLGen.g:1125:15: d= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_levelhand8433);
d=this.digit();
this.state._fsp--;
rlh.appendChild(d); 
break;
default :
break loop83;
}
} while (true);
break;
case 3 :
// Ham4HMLGen.g:1127:13: (d= digit )+ (fp= fingerpart )?
// Ham4HMLGen.g:1127:13: (d= digit )+
var cnt84=0;
loop84:
do {
var alt84=2;
var LA84_0 = this.input.LA(1);
if ( ((LA84_0>=HamThumb && LA84_0<=HamPinky)) ) {
alt84=1;
}
switch (alt84) {
case 1 :
// Ham4HMLGen.g:1127:15: d= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_levelhand8476);
d=this.digit();
this.state._fsp--;
rlh.appendChild(d); 
break;
default :
if ( cnt84 >= 1 ) {
break loop84;
}
var eee = new org.antlr.runtime.EarlyExitException(84, this.input);
throw eee;
}
cnt84++;
} while (true);
// Ham4HMLGen.g:1128:13: (fp= fingerpart )?
var alt85=2;
var LA85_0 = this.input.LA(1);
if ( ((LA85_0>=HamFingertip && LA85_0<=HamFingerside)) ) {
alt85=1;
}
switch (alt85) {
case 1 :
// Ham4HMLGen.g:1128:15: fp= fingerpart
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_levelhand8510);
fp=this.fingerpart();
this.state._fsp--;
rlh.appendChild(fp); 
break;
}
break;
}
// Ham4HMLGen.g:1139:9: (dp= dorsalorpalmar )?
var alt87=2;
var LA87_0 = this.input.LA(1);
if ( ((LA87_0>=HamPalm && LA87_0<=HamHandback)) ) {
alt87=1;
}
switch (alt87) {
case 1 :
// Ham4HMLGen.g:1139:11: dp= dorsalorpalmar
this.pushFollow(Ham4HMLGen.FOLLOW_dorsalorpalmar_in_levelhand8553);
dp=this.dorsalorpalmar();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1140:9: (sd= side[\"right\"] )?
var alt88=2;
var LA88_0 = this.input.LA(1);
if ( ((LA88_0>=HamLrbeside && LA88_0<=HamLrat)) ) {
alt88=1;
}
switch (alt88) {
case 1 :
// Ham4HMLGen.g:1140:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelhand8575);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
// Check for HNS-3 to HNS-4 conversion:
if (hp != null) {
if (hp.getAttribute("handpart") === "ham_wristpulse") {
hp.setAttribute("handpart", "ham_wristback");
rlh.setAttribute("dorsal_or_palmar", "palmar");
}
}
else
if (fp != null) {
if (fp.getAttribute("fingerpart") === "ham_finger_pad") {
fp.setAttribute("fingerpart", "ham_finger_nail");
rlh.setAttribute("dorsal_or_palmar", "palmar");
}
}
hBuilder.checkedSetAttr(rlh, "side", sd);
hBuilder.checkedSetAttr(rlh, "dorsal_or_palmar", dp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlh;
},
// Ham4HMLGen.g:1163:1: levelarm returns [Element rla = null] : ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelarm"
levelarm: function() {
var rla =  null;
var sd = null;
var la = null;
var dp = null;
var approxla = false;
try {
// Ham4HMLGen.g:1169:5: ( ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1170:5: ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? )
this.match(this.input,LEVARM,Ham4HMLGen.FOLLOW_LEVARM_in_levelarm8630); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1171:9: (sd= side[\"left\"] )?
var alt89=2;
var LA89_0 = this.input.LA(1);
if ( ((LA89_0>=HamLrbeside && LA89_0<=HamLrat)) ) {
alt89=1;
}
switch (alt89) {
case 1 :
// Ham4HMLGen.g:1171:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelarm8649);
sd=this.side("left");
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_locarm_in_levelarm8672);
la=this.locarm();
this.state._fsp--;
// Ham4HMLGen.g:1173:9: ( HamEtc )?
var alt90=2;
var LA90_0 = this.input.LA(1);
if ( (LA90_0==HamEtc) ) {
alt90=1;
}
switch (alt90) {
case 1 :
// Ham4HMLGen.g:1173:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_levelarm8692); 
approxla = true; 
break;
}
// Ham4HMLGen.g:1174:9: (dp= dorsalorpalmar )?
var alt91=2;
var LA91_0 = this.input.LA(1);
if ( ((LA91_0>=HamPalm && LA91_0<=HamHandback)) ) {
alt91=1;
}
switch (alt91) {
case 1 :
// Ham4HMLGen.g:1174:11: dp= dorsalorpalmar
this.pushFollow(Ham4HMLGen.FOLLOW_dorsalorpalmar_in_levelarm8727);
dp=this.dorsalorpalmar();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1175:9: (sd= side[\"right\"] )?
var alt92=2;
var LA92_0 = this.input.LA(1);
if ( ((LA92_0>=HamLrbeside && LA92_0<=HamLrat)) ) {
alt92=1;
}
switch (alt92) {
case 1 :
// Ham4HMLGen.g:1175:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelarm8749);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rla = hBuilder.newHMLElement("levelarm");
rla.setAttribute("locarm", la);
hBuilder.checkedSetAttr(rla, "side", sd);
hBuilder.checkedSetAttr(rla, "dorsal_or_palmar", dp);
hBuilder.checkedSetFlagAttr(rla, "approx_location", approxla);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1186:1: contactbody returns [Element rcb = null] : ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) ) ;
// $ANTLR start "contactbody"
contactbody: function() {
var rcb =  null;
var cbsub = null;
try {
// Ham4HMLGen.g:1189:5: ( ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) ) )
// Ham4HMLGen.g:1190:5: ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) )
this.match(this.input,CNTCTBODY,Ham4HMLGen.FOLLOW_CNTCTBODY_in_contactbody8797); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1191:9: (cbsub= pcontact | HamArmextended | cbsub= contactofhand )
var alt93=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt93=1;
break;
case HamArmextended:
alt93=2;
break;
case CNTCTOFHAND:
alt93=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 93, 0, this.input);
throw nvae;
}
switch (alt93) {
case 1 :
// Ham4HMLGen.g:1192:13: cbsub= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contactbody8827);
cbsub=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1194:13: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_contactbody8851); 
cbsub = hBuilder.newHMLElement("hamarmextended"); 
break;
case 3 :
// Ham4HMLGen.g:1197:13: cbsub= contactofhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactofhand_in_contactbody8903);
cbsub=this.contactofhand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcb = hBuilder.wrapperEl("contactbody", cbsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcb;
},
// Ham4HMLGen.g:1205:1: contacthand returns [Element rch = null] : ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) ) ;
// $ANTLR start "contacthand"
contacthand: function() {
var rch =  null;
var chsub = null;
try {
// Ham4HMLGen.g:1208:5: ( ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) ) )
// Ham4HMLGen.g:1209:5: ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) )
this.match(this.input,CNTCTHAND,Ham4HMLGen.FOLLOW_CNTCTHAND_in_contacthand8957); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1210:9: (chsub= pcontact | chsub= ccontact | chsub= contactofhand )
var alt94=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt94=1;
break;
case HamInterlock:
case HamCross:
alt94=2;
break;
case CNTCTOFHAND:
alt94=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 0, this.input);
throw nvae;
}
switch (alt94) {
case 1 :
// Ham4HMLGen.g:1211:13: chsub= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contacthand8987);
chsub=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1213:13: chsub= ccontact
this.pushFollow(Ham4HMLGen.FOLLOW_ccontact_in_contacthand9017);
chsub=this.ccontact();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1215:13: chsub= contactofhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactofhand_in_contacthand9047);
chsub=this.contactofhand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rch = hBuilder.wrapperEl("contacthand", chsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rch;
},
// Ham4HMLGen.g:1229:1: contactofhand returns [Element rcoh = null] : ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) ) ;
// $ANTLR start "contactofhand"
contactofhand: function() {
var rcoh =  null;
var pc = null;
var loc = null;
try {
// Ham4HMLGen.g:1232:5: ( ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) ) )
// Ham4HMLGen.g:1233:5: ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) )
this.match(this.input,CNTCTOFHAND,Ham4HMLGen.FOLLOW_CNTCTOFHAND_in_contactofhand9109); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1234:9: (pc= pcontact | pc= ccontact )
var alt95=2;
var LA95_0 = this.input.LA(1);
if ( ((LA95_0>=HamClose && LA95_0<=HamTouch)) ) {
alt95=1;
}
else if ( ((LA95_0>=HamInterlock && LA95_0<=HamCross)) ) {
alt95=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 95, 0, this.input);
throw nvae;
}
switch (alt95) {
case 1 :
// Ham4HMLGen.g:1235:13: pc= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contactofhand9142);
pc=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1237:13: pc= ccontact
this.pushFollow(Ham4HMLGen.FOLLOW_ccontact_in_contactofhand9175);
pc=this.ccontact();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1239:9: (loc= contactohhand | loc= contactoharm )
var alt96=2;
var LA96_0 = this.input.LA(1);
if ( (LA96_0==CNTCTOHHAND) ) {
alt96=1;
}
else if ( (LA96_0==CNTCTOHARM) ) {
alt96=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 96, 0, this.input);
throw nvae;
}
switch (alt96) {
case 1 :
// Ham4HMLGen.g:1240:13: loc= contactohhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactohhand_in_contactofhand9217);
loc=this.contactohhand();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1242:13: loc= contactoharm
this.pushFollow(Ham4HMLGen.FOLLOW_contactoharm_in_contactofhand9249);
loc=this.contactoharm();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcoh = hBuilder.newHMLElement("contactofhand");
rcoh.appendChild(pc);
rcoh.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcoh;
},
// Ham4HMLGen.g:1252:1: contactohhand returns [Element rcohh = null] : ^( CNTCTOHHAND cohh= levelcomplexhand ) ;
// $ANTLR start "contactohhand"
contactohhand: function() {
var rcohh =  null;
var cohh = null;
try {
// Ham4HMLGen.g:1256:5: ( ^( CNTCTOHHAND cohh= levelcomplexhand ) )
// Ham4HMLGen.g:1257:5: ^( CNTCTOHHAND cohh= levelcomplexhand )
this.match(this.input,CNTCTOHHAND,Ham4HMLGen.FOLLOW_CNTCTOHHAND_in_contactohhand9305); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexhand_in_contactohhand9319);
cohh=this.levelcomplexhand();
this.state._fsp--;
rcohh = cohh; 
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcohh;
},
// Ham4HMLGen.g:1262:1: contactoharm returns [Element rcoha = null] : ^( CNTCTOHARM coha= levelcomplexarm ) ;
// $ANTLR start "contactoharm"
contactoharm: function() {
var rcoha =  null;
var coha = null;
try {
// Ham4HMLGen.g:1266:5: ( ^( CNTCTOHARM coha= levelcomplexarm ) )
// Ham4HMLGen.g:1267:5: ^( CNTCTOHARM coha= levelcomplexarm )
this.match(this.input,CNTCTOHARM,Ham4HMLGen.FOLLOW_CNTCTOHARM_in_contactoharm9364); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexarm_in_contactoharm9378);
coha=this.levelcomplexarm();
this.state._fsp--;
rcoha = coha; 
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcoha;
},
// Ham4HMLGen.g:1272:1: handconstellation returns [Element rhc = null] : ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand ) ;
// $ANTLR start "handconstellation"
handconstellation: function() {
var rhc =  null;
var lha = null;
var lhb = null;
var ch = null;
try {
// Ham4HMLGen.g:1275:5: ( ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand ) )
// Ham4HMLGen.g:1276:5: ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand )
this.match(this.input,HCONSTLLN,Ham4HMLGen.FOLLOW_HCONSTLLN_in_handconstellation9420); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1277:9: (lha= locationhand lhb= locationhand )?
var alt97=2;
var LA97_0 = this.input.LA(1);
if ( (LA97_0==LOCTNHAND) ) {
alt97=1;
}
switch (alt97) {
case 1 :
// Ham4HMLGen.g:1278:13: lha= locationhand lhb= locationhand
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_handconstellation9448);
lha=this.locationhand();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_handconstellation9466);
lhb=this.locationhand();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_contacthand_in_handconstellation9496);
ch=this.contacthand();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconstellation");
hBuilder.checkedAppendChild(rhc, lha);
hBuilder.checkedAppendChild(rhc, lhb);
rhc.appendChild(ch);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:1294:1: locarm returns [String rla = null] : ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm ) ;
// $ANTLR start "locarm"
locarm: function() {
var rla =  null;
try {
// Ham4HMLGen.g:1296:5: ( ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm ) )
// Ham4HMLGen.g:1297:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
// Ham4HMLGen.g:1297:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
var alt98=4;
switch ( this.input.LA(1) ) {
case HamUpperarm:
alt98=1;
break;
case HamElbow:
alt98=2;
break;
case HamElbowinside:
alt98=3;
break;
case HamLowerarm:
alt98=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 98, 0, this.input);
throw nvae;
}
switch (alt98) {
case 1 :
// Ham4HMLGen.g:1297:9: HamUpperarm
this.match(this.input,HamUpperarm,Ham4HMLGen.FOLLOW_HamUpperarm_in_locarm9551); 
rla = "ham_upperarm"; 
break;
case 2 :
// Ham4HMLGen.g:1298:9: HamElbow
this.match(this.input,HamElbow,Ham4HMLGen.FOLLOW_HamElbow_in_locarm9575); 
rla = "ham_elbow"; 
break;
case 3 :
// Ham4HMLGen.g:1299:9: HamElbowinside
this.match(this.input,HamElbowinside,Ham4HMLGen.FOLLOW_HamElbowinside_in_locarm9602); 
rla = "ham_elbowinside"; 
break;
case 4 :
// Ham4HMLGen.g:1300:9: HamLowerarm
this.match(this.input,HamLowerarm,Ham4HMLGen.FOLLOW_HamLowerarm_in_locarm9623); 
rla = "ham_lowerarm"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1304:1: locbody returns [String rlb = null] : ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? ) ;
// $ANTLR start "locbody"
locbody: function() {
var rlb =  null;
var uprlwr = null;
try {
// Ham4HMLGen.g:1309:5: ( ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? ) )
// Ham4HMLGen.g:1310:5: ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? )
this.match(this.input,LOCBODY,Ham4HMLGen.FOLLOW_LOCBODY_in_locbody9683); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1311:9: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
var alt99=18;
switch ( this.input.LA(1) ) {
case HamHead:
alt99=1;
break;
case HamHeadtop:
alt99=2;
break;
case HamForehead:
alt99=3;
break;
case HamEyebrows:
alt99=4;
break;
case HamEyes:
alt99=5;
break;
case HamNose:
alt99=6;
break;
case HamNostrils:
alt99=7;
break;
case HamLips:
alt99=8;
break;
case HamTongue:
alt99=9;
break;
case HamTeeth:
alt99=10;
break;
case HamChin:
alt99=11;
break;
case HamUnderchin:
alt99=12;
break;
case HamNeck:
alt99=13;
break;
case HamShouldertop:
alt99=14;
break;
case HamShoulders:
alt99=15;
break;
case HamChest:
alt99=16;
break;
case HamStomach:
alt99=17;
break;
case HamBelowstomach:
alt99=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 99, 0, this.input);
throw nvae;
}
switch (alt99) {
case 1 :
// Ham4HMLGen.g:1311:13: HamHead
this.match(this.input,HamHead,Ham4HMLGen.FOLLOW_HamHead_in_locbody9697); 
rlb = "ham_head"; 
break;
case 2 :
// Ham4HMLGen.g:1312:13: HamHeadtop
this.match(this.input,HamHeadtop,Ham4HMLGen.FOLLOW_HamHeadtop_in_locbody9729); 
rlb = "ham_headtop"; 
break;
case 3 :
// Ham4HMLGen.g:1313:13: HamForehead
this.match(this.input,HamForehead,Ham4HMLGen.FOLLOW_HamForehead_in_locbody9758); 
rlb = "ham_forehead"; 
break;
case 4 :
// Ham4HMLGen.g:1314:13: HamEyebrows
this.match(this.input,HamEyebrows,Ham4HMLGen.FOLLOW_HamEyebrows_in_locbody9786); 
rlb = "ham_eyebrows"; 
break;
case 5 :
// Ham4HMLGen.g:1315:13: HamEyes
this.match(this.input,HamEyes,Ham4HMLGen.FOLLOW_HamEyes_in_locbody9814); 
rlb = "ham_eyes"; 
break;
case 6 :
// Ham4HMLGen.g:1316:13: HamNose
this.match(this.input,HamNose,Ham4HMLGen.FOLLOW_HamNose_in_locbody9846); 
rlb = "ham_nose"; 
break;
case 7 :
// Ham4HMLGen.g:1317:13: HamNostrils
this.match(this.input,HamNostrils,Ham4HMLGen.FOLLOW_HamNostrils_in_locbody9878); 
rlb = "ham_nostrils"; 
break;
case 8 :
// Ham4HMLGen.g:1318:13: HamLips
this.match(this.input,HamLips,Ham4HMLGen.FOLLOW_HamLips_in_locbody9906); 
rlb = "ham_lips"; 
break;
case 9 :
// Ham4HMLGen.g:1319:13: HamTongue
this.match(this.input,HamTongue,Ham4HMLGen.FOLLOW_HamTongue_in_locbody9938); 
rlb = "ham_tongue"; 
break;
case 10 :
// Ham4HMLGen.g:1320:13: HamTeeth
this.match(this.input,HamTeeth,Ham4HMLGen.FOLLOW_HamTeeth_in_locbody9968); 
rlb = "ham_teeth"; 
break;
case 11 :
// Ham4HMLGen.g:1321:13: HamChin
this.match(this.input,HamChin,Ham4HMLGen.FOLLOW_HamChin_in_locbody9999); 
rlb = "ham_chin"; 
break;
case 12 :
// Ham4HMLGen.g:1322:13: HamUnderchin
this.match(this.input,HamUnderchin,Ham4HMLGen.FOLLOW_HamUnderchin_in_locbody10031); 
rlb = "ham_underchin"; 
break;
case 13 :
// Ham4HMLGen.g:1323:13: HamNeck
this.match(this.input,HamNeck,Ham4HMLGen.FOLLOW_HamNeck_in_locbody10058); 
rlb = "ham_neck"; 
break;
case 14 :
// Ham4HMLGen.g:1324:13: HamShouldertop
this.match(this.input,HamShouldertop,Ham4HMLGen.FOLLOW_HamShouldertop_in_locbody10090); 
rlb = "ham_shouldertop"; 
break;
case 15 :
// Ham4HMLGen.g:1325:13: HamShoulders
this.match(this.input,HamShoulders,Ham4HMLGen.FOLLOW_HamShoulders_in_locbody10115); 
rlb = "ham_shoulders"; 
break;
case 16 :
// Ham4HMLGen.g:1326:13: HamChest
this.match(this.input,HamChest,Ham4HMLGen.FOLLOW_HamChest_in_locbody10142); 
rlb = "ham_chest"; 
break;
case 17 :
// Ham4HMLGen.g:1327:13: HamStomach
this.match(this.input,HamStomach,Ham4HMLGen.FOLLOW_HamStomach_in_locbody10173); 
rlb = "ham_stomach"; 
break;
case 18 :
// Ham4HMLGen.g:1328:13: HamBelowstomach
this.match(this.input,HamBelowstomach,Ham4HMLGen.FOLLOW_HamBelowstomach_in_locbody10202); 
rlb = "ham_belowstomach"; 
break;
}
// Ham4HMLGen.g:1330:9: ( HamDoublebent | HamDoublehooked )?
var alt100=3;
var LA100_0 = this.input.LA(1);
if ( (LA100_0==HamDoublebent) ) {
alt100=1;
}
else if ( (LA100_0==HamDoublehooked) ) {
alt100=2;
}
switch (alt100) {
case 1 :
// Ham4HMLGen.g:1331:13: HamDoublebent
this.match(this.input,HamDoublebent,Ham4HMLGen.FOLLOW_HamDoublebent_in_locbody10246); 
uprlwr = "ham_upper"; 
break;
case 2 :
// Ham4HMLGen.g:1332:13: HamDoublehooked
this.match(this.input,HamDoublehooked,Ham4HMLGen.FOLLOW_HamDoublehooked_in_locbody10272); 
uprlwr = "ham_lower"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (uprlwr != null) {
if (rlb === "ham_eyes") {
rlb = uprlwr + "eyelid";
}
else
if (rlb === "ham_lips") {
rlb = uprlwr + "lip";
}
else
if (rlb === "ham_teeth") {
rlb = uprlwr + "teeth";
}
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1352:1: locsided returns [String rls = null] : ( HamEar | HamEarlobe | HamCheek ) ;
// $ANTLR start "locsided"
locsided: function() {
var rls =  null;
try {
// Ham4HMLGen.g:1354:5: ( ( HamEar | HamEarlobe | HamCheek ) )
// Ham4HMLGen.g:1355:5: ( HamEar | HamEarlobe | HamCheek )
// Ham4HMLGen.g:1355:5: ( HamEar | HamEarlobe | HamCheek )
var alt101=3;
switch ( this.input.LA(1) ) {
case HamEar:
alt101=1;
break;
case HamEarlobe:
alt101=2;
break;
case HamCheek:
alt101=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 101, 0, this.input);
throw nvae;
}
switch (alt101) {
case 1 :
// Ham4HMLGen.g:1355:9: HamEar
this.match(this.input,HamEar,Ham4HMLGen.FOLLOW_HamEar_in_locsided10343); 
rls = "ham_ear"; 
break;
case 2 :
// Ham4HMLGen.g:1356:9: HamEarlobe
this.match(this.input,HamEarlobe,Ham4HMLGen.FOLLOW_HamEarlobe_in_locsided10372); 
rls = "ham_earlobe"; 
break;
case 3 :
// Ham4HMLGen.g:1357:9: HamCheek
this.match(this.input,HamCheek,Ham4HMLGen.FOLLOW_HamCheek_in_locsided10397); 
rls = "ham_cheek"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rls;
},
// Ham4HMLGen.g:1361:1: handpart returns [Element rhp = null] : ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside ) ;
// $ANTLR start "handpart"
handpart: function() {
var rhp =  null;
var  shp     = null;
try {
// Ham4HMLGen.g:1366:5: ( ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside ) )
// Ham4HMLGen.g:1367:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
// Ham4HMLGen.g:1367:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
var alt102=7;
switch ( this.input.LA(1) ) {
case HamWristback:
alt102=1;
break;
case HamWristpulse:
alt102=2;
break;
case HamThumbball:
alt102=3;
break;
case HamPalm:
alt102=4;
break;
case HamHandback:
alt102=5;
break;
case HamThumbside:
alt102=6;
break;
case HamPinkyside:
alt102=7;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 102, 0, this.input);
throw nvae;
}
switch (alt102) {
case 1 :
// Ham4HMLGen.g:1367:9: HamWristback
this.match(this.input,HamWristback,Ham4HMLGen.FOLLOW_HamWristback_in_handpart10462); 
shp = "ham_wristback"; 
break;
case 2 :
// Ham4HMLGen.g:1368:9: HamWristpulse
this.match(this.input,HamWristpulse,Ham4HMLGen.FOLLOW_HamWristpulse_in_handpart10485); 
shp = "ham_wristpulse"; 
break;
case 3 :
// Ham4HMLGen.g:1369:9: HamThumbball
this.match(this.input,HamThumbball,Ham4HMLGen.FOLLOW_HamThumbball_in_handpart10507); 
shp = "ham_thumbball"; 
break;
case 4 :
// Ham4HMLGen.g:1370:9: HamPalm
this.match(this.input,HamPalm,Ham4HMLGen.FOLLOW_HamPalm_in_handpart10530); 
shp = "ham_palm"; 
break;
case 5 :
// Ham4HMLGen.g:1371:9: HamHandback
this.match(this.input,HamHandback,Ham4HMLGen.FOLLOW_HamHandback_in_handpart10558); 
shp = "ham_handback"; 
break;
case 6 :
// Ham4HMLGen.g:1372:9: HamThumbside
this.match(this.input,HamThumbside,Ham4HMLGen.FOLLOW_HamThumbside_in_handpart10582); 
shp = "ham_thumbside"; 
break;
case 7 :
// Ham4HMLGen.g:1373:9: HamPinkyside
this.match(this.input,HamPinkyside,Ham4HMLGen.FOLLOW_HamPinkyside_in_handpart10605); 
shp = "ham_pinkyside"; 
break;
}
rhp = hBuilder.newHMLElement("handpart");
rhp.setAttribute("handpart", shp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhp;
},
// Ham4HMLGen.g:1381:1: side[lh_or_rh] returns [String rs = null] : ( HamLrbeside | HamLrat ) ;
// $ANTLR start "side"
side: function(lh_or_rh) {
var rs =  null;
try {
// Ham4HMLGen.g:1386:5: ( ( HamLrbeside | HamLrat ) )
// Ham4HMLGen.g:1387:5: ( HamLrbeside | HamLrat )
// Ham4HMLGen.g:1387:5: ( HamLrbeside | HamLrat )
var alt103=2;
var LA103_0 = this.input.LA(1);
if ( (LA103_0==HamLrbeside) ) {
alt103=1;
}
else if ( (LA103_0==HamLrat) ) {
alt103=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 103, 0, this.input);
throw nvae;
}
switch (alt103) {
case 1 :
// Ham4HMLGen.g:1387:9: HamLrbeside
this.match(this.input,HamLrbeside,Ham4HMLGen.FOLLOW_HamLrbeside_in_side10690); 
rs = "beside"; 
break;
case 2 :
// Ham4HMLGen.g:1388:9: HamLrat
this.match(this.input,HamLrat,Ham4HMLGen.FOLLOW_HamLrat_in_side10714); 
rs = "at"; 
break;
}
rs = "ham_" + lh_or_rh + "_" + rs;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rs;
},
// Ham4HMLGen.g:1395:1: dorsalorpalmar returns [String rdp = null] : ( HamHandback | HamPalm ) ;
// $ANTLR start "dorsalorpalmar"
dorsalorpalmar: function() {
var rdp =  null;
try {
// Ham4HMLGen.g:1398:5: ( ( HamHandback | HamPalm ) )
// Ham4HMLGen.g:1399:5: ( HamHandback | HamPalm )
// Ham4HMLGen.g:1399:5: ( HamHandback | HamPalm )
var alt104=2;
var LA104_0 = this.input.LA(1);
if ( (LA104_0==HamHandback) ) {
alt104=1;
}
else if ( (LA104_0==HamPalm) ) {
alt104=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 104, 0, this.input);
throw nvae;
}
switch (alt104) {
case 1 :
// Ham4HMLGen.g:1399:9: HamHandback
this.match(this.input,HamHandback,Ham4HMLGen.FOLLOW_HamHandback_in_dorsalorpalmar10776); 
rdp = "dorsal"; 
break;
case 2 :
// Ham4HMLGen.g:1400:9: HamPalm
this.match(this.input,HamPalm,Ham4HMLGen.FOLLOW_HamPalm_in_dorsalorpalmar10800); 
rdp = "palmar"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rdp;
},
// Ham4HMLGen.g:1404:1: pcontact returns [Element rpc = null] : ( HamTouch | HamClose ) ;
// $ANTLR start "pcontact"
pcontact: function() {
var rpc =  null;
var  spc     = null;
try {
// Ham4HMLGen.g:1409:5: ( ( HamTouch | HamClose ) )
// Ham4HMLGen.g:1410:5: ( HamTouch | HamClose )
// Ham4HMLGen.g:1410:5: ( HamTouch | HamClose )
var alt105=2;
var LA105_0 = this.input.LA(1);
if ( (LA105_0==HamTouch) ) {
alt105=1;
}
else if ( (LA105_0==HamClose) ) {
alt105=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 105, 0, this.input);
throw nvae;
}
switch (alt105) {
case 1 :
// Ham4HMLGen.g:1410:9: HamTouch
this.match(this.input,HamTouch,Ham4HMLGen.FOLLOW_HamTouch_in_pcontact10866); 
spc = "ham_touch"; 
break;
case 2 :
// Ham4HMLGen.g:1411:9: HamClose
this.match(this.input,HamClose,Ham4HMLGen.FOLLOW_HamClose_in_pcontact10893); 
spc = "ham_close"; 
break;
}
rpc = hBuilder.newHMLElement("pcontact");
rpc.setAttribute("where", spc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpc;
},
// Ham4HMLGen.g:1419:1: ccontact returns [Element rcc = null] : ( HamInterlock | HamCross ) ;
// $ANTLR start "ccontact"
ccontact: function() {
var rcc =  null;
var  scc     = null;
try {
// Ham4HMLGen.g:1424:5: ( ( HamInterlock | HamCross ) )
// Ham4HMLGen.g:1425:5: ( HamInterlock | HamCross )
// Ham4HMLGen.g:1425:5: ( HamInterlock | HamCross )
var alt106=2;
var LA106_0 = this.input.LA(1);
if ( (LA106_0==HamInterlock) ) {
alt106=1;
}
else if ( (LA106_0==HamCross) ) {
alt106=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 106, 0, this.input);
throw nvae;
}
switch (alt106) {
case 1 :
// Ham4HMLGen.g:1425:9: HamInterlock
this.match(this.input,HamInterlock,Ham4HMLGen.FOLLOW_HamInterlock_in_ccontact10964); 
scc = "ham_interlock"; 
break;
case 2 :
// Ham4HMLGen.g:1426:9: HamCross
this.match(this.input,HamCross,Ham4HMLGen.FOLLOW_HamCross_in_ccontact10987); 
scc = "ham_cross"; 
break;
}
rcc = hBuilder.newHMLElement("ccontact");
rcc.setAttribute("crosskind", scc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcc;
},
// Ham4HMLGen.g:1437:1: a2tstar returns [Element[] ral = null] : ^( A2TLIST (a2t= action2t )* ) ;
// $ANTLR start "a2tstar"
a2tstar: function() {
var ral =  null;
var a2t = null;
alist   = [];
try {
// Ham4HMLGen.g:1443:5: ( ^( A2TLIST (a2t= action2t )* ) )
// Ham4HMLGen.g:1444:5: ^( A2TLIST (a2t= action2t )* )
this.match(this.input,A2TLIST,Ham4HMLGen.FOLLOW_A2TLIST_in_a2tstar11059); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1445:9: (a2t= action2t )*
loop107:
do {
var alt107=2;
var LA107_0 = this.input.LA(1);
if ( (LA107_0==ACTION2T) ) {
alt107=1;
}
switch (alt107) {
case 1 :
// Ham4HMLGen.g:1445:11: a2t= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_a2tstar11077);
a2t=this.action2t();
this.state._fsp--;
alist.push(a2t); 
break;
default :
break loop107;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
ral = alist;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ral;
},
// Ham4HMLGen.g:1452:1: a1tstar returns [Element[] ral = null] : ^( A1TLIST (a1t= action1t )* ) ;
// $ANTLR start "a1tstar"
a1tstar: function() {
var ral =  null;
var a1t = null;
var alist   = [];
try {
// Ham4HMLGen.g:1458:5: ( ^( A1TLIST (a1t= action1t )* ) )
// Ham4HMLGen.g:1459:5: ^( A1TLIST (a1t= action1t )* )
this.match(this.input,A1TLIST,Ham4HMLGen.FOLLOW_A1TLIST_in_a1tstar11139); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1460:9: (a1t= action1t )*
loop108:
do {
var alt108=2;
var LA108_0 = this.input.LA(1);
if ( (LA108_0==ACTION1T) ) {
alt108=1;
}
switch (alt108) {
case 1 :
// Ham4HMLGen.g:1460:11: a1t= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_a1tstar11157);
a1t=this.action1t();
this.state._fsp--;
alist.push(a1t); 
break;
default :
break loop108;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
ral = alist;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ral;
},
// Ham4HMLGen.g:1467:1: action2t returns [Element ra = null] : ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? ) ;
// $ANTLR start "action2t"
action2t: function() {
var ra =  null;
var sub = null;
var a = null;
var loc = null;
var ra1 = null;
var ra2 = null;
try {
// Ham4HMLGen.g:1470:5: ( ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? ) )
// Ham4HMLGen.g:1471:5: ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? )
this.match(this.input,ACTION2T,Ham4HMLGen.FOLLOW_ACTION2T_in_action2t11214); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1472:9: (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t )
var alt109=7;
switch ( this.input.LA(1) ) {
case ACTION1T:
alt109=1;
break;
case ACTION1:
alt109=2;
break;
case SPLITACT2LOC2:
alt109=3;
break;
case SPLITACT2T:
alt109=4;
break;
case PARACT2T:
alt109=5;
break;
case SEQACT2T:
alt109=6;
break;
case SEQFUSEDACT2T:
alt109=7;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 109, 0, this.input);
throw nvae;
}
switch (alt109) {
case 1 :
// Ham4HMLGen.g:1473:13: sub= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_action2t11242);
sub=this.action1t();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1475:13: a= action1 loc= location2
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_action2t11272);
a=this.action1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_action2t11290);
loc=this.location2();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1478:13: ra1= splitaction2loc2
this.pushFollow(Ham4HMLGen.FOLLOW_splitaction2loc2_in_action2t11319);
ra1=this.splitaction2loc2();
this.state._fsp--;
ra = ra1; 
break;
case 4 :
// Ham4HMLGen.g:1480:13: ra2= splitaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_splitaction2t_in_action2t11354);
ra2=this.splitaction2t();
this.state._fsp--;
ra = ra2; 
break;
case 5 :
// Ham4HMLGen.g:1482:13: sub= paraction2t
this.pushFollow(Ham4HMLGen.FOLLOW_paraction2t_in_action2t11391);
sub=this.paraction2t();
this.state._fsp--;
break;
case 6 :
// Ham4HMLGen.g:1484:13: sub= seqaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction2t_in_action2t11419);
sub=this.seqaction2t();
this.state._fsp--;
break;
case 7 :
// Ham4HMLGen.g:1486:13: sub= seqfusedaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction2t_in_action2t11447);
sub=this.seqfusedaction2t();
this.state._fsp--;
break;
}
if (ra == null) {
if (sub != null) {
ra = hBuilder.wrapperEl("action2t", sub);
}
else /* a != null */ {
ra = hBuilder.wrapPair("action2t", a, loc);
}
}
// Ham4HMLGen.g:1498:9: ( repetitions[ra] )?
var alt110=2;
var LA110_0 = this.input.LA(1);
if ( (LA110_0==REPETITIONS) ) {
alt110=1;
}
switch (alt110) {
case 1 :
// Ham4HMLGen.g:1498:11: repetitions[ra]
this.pushFollow(Ham4HMLGen.FOLLOW_repetitions_in_action2t11483);
this.repetitions(ra);
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
/*  TBD: allow location2? after repetitions, and in this case
*  wrap ra and the extra loc as a new action2t;
*/
ra = hBuilder.stripParentIfNotNeeded(ra);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1508:1: action1t returns [Element ra = null] : ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? ) ;
// $ANTLR start "action1t"
action1t: function() {
var ra =  null;
var a = null;
var tl = null;
var sub = null;
var ract = null;
var     bouncing= false;
try {
// Ham4HMLGen.g:1514:5: ( ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? ) )
// Ham4HMLGen.g:1515:5: ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? )
this.match(this.input,ACTION1T,Ham4HMLGen.FOLLOW_ACTION1T_in_action1t11538); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1516:9: (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t )
var alt113=5;
switch ( this.input.LA(1) ) {
case ACTION1:
alt113=1;
break;
case PARACT1T:
alt113=2;
break;
case SEQACT1T:
alt113=3;
break;
case SEQFUSEDACT1T:
alt113=4;
break;
case NMACT1T:
alt113=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 113, 0, this.input);
throw nvae;
}
switch (alt113) {
case 1 :
// Ham4HMLGen.g:1517:13: a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )?
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_action1t11572);
a=this.action1();
this.state._fsp--;
// Ham4HMLGen.g:1518:13: (tl= location1 ( HamLargemod )? | tl= handconstellation )?
var alt112=3;
var LA112_0 = this.input.LA(1);
if ( (LA112_0==LOC1) ) {
alt112=1;
}
else if ( (LA112_0==HCONSTLLN) ) {
alt112=2;
}
switch (alt112) {
case 1 :
// Ham4HMLGen.g:1519:17: tl= location1 ( HamLargemod )?
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_action1t11609);
tl=this.location1();
this.state._fsp--;
// Ham4HMLGen.g:1520:21: ( HamLargemod )?
var alt111=2;
var LA111_0 = this.input.LA(1);
if ( (LA111_0==HamLargemod) ) {
alt111=1;
}
switch (alt111) {
case 1 :
// Ham4HMLGen.g:1520:23: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_action1t11633); 
bouncing = true; 
break;
}
break;
case 2 :
// Ham4HMLGen.g:1522:17: tl= handconstellation
this.pushFollow(Ham4HMLGen.FOLLOW_handconstellation_in_action1t11677);
tl=this.handconstellation();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1525:13: sub= paraction1t
this.pushFollow(Ham4HMLGen.FOLLOW_paraction1t_in_action1t11724);
sub=this.paraction1t();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1527:13: sub= seqaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction1t_in_action1t11756);
sub=this.seqaction1t();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1529:13: sub= seqfusedaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction1t_in_action1t11788);
sub=this.seqfusedaction1t();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1531:13: ract= nmaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_nmaction1t_in_action1t11819);
ract=this.nmaction1t();
this.state._fsp--;
ra = ract; 
break;
}
if (ra == null) {
if (sub != null) {
ra = hBuilder.wrapperEl("action1t", sub);
}
else /* a != null */ {
hBuilder.checkedSetFlagAttr(
a, "bouncing", bouncing);
ra = hBuilder.wrapperEl("action1t", a);
hBuilder.checkedAppendChild(ra, tl);
}
}
// Ham4HMLGen.g:1546:9: ( repetitions[ra] )?
var alt114=2;
var LA114_0 = this.input.LA(1);
if ( (LA114_0==REPETITIONS) ) {
alt114=1;
}
switch (alt114) {
case 1 :
// Ham4HMLGen.g:1546:11: repetitions[ra]
this.pushFollow(Ham4HMLGen.FOLLOW_repetitions_in_action1t11861);
this.repetitions(ra);
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
/*  TBD: allow location1? after repetitions, and in this case
*  wrap ra and the extra loc as a new action1t;
*/
ra = hBuilder.stripParentIfNotNeeded(ra);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1556:1: action1 returns [Element ra = null] : ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) ) ;
// $ANTLR start "action1"
action1: function() {
var ra =  null;
var sub = null;
var mod = null;
var     bouncing    = false;
try {
// Ham4HMLGen.g:1562:5: ( ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) ) )
// Ham4HMLGen.g:1563:5: ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) )
this.match(this.input,ACTION1,Ham4HMLGen.FOLLOW_ACTION1_in_action111917); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1564:9: ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 )
var alt118=5;
switch ( this.input.LA(1) ) {
case HamNomotion:
alt118=1;
break;
case SIMPLEMVMT:
alt118=2;
break;
case PARACT1:
alt118=3;
break;
case SEQACT1:
alt118=4;
break;
case SEQFUSEDACT1:
alt118=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 118, 0, this.input);
throw nvae;
}
switch (alt118) {
case 1 :
// Ham4HMLGen.g:1565:23: HamNomotion
this.match(this.input,HamNomotion,Ham4HMLGen.FOLLOW_HamNomotion_in_action111951); 
sub = hBuilder.newHMLElement("hamnomotion"); 
break;
case 2 :
// Ham4HMLGen.g:1568:13: sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )?
this.pushFollow(Ham4HMLGen.FOLLOW_simplemovement_in_action112007);
sub=this.simplemovement();
this.state._fsp--;
// Ham4HMLGen.g:1569:13: ( (mod= modifier )+ ( HamLargemod )? )?
var alt117=2;
var LA117_0 = this.input.LA(1);
if ( ((LA117_0>=HamFast && LA117_0<=HamHalt)) ) {
alt117=1;
}
switch (alt117) {
case 1 :
// Ham4HMLGen.g:1570:17: (mod= modifier )+ ( HamLargemod )?
// Ham4HMLGen.g:1570:17: (mod= modifier )+
var cnt115=0;
loop115:
do {
var alt115=2;
var LA115_0 = this.input.LA(1);
if ( ((LA115_0>=HamFast && LA115_0<=HamHalt)) ) {
alt115=1;
}
switch (alt115) {
case 1 :
// Ham4HMLGen.g:1571:17: mod= modifier
this.pushFollow(Ham4HMLGen.FOLLOW_modifier_in_action112061);
mod=this.modifier();
this.state._fsp--;
sub.setAttribute(mod, "true"); 
break;
default :
if ( cnt115 >= 1 ) {
break loop115;
}
var eee = new org.antlr.runtime.EarlyExitException(115, this.input);
throw eee;
}
cnt115++;
} while (true);
// Ham4HMLGen.g:1574:21: ( HamLargemod )?
var alt116=2;
var LA116_0 = this.input.LA(1);
if ( (LA116_0==HamLargemod) ) {
alt116=1;
}
switch (alt116) {
case 1 :
// Ham4HMLGen.g:1574:23: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_action112128); 
bouncing = true; 
break;
}
break;
}
break;
case 3 :
// Ham4HMLGen.g:1577:13: sub= paraction1
this.pushFollow(Ham4HMLGen.FOLLOW_paraction1_in_action112182);
sub=this.paraction1();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1579:13: sub= seqaction1
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction1_in_action112214);
sub=this.seqaction1();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1581:13: sub= seqfusedaction1
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction1_in_action112246);
sub=this.seqfusedaction1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ra = hBuilder.wrapIfNeeded("action1", sub);
hBuilder.checkedSetFlagAttr(ra, "bouncing", bouncing);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1593:1: paraction2t returns [Element rpa = null] : ^( PARACT2T (a= action2t )+ ) ;
// $ANTLR start "paraction2t"
paraction2t: function() {
var rpa =  null;
var a = null;
al  = [];
try {
// Ham4HMLGen.g:1599:5: ( ^( PARACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1600:5: ^( PARACT2T (a= action2t )+ )
this.match(this.input,PARACT2T,Ham4HMLGen.FOLLOW_PARACT2T_in_paraction2t12307); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1601:9: (a= action2t )+
var cnt119=0;
loop119:
do {
var alt119=2;
var LA119_0 = this.input.LA(1);
if ( (LA119_0==ACTION2T) ) {
alt119=1;
}
switch (alt119) {
case 1 :
// Ham4HMLGen.g:1602:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_paraction2t12337);
a=this.action2t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt119 >= 1 ) {
break loop119;
}
var eee = new org.antlr.runtime.EarlyExitException(119, this.input);
throw eee;
}
cnt119++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action2t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1610:1: seqaction2t returns [Element rsa = null] : ^( SEQACT2T (a= action2t )+ ) ;
// $ANTLR start "seqaction2t"
seqaction2t: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1616:5: ( ^( SEQACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1617:5: ^( SEQACT2T (a= action2t )+ )
this.match(this.input,SEQACT2T,Ham4HMLGen.FOLLOW_SEQACT2T_in_seqaction2t12403); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1618:9: (a= action2t )+
var cnt120=0;
loop120:
do {
var alt120=2;
var LA120_0 = this.input.LA(1);
if ( (LA120_0==ACTION2T) ) {
alt120=1;
}
switch (alt120) {
case 1 :
// Ham4HMLGen.g:1619:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_seqaction2t12433);
a=this.action2t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt120 >= 1 ) {
break loop120;
}
var eee = new org.antlr.runtime.EarlyExitException(120, this.input);
throw eee;
}
cnt120++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action2t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1627:1: seqfusedaction2t returns [Element rsfa = null] : ^( SEQFUSEDACT2T (a= action2t )+ ) ;
// $ANTLR start "seqfusedaction2t"
seqfusedaction2t: function() {
var rsfa =  null;
var a = null;
var al = [];
try {
// Ham4HMLGen.g:1634:5: ( ^( SEQFUSEDACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1635:5: ^( SEQFUSEDACT2T (a= action2t )+ )
this.match(this.input,SEQFUSEDACT2T,Ham4HMLGen.FOLLOW_SEQFUSEDACT2T_in_seqfusedaction2t12502); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1636:9: (a= action2t )+
var cnt121=0;
loop121:
do {
var alt121=2;
var LA121_0 = this.input.LA(1);
if ( (LA121_0==ACTION2T) ) {
alt121=1;
}
switch (alt121) {
case 1 :
// Ham4HMLGen.g:1637:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_seqfusedaction2t12532);
a=this.action2t();
this.state._fsp--;
al.add(a); 
break;
default :
if ( cnt121 >= 1 ) {
break loop121;
}
var eee = new org.antlr.runtime.EarlyExitException(121, this.input);
throw eee;
}
cnt121++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action2t");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1648:1: splitaction2loc2 returns [Element rsal = null] : ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 ) ;
// $ANTLR start "splitaction2loc2"
splitaction2loc2: function() {
var rsal =  null;
var a = null;
var loc = null;
var sadom   = hBuilder.newHMLElement("seq_action1");
var sasub   = hBuilder.newHMLElement("seq_action1");
try {
// Ham4HMLGen.g:1655:5: ( ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 ) )
// Ham4HMLGen.g:1656:5: ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 )
this.match(this.input,SPLITACT2LOC2,Ham4HMLGen.FOLLOW_SPLITACT2LOC2_in_splitaction2loc212597); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1657:9: (a= action1 )+
var cnt122=0;
loop122:
do {
var alt122=2;
var LA122_0 = this.input.LA(1);
if ( (LA122_0==ACTION1) ) {
alt122=1;
}
switch (alt122) {
case 1 :
// Ham4HMLGen.g:1657:11: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_splitaction2loc212617);
a=this.action1();
this.state._fsp--;
sadom.appendChild(a); 
break;
default :
if ( cnt122 >= 1 ) {
break loop122;
}
var eee = new org.antlr.runtime.EarlyExitException(122, this.input);
throw eee;
}
cnt122++;
} while (true);
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_splitaction2loc212640); 
// Ham4HMLGen.g:1659:9: (a= action1 )+
var cnt123=0;
loop123:
do {
var alt123=2;
var LA123_0 = this.input.LA(1);
if ( (LA123_0==ACTION1) ) {
alt123=1;
}
switch (alt123) {
case 1 :
// Ham4HMLGen.g:1659:11: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_splitaction2loc212660);
a=this.action1();
this.state._fsp--;
sasub.appendChild(a); 
break;
default :
if ( cnt123 >= 1 ) {
break loop123;
}
var eee = new org.antlr.runtime.EarlyExitException(123, this.input);
throw eee;
}
cnt123++;
} while (true);
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_splitaction2loc212691);
loc=this.location2();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
var a2  = hBuilder.newHMLElement("action2");
// A singleton sequence can be unwrapped, rather
// than being wrapped.
var adom =
sadom.childNodes.length==1 ?
sadom.firstChild :
hBuilder.wrapperEl("action1", sadom);
a2.appendChild(adom);
// Again, choose between unwrapping and wrapping.
var asub =
sasub.childNodes.length==1 ?
sasub.firstChild :
hBuilder.wrapperEl("action1", sasub);
a2.appendChild(asub);
rsal = hBuilder.newHMLElement("action2t");
rsal.appendChild(a2);
rsal.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsal;
},
// Ham4HMLGen.g:1686:1: splitaction2t returns [Element rsa = null] : ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ ) ;
// $ANTLR start "splitaction2t"
splitaction2t: function() {
var rsa =  null;
var at = null;
var satdom  = hBuilder.newHMLElement("seq_action1t");
var satsub  = hBuilder.newHMLElement("seq_action1t");
try {
// Ham4HMLGen.g:1693:5: ( ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ ) )
// Ham4HMLGen.g:1694:5: ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ )
this.match(this.input,SPLITACT2T,Ham4HMLGen.FOLLOW_SPLITACT2T_in_splitaction2t12737); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1695:9: (at= action1t )+
var cnt124=0;
loop124:
do {
var alt124=2;
var LA124_0 = this.input.LA(1);
if ( (LA124_0==ACTION1T) ) {
alt124=1;
}
switch (alt124) {
case 1 :
// Ham4HMLGen.g:1695:11: at= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_splitaction2t12756);
at=this.action1t();
this.state._fsp--;
satdom.appendChild(at); 
break;
default :
if ( cnt124 >= 1 ) {
break loop124;
}
var eee = new org.antlr.runtime.EarlyExitException(124, this.input);
throw eee;
}
cnt124++;
} while (true);
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_splitaction2t12778); 
// Ham4HMLGen.g:1697:9: (at= action1t )+
var cnt125=0;
loop125:
do {
var alt125=2;
var LA125_0 = this.input.LA(1);
if ( (LA125_0==ACTION1T) ) {
alt125=1;
}
switch (alt125) {
case 1 :
// Ham4HMLGen.g:1697:11: at= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_splitaction2t12797);
at=this.action1t();
this.state._fsp--;
satsub.appendChild(at); 
break;
default :
if ( cnt125 >= 1 ) {
break loop125;
}
var eee = new org.antlr.runtime.EarlyExitException(125, this.input);
throw eee;
}
cnt125++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.newHMLElement("action2t");
// A singleton sequence can be unwrapped, rather
// than being wrapped.
var atdom =
satdom.childNodes.length==1 ?
satdom.firstChild :
hBuilder.wrapperEl("action1t", satdom);
rsa.appendChild(atdom);
// Again, choose between unwrapping and wrapping.
var atsub =
satsub.childNodes.length==1 ?
satsub.firstChild :
hBuilder.wrapperEl("action1t", satsub);
rsa.appendChild(atsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1719:1: paraction1t returns [Element rpa = null] : ^( PARACT1T (a= action1t )+ ) ;
// $ANTLR start "paraction1t"
paraction1t: function() {
var rpa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1725:5: ( ^( PARACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1726:5: ^( PARACT1T (a= action1t )+ )
this.match(this.input,PARACT1T,Ham4HMLGen.FOLLOW_PARACT1T_in_paraction1t12857); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1727:9: (a= action1t )+
var cnt126=0;
loop126:
do {
var alt126=2;
var LA126_0 = this.input.LA(1);
if ( (LA126_0==ACTION1T) ) {
alt126=1;
}
switch (alt126) {
case 1 :
// Ham4HMLGen.g:1728:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_paraction1t12887);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt126 >= 1 ) {
break loop126;
}
var eee = new org.antlr.runtime.EarlyExitException(126, this.input);
throw eee;
}
cnt126++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action1t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1736:1: seqaction1t returns [Element rsa = null] : ^( SEQACT1T (a= action1t )+ ) ;
// $ANTLR start "seqaction1t"
seqaction1t: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1742:5: ( ^( SEQACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1743:5: ^( SEQACT1T (a= action1t )+ )
this.match(this.input,SEQACT1T,Ham4HMLGen.FOLLOW_SEQACT1T_in_seqaction1t12953); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1744:9: (a= action1t )+
var cnt127=0;
loop127:
do {
var alt127=2;
var LA127_0 = this.input.LA(1);
if ( (LA127_0==ACTION1T) ) {
alt127=1;
}
switch (alt127) {
case 1 :
// Ham4HMLGen.g:1745:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_seqaction1t12983);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt127 >= 1 ) {
break loop127;
}
var eee = new org.antlr.runtime.EarlyExitException(127, this.input);
throw eee;
}
cnt127++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action1t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1753:1: seqfusedaction1t returns [Element rsfa = null] : ^( SEQFUSEDACT1T (a= action1t )+ ) ;
// $ANTLR start "seqfusedaction1t"
seqfusedaction1t: function() {
var rsfa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1760:5: ( ^( SEQFUSEDACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1761:5: ^( SEQFUSEDACT1T (a= action1t )+ )
this.match(this.input,SEQFUSEDACT1T,Ham4HMLGen.FOLLOW_SEQFUSEDACT1T_in_seqfusedaction1t13052); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1762:9: (a= action1t )+
var cnt128=0;
loop128:
do {
var alt128=2;
var LA128_0 = this.input.LA(1);
if ( (LA128_0==ACTION1T) ) {
alt128=1;
}
switch (alt128) {
case 1 :
// Ham4HMLGen.g:1763:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_seqfusedaction1t13082);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt128 >= 1 ) {
break loop128;
}
var eee = new org.antlr.runtime.EarlyExitException(128, this.input);
throw eee;
}
cnt128++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action1t");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1774:1: nmaction1t returns [Element rnma = null] : ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t ) ;
// $ANTLR start "nmaction1t"
nmaction1t: function() {
var rnma =  null;
var hd = null;
var a = null;
try {
// Ham4HMLGen.g:1777:5: ( ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t ) )
// Ham4HMLGen.g:1778:5: ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t )
this.match(this.input,NMACT1T,Ham4HMLGen.FOLLOW_NMACT1T_in_nmaction1t13145); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1779:9: (hd= levelbody | hd= levelarm )
var alt129=2;
var LA129_0 = this.input.LA(1);
if ( (LA129_0==LEVBODY) ) {
alt129=1;
}
else if ( (LA129_0==LEVARM) ) {
alt129=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 129, 0, this.input);
throw nvae;
}
switch (alt129) {
case 1 :
// Ham4HMLGen.g:1780:13: hd= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_nmaction1t13174);
hd=this.levelbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1782:13: hd= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_nmaction1t13203);
hd=this.levelarm();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_nmaction1t13234);
a=this.action1t();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rnma = hBuilder.newHMLElement("action1t");
rnma.appendChild(hd);
rnma.appendChild(a);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnma;
},
// Ham4HMLGen.g:1794:1: paraction1 returns [Element rpa = null] : ^( PARACT1 (a= action1 )+ ) ;
// $ANTLR start "paraction1"
paraction1: function() {
var rpa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1800:5: ( ^( PARACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1801:5: ^( PARACT1 (a= action1 )+ )
this.match(this.input,PARACT1,Ham4HMLGen.FOLLOW_PARACT1_in_paraction113283); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1802:9: (a= action1 )+
var cnt130=0;
loop130:
do {
var alt130=2;
var LA130_0 = this.input.LA(1);
if ( (LA130_0==ACTION1) ) {
alt130=1;
}
switch (alt130) {
case 1 :
// Ham4HMLGen.g:1803:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_paraction113313);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt130 >= 1 ) {
break loop130;
}
var eee = new org.antlr.runtime.EarlyExitException(130, this.input);
throw eee;
}
cnt130++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1811:1: seqaction1 returns [Element rsa = null] : ^( SEQACT1 (a= action1 )+ ) ;
// $ANTLR start "seqaction1"
seqaction1: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1817:5: ( ^( SEQACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1818:5: ^( SEQACT1 (a= action1 )+ )
this.match(this.input,SEQACT1,Ham4HMLGen.FOLLOW_SEQACT1_in_seqaction113385); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1819:9: (a= action1 )+
var cnt131=0;
loop131:
do {
var alt131=2;
var LA131_0 = this.input.LA(1);
if ( (LA131_0==ACTION1) ) {
alt131=1;
}
switch (alt131) {
case 1 :
// Ham4HMLGen.g:1820:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_seqaction113415);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt131 >= 1 ) {
break loop131;
}
var eee = new org.antlr.runtime.EarlyExitException(131, this.input);
throw eee;
}
cnt131++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1828:1: seqfusedaction1 returns [Element rsfa = null] : ^( SEQFUSEDACT1 (a= action1 )+ ) ;
// $ANTLR start "seqfusedaction1"
seqfusedaction1: function() {
var rsfa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1835:5: ( ^( SEQFUSEDACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1836:5: ^( SEQFUSEDACT1 (a= action1 )+ )
this.match(this.input,SEQFUSEDACT1,Ham4HMLGen.FOLLOW_SEQFUSEDACT1_in_seqfusedaction113490); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1837:9: (a= action1 )+
var cnt132=0;
loop132:
do {
var alt132=2;
var LA132_0 = this.input.LA(1);
if ( (LA132_0==ACTION1) ) {
alt132=1;
}
switch (alt132) {
case 1 :
// Ham4HMLGen.g:1838:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_seqfusedaction113520);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt132 >= 1 ) {
break loop132;
}
var eee = new org.antlr.runtime.EarlyExitException(132, this.input);
throw eee;
}
cnt132++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action1");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1849:1: repetitions[action] : ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) ) ;
// $ANTLR start "repetitions"
repetitions: function(action) {
var r0 = null;
var ed = null;
var r1 = null;
var sc = null;
var sz = null;
var     approxrpt = false;
var     alta    = false;
var     altb    = false;
try {
// Ham4HMLGen.g:1856:5: ( ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) ) )
// Ham4HMLGen.g:1857:5: ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) )
this.match(this.input,REPETITIONS,Ham4HMLGen.FOLLOW_REPETITIONS_in_repetitions13593); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1858:9: ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? )
var alt141=2;
var LA141_0 = this.input.LA(1);
if ( ((LA141_0>=HamRepeatfromstart && LA141_0<=HamRepeatcontinueseveral)||LA141_0==HamRepeatreverse||LA141_0==MOVINGREPETITION) ) {
alt141=1;
}
else if ( (LA141_0==HamAlternatingmotion) ) {
alt141=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 141, 0, this.input);
throw nvae;
}
switch (alt141) {
case 1 :
// Ham4HMLGen.g:1859:13: (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )?
// Ham4HMLGen.g:1859:13: (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] )
var alt135=2;
var LA135_0 = this.input.LA(1);
if ( ((LA135_0>=HamRepeatfromstart && LA135_0<=HamRepeatcontinueseveral)||LA135_0==HamRepeatreverse) ) {
alt135=1;
}
else if ( (LA135_0==MOVINGREPETITION) ) {
alt135=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);
throw nvae;
}
switch (alt135) {
case 1 :
// Ham4HMLGen.g:1860:21: r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )?
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_repetitions13644);
r0=this.repetition();
this.state._fsp--;
// Ham4HMLGen.g:1861:17: ( HamEtc (ed= ellipsedirection )? | r1= repetition )?
var alt134=3;
var LA134_0 = this.input.LA(1);
if ( (LA134_0==HamEtc) ) {
alt134=1;
}
else if ( ((LA134_0>=HamRepeatfromstart && LA134_0<=HamRepeatcontinueseveral)||LA134_0==HamRepeatreverse) ) {
alt134=2;
}
switch (alt134) {
case 1 :
// Ham4HMLGen.g:1862:27: HamEtc (ed= ellipsedirection )?
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_repetitions13690); 
approxrpt = true; 
// Ham4HMLGen.g:1863:20: (ed= ellipsedirection )?
var alt133=2;
var LA133_0 = this.input.LA(1);
if ( ((LA133_0>=HamEllipseh && LA133_0<=HamEllipseul)) ) {
alt133=1;
}
switch (alt133) {
case 1 :
// Ham4HMLGen.g:1863:22: ed= ellipsedirection
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_repetitions13734);
ed=this.ellipsedirection();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1865:22: r1= repetition
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_repetitions13782);
r1=this.repetition();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1868:27: movingrepetition[action]
this.pushFollow(Ham4HMLGen.FOLLOW_movingrepetition_in_repetitions13843);
this.movingrepetition(action);
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1870:13: (sc= sizechange (sz= size )? )?
var alt137=2;
var LA137_0 = this.input.LA(1);
if ( ((LA137_0>=HamIncreasing && LA137_0<=HamDecreasing)) ) {
alt137=1;
}
switch (alt137) {
case 1 :
// Ham4HMLGen.g:1871:17: sc= sizechange (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_repetitions13899);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:1872:17: (sz= size )?
var alt136=2;
var LA136_0 = this.input.LA(1);
if ( ((LA136_0>=HamSmallmod && LA136_0<=HamLargemod)) ) {
alt136=1;
}
switch (alt136) {
case 1 :
// Ham4HMLGen.g:1872:19: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_repetitions13926);
sz=this.size();
this.state._fsp--;
break;
}
break;
}
// Ham4HMLGen.g:1874:13: ( HamAlternatingmotion ( HamAlternatingmotion )? )?
var alt139=2;
var LA139_0 = this.input.LA(1);
if ( (LA139_0==HamAlternatingmotion) ) {
alt139=1;
}
switch (alt139) {
case 1 :
// Ham4HMLGen.g:1875:27: HamAlternatingmotion ( HamAlternatingmotion )?
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions13986); 
alta = true; 
// Ham4HMLGen.g:1876:7: ( HamAlternatingmotion )?
var alt138=2;
var LA138_0 = this.input.LA(1);
if ( (LA138_0==HamAlternatingmotion) ) {
alt138=1;
}
switch (alt138) {
case 1 :
// Ham4HMLGen.g:1876:9: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions13999); 
altb = true; 
break;
}
break;
}
break;
case 2 :
// Ham4HMLGen.g:1879:13: HamAlternatingmotion ( HamAlternatingmotion )?
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14044); 
alta = true; 
// Ham4HMLGen.g:1880:13: ( HamAlternatingmotion )?
var alt140=2;
var LA140_0 = this.input.LA(1);
if ( (LA140_0==HamAlternatingmotion) ) {
alt140=1;
}
switch (alt140) {
case 1 :
// Ham4HMLGen.g:1880:15: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14065); 
altb = true; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (r0 != null) {
hBuilder.checkedSetAttr(action, "repetition", r0);
hBuilder.checkedSetAttr(action, "second_repetition", r1);
if (approxrpt && r0.endsWith("fromstartseveral")) {
hBuilder.checkedSetAttr(action, "approx_repetition", "true");
hBuilder.checkedSetAttr(action, "ellipsedirection", ed);
}
}
hBuilder.checkedSetAttr(action, "repetition_incrdecr", sc);
hBuilder.checkedSetAttr(action, "repetition_incrdecr_size", sz);
hBuilder.checkedSetFlagAttr(action, "alternating", alta);
hBuilder.checkedSetFlagAttr(action, "second_alternating", altb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:1899:1: movingrepetition[action] : ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? ) ;
// $ANTLR start "movingrepetition"
movingrepetition: function(action) {
var r = null;
var ma = null;
var sz = null;
var sc = null;
var idsz = null;
try {
// Ham4HMLGen.g:1901:5: ( ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? ) )
// Ham4HMLGen.g:1902:5: ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? )
this.match(this.input,MOVINGREPETITION,Ham4HMLGen.FOLLOW_MOVINGREPETITION_in_movingrepetition14122); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_movingrepetition14146);
r=this.repetition();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_movingrepetition14169);
ma=this.movementarrow();
this.state._fsp--;
// Ham4HMLGen.g:1905:9: (sz= size )?
var alt142=2;
var LA142_0 = this.input.LA(1);
if ( ((LA142_0>=HamSmallmod && LA142_0<=HamLargemod)) ) {
alt142=1;
}
switch (alt142) {
case 1 :
// Ham4HMLGen.g:1905:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_movingrepetition14192);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1906:9: (sc= sizechange (idsz= size )? )?
var alt144=2;
var LA144_0 = this.input.LA(1);
if ( ((LA144_0>=HamIncreasing && LA144_0<=HamDecreasing)) ) {
alt144=1;
}
switch (alt144) {
case 1 :
// Ham4HMLGen.g:1907:13: sc= sizechange (idsz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_movingrepetition14228);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:1908:13: (idsz= size )?
var alt143=2;
var LA143_0 = this.input.LA(1);
if ( ((LA143_0>=HamSmallmod && LA143_0<=HamLargemod)) ) {
alt143=1;
}
switch (alt143) {
case 1 :
// Ham4HMLGen.g:1908:15: idsz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_movingrepetition14249);
idsz=this.size();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
hBuilder.checkedSetAttr(action, "repetition", r);
hBuilder.checkedSetAttr(action, "repetition_baseshift", ma);
hBuilder.checkedSetAttr(action, "baseshift_size", sz);
hBuilder.checkedSetAttr(action, "baseshift_incrdecr", sc);
hBuilder.checkedSetAttr(action, "baseshift_incrdecr_size", idsz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:1923:1: simplemovement returns [rsm = null] : ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? ) ;
// $ANTLR start "simplemovement"
simplemovement: function() {
var rsm =  null;
var mv = null;
var tmpdig = null;
var bl = null;
var dig = null;
var dl = null;
try {
// Ham4HMLGen.g:1929:5: ( ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? ) )
// Ham4HMLGen.g:1930:5: ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? )
this.match(this.input,SIMPLEMVMT,Ham4HMLGen.FOLLOW_SIMPLEMVMT_in_simplemovement14311); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1931:9: (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay )
var alt146=6;
switch ( this.input.LA(1) ) {
case STRGHTMVMT:
alt146=1;
break;
case CRCLRMVMT:
alt146=2;
break;
case HamNodding:
case HamSwinging:
case HamTwisting:
case HamStircw:
case HamStirccw:
alt146=3;
break;
case HamMovecross:
case HamMovex:
alt146=4;
break;
case REPLACE:
alt146=5;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
case HamFingerplay:
alt146=6;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 146, 0, this.input);
throw nvae;
}
switch (alt146) {
case 1 :
// Ham4HMLGen.g:1932:13: mv= fullstraightmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullstraightmovement_in_simplemovement14340);
mv=this.fullstraightmovement();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1934:13: mv= fullcircularmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullcircularmovement_in_simplemovement14369);
mv=this.fullcircularmovement();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1936:13: mv= fullwristmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullwristmovement_in_simplemovement14398);
mv=this.fullwristmovement();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1938:13: mv= fullmovementcross
this.pushFollow(Ham4HMLGen.FOLLOW_fullmovementcross_in_simplemovement14427);
mv=this.fullmovementcross();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1940:13: mv= replacement
this.pushFollow(Ham4HMLGen.FOLLOW_replacement_in_simplemovement14456);
mv=this.replacement();
this.state._fsp--;
break;
case 6 :
// Ham4HMLGen.g:1942:19: (tmpdig= digit )* HamFingerplay
// Ham4HMLGen.g:1942:19: (tmpdig= digit )*
loop145:
do {
var alt145=2;
var LA145_0 = this.input.LA(1);
if ( ((LA145_0>=HamThumb && LA145_0<=HamPinky)) ) {
alt145=1;
}
switch (alt145) {
case 1 :
// Ham4HMLGen.g:1943:23: tmpdig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_simplemovement14514);
tmpdig=this.digit();
this.state._fsp--;
if (dl == null) { dl = []; }
dl.push(tmpdig); 
break;
default :
break loop145;
}
} while (true);
this.match(this.input,HamFingerplay,Ham4HMLGen.FOLLOW_HamFingerplay_in_simplemovement14579); 
mv = hBuilder.newHMLElement("hamfingerplay"); 
break;
}
// Ham4HMLGen.g:1952:9: ( HamBrushing bl= location1 )?
var alt147=2;
var LA147_0 = this.input.LA(1);
if ( (LA147_0==HamBrushing) ) {
alt147=1;
}
switch (alt147) {
case 1 :
// Ham4HMLGen.g:1953:19: HamBrushing bl= location1
this.match(this.input,HamBrushing,Ham4HMLGen.FOLLOW_HamBrushing_in_simplemovement14639); 
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_simplemovement14658);
bl=this.location1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1956:9: (dig= digit )?
var alt148=2;
var LA148_0 = this.input.LA(1);
if ( ((LA148_0>=HamThumb && LA148_0<=HamPinky)) ) {
alt148=1;
}
switch (alt148) {
case 1 :
// Ham4HMLGen.g:1956:13: dig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_simplemovement14687);
dig=this.digit();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsm = hBuilder.newHMLElement("simplemovement");
if (dl != null) {
for (var i = 0; i < dl.length; i++) { mv.appendChild(dl[i]); }
}
rsm.appendChild(mv);
hBuilder.checkedAppendChild(rsm, bl);
if (dig != null) {
var dstr = dig.getAttribute("fingerid");
var ipos = "ham_digit_".length();
var locstr = "loc" + dstr.substring(ipos);
hBuilder.checkedSetAttr(rsm, "def_locname", locstr);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsm;
},
// Ham4HMLGen.g:1974:1: fullstraightmovement returns [Element rfsm = null] : (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? ) ;
// $ANTLR start "fullstraightmovement"
fullstraightmovement: function() {
var rfsm =  null;
var fsm = null;
var sz = null;
try {
// Ham4HMLGen.g:1978:5: ( (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? ) )
// Ham4HMLGen.g:1979:5: (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? )
// Ham4HMLGen.g:1979:5: (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? )
// Ham4HMLGen.g:1980:9: fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )?
this.pushFollow(Ham4HMLGen.FOLLOW_straightmovement_in_fullstraightmovement14750);
fsm=this.straightmovement();
this.state._fsp--;
rfsm = fsm; 
// Ham4HMLGen.g:1981:9: (sz= size )?
var alt149=2;
var LA149_0 = this.input.LA(1);
if ( ((LA149_0>=HamSmallmod && LA149_0<=HamLargemod)) ) {
alt149=1;
}
switch (alt149) {
case 1 :
// Ham4HMLGen.g:1981:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullstraightmovement14775);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1982:9: ( arckind[rfsm] | zigzag[rfsm] )?
var alt150=3;
var LA150_0 = this.input.LA(1);
if ( ((LA150_0>=HamArcl && LA150_0<=HamArcd)) ) {
alt150=1;
}
else if ( ((LA150_0>=HamWavy && LA150_0<=HamZigzag)) ) {
alt150=2;
}
switch (alt150) {
case 1 :
// Ham4HMLGen.g:1983:19: arckind[rfsm]
this.pushFollow(Ham4HMLGen.FOLLOW_arckind_in_fullstraightmovement14808);
this.arckind(rfsm);
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1985:19: zigzag[rfsm]
this.pushFollow(Ham4HMLGen.FOLLOW_zigzag_in_fullstraightmovement14839);
this.zigzag(rfsm);
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(rfsm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfsm;
},
// Ham4HMLGen.g:1993:1: straightmovement returns [Element rsm = null] : ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? ) ;
// $ANTLR start "straightmovement"
straightmovement: function() {
var rsm =  null;
var ma = null;
var mb = null;
try {
// Ham4HMLGen.g:1996:5: ( ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? ) )
// Ham4HMLGen.g:1997:5: ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? )
this.match(this.input,STRGHTMVMT,Ham4HMLGen.FOLLOW_STRGHTMVMT_in_straightmovement14894); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_straightmovement14913);
ma=this.movementarrow();
this.state._fsp--;
// Ham4HMLGen.g:1999:9: (mb= movementarrow )?
var alt151=2;
var LA151_0 = this.input.LA(1);
if ( ((LA151_0>=HamMoveu && LA151_0<=HamMoveuo)) ) {
alt151=1;
}
switch (alt151) {
case 1 :
// Ham4HMLGen.g:1999:11: mb= movementarrow
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_straightmovement14932);
mb=this.movementarrow();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsm = hBuilder.newHMLElement("straightmovement");
hBuilder.checkedSetAttr(rsm, "movement", ma);
hBuilder.checkedSetAttr(rsm, "second_movement", mb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsm;
},
// Ham4HMLGen.g:2008:1: arckind[ake] : (aa= arc (ab= arc )? (sz= size )? ) ;
// $ANTLR start "arckind"
arckind: function(ake) {
var aa = null;
var ab = null;
var sz = null;
try {
// Ham4HMLGen.g:2012:5: ( (aa= arc (ab= arc )? (sz= size )? ) )
// Ham4HMLGen.g:2013:5: (aa= arc (ab= arc )? (sz= size )? )
// Ham4HMLGen.g:2013:5: (aa= arc (ab= arc )? (sz= size )? )
// Ham4HMLGen.g:2014:9: aa= arc (ab= arc )? (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_arc_in_arckind14999);
aa=this.arc();
this.state._fsp--;
// Ham4HMLGen.g:2015:9: (ab= arc )?
var alt152=2;
var LA152_0 = this.input.LA(1);
if ( ((LA152_0>=HamArcl && LA152_0<=HamArcd)) ) {
alt152=1;
}
switch (alt152) {
case 1 :
// Ham4HMLGen.g:2015:11: ab= arc
this.pushFollow(Ham4HMLGen.FOLLOW_arc_in_arckind15018);
ab=this.arc();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2016:9: (sz= size )?
var alt153=2;
var LA153_0 = this.input.LA(1);
if ( ((LA153_0>=HamSmallmod && LA153_0<=HamLargemod)) ) {
alt153=1;
}
switch (alt153) {
case 1 :
// Ham4HMLGen.g:2016:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_arckind15041);
sz=this.size();
this.state._fsp--;
break;
}
if (ab != null) {
var   aax = aa.charAt(aa.length()-1);
var   abx = ab.charAt(ab.length()-1);
if (aax=='u' || aax=='d') {
if (abx=='l' || abx=='r') {
aa = aa + abx;
}
}
}
ake.setAttribute("arc", aa);
hBuilder.checkedSetAttr(ake, "arc_size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2033:1: zigzag[zze] : ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? ) ;
// $ANTLR start "zigzag"
zigzag: function(zze) {
var sz = null;
var ed = null;
var  style   = null;
try {
// Ham4HMLGen.g:2040:5: ( ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? ) )
// Ham4HMLGen.g:2041:5: ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? )
// Ham4HMLGen.g:2041:5: ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? )
// Ham4HMLGen.g:2042:9: ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )?
// Ham4HMLGen.g:2042:9: ( HamZigzag | HamWavy )
var alt154=2;
var LA154_0 = this.input.LA(1);
if ( (LA154_0==HamZigzag) ) {
alt154=1;
}
else if ( (LA154_0==HamWavy) ) {
alt154=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 154, 0, this.input);
throw nvae;
}
switch (alt154) {
case 1 :
// Ham4HMLGen.g:2043:19: HamZigzag
this.match(this.input,HamZigzag,Ham4HMLGen.FOLLOW_HamZigzag_in_zigzag15124); 
style = "ham_zigzag"; 
break;
case 2 :
// Ham4HMLGen.g:2045:19: HamWavy
this.match(this.input,HamWavy,Ham4HMLGen.FOLLOW_HamWavy_in_zigzag15160); 
style = "ham_wavy"; 
break;
}
// Ham4HMLGen.g:2047:9: (sz= size )?
var alt155=2;
var LA155_0 = this.input.LA(1);
if ( ((LA155_0>=HamSmallmod && LA155_0<=HamLargemod)) ) {
alt155=1;
}
switch (alt155) {
case 1 :
// Ham4HMLGen.g:2047:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_zigzag15197);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2048:9: (ed= ellipsedirection )?
var alt156=2;
var LA156_0 = this.input.LA(1);
if ( ((LA156_0>=HamEllipseh && LA156_0<=HamEllipseul)) ) {
alt156=1;
}
switch (alt156) {
case 1 :
// Ham4HMLGen.g:2048:11: ed= ellipsedirection
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_zigzag15219);
ed=this.ellipsedirection();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2049:9: ( sizechangenonlinear[zze] )?
var alt157=2;
var LA157_0 = this.input.LA(1);
if ( ((LA157_0>=HamIncreasing && LA157_0<=HamDecreasing)) ) {
alt157=1;
}
switch (alt157) {
case 1 :
// Ham4HMLGen.g:2049:19: sizechangenonlinear[zze]
this.pushFollow(Ham4HMLGen.FOLLOW_sizechangenonlinear_in_zigzag15242);
this.sizechangenonlinear(zze);
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(zze, "zigzagstyle", style);
hBuilder.checkedSetAttr(zze, "zigzag_size", sz);
hBuilder.checkedSetAttr(zze, "ellipsedirection", ed);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2058:1: sizechangenonlinear[sce] : (sc= sizechange (sz= size )? ) ;
// $ANTLR start "sizechangenonlinear"
sizechangenonlinear: function(sce) {
var sc = null;
var sz = null;
try {
// Ham4HMLGen.g:2062:5: ( (sc= sizechange (sz= size )? ) )
// Ham4HMLGen.g:2063:5: (sc= sizechange (sz= size )? )
// Ham4HMLGen.g:2063:5: (sc= sizechange (sz= size )? )
// Ham4HMLGen.g:2064:9: sc= sizechange (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_sizechangenonlinear15306);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:2065:9: (sz= size )?
var alt158=2;
var LA158_0 = this.input.LA(1);
if ( ((LA158_0>=HamSmallmod && LA158_0<=HamLargemod)) ) {
alt158=1;
}
switch (alt158) {
case 1 :
// Ham4HMLGen.g:2065:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_sizechangenonlinear15325);
sz=this.size();
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(sce, "incrdecr", sc);
hBuilder.checkedSetAttr(sce, "incrdecr_size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2073:1: fullcircularmovement returns [Element rfcm = null] : (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? ) ;
// $ANTLR start "fullcircularmovement"
fullcircularmovement: function() {
var rfcm =  null;
var fcm = null;
var sz = null;
var el = null;
try {
// Ham4HMLGen.g:2077:5: ( (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? ) )
// Ham4HMLGen.g:2078:5: (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? )
// Ham4HMLGen.g:2078:5: (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? )
// Ham4HMLGen.g:2079:9: fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )?
this.pushFollow(Ham4HMLGen.FOLLOW_circularmovement_in_fullcircularmovement15388);
fcm=this.circularmovement();
this.state._fsp--;
rfcm = fcm; 
// Ham4HMLGen.g:2080:9: (sz= size )?
var alt159=2;
var LA159_0 = this.input.LA(1);
if ( ((LA159_0>=HamSmallmod && LA159_0<=HamLargemod)) ) {
alt159=1;
}
switch (alt159) {
case 1 :
// Ham4HMLGen.g:2080:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullcircularmovement15413);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2081:9: ( revolutions[rfcm] )?
var alt160=2;
var LA160_0 = this.input.LA(1);
if ( ((LA160_0>=HamClocku && LA160_0<=HamClockfull)) ) {
alt160=1;
}
switch (alt160) {
case 1 :
// Ham4HMLGen.g:2081:19: revolutions[rfcm]
this.pushFollow(Ham4HMLGen.FOLLOW_revolutions_in_fullcircularmovement15436);
this.revolutions(rfcm);
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2082:9: (el= ellipse )?
var alt161=2;
var LA161_0 = this.input.LA(1);
if ( ((LA161_0>=HamEllipseh && LA161_0<=HamEllipseul)) ) {
alt161=1;
}
switch (alt161) {
case 1 :
// Ham4HMLGen.g:2082:11: el= ellipse
this.pushFollow(Ham4HMLGen.FOLLOW_ellipse_in_fullcircularmovement15459);
el=this.ellipse();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2083:9: ( sizechangenonlinear[rfcm] )?
var alt162=2;
var LA162_0 = this.input.LA(1);
if ( ((LA162_0>=HamIncreasing && LA162_0<=HamDecreasing)) ) {
alt162=1;
}
switch (alt162) {
case 1 :
// Ham4HMLGen.g:2083:19: sizechangenonlinear[rfcm]
this.pushFollow(Ham4HMLGen.FOLLOW_sizechangenonlinear_in_fullcircularmovement15482);
this.sizechangenonlinear(rfcm);
this.state._fsp--;
break;
}
hBuilder.checkedAppendChild(rfcm, el);
hBuilder.checkedSetAttr(rfcm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfcm;
},
// Ham4HMLGen.g:2091:1: circularmovement returns [Element rcm = null] : ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? ) ;
// $ANTLR start "circularmovement"
circularmovement: function() {
var rcm =  null;
var mca = null;
var mcb = null;
try {
// Ham4HMLGen.g:2094:5: ( ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? ) )
// Ham4HMLGen.g:2095:5: ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? )
this.match(this.input,CRCLRMVMT,Ham4HMLGen.FOLLOW_CRCLRMVMT_in_circularmovement15529); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_movementcircle_in_circularmovement15547);
mca=this.movementcircle();
this.state._fsp--;
// Ham4HMLGen.g:2097:9: (mcb= movementcircle )?
var alt163=2;
var LA163_0 = this.input.LA(1);
if ( ((LA163_0>=HamCircleo && LA163_0<=HamCircler)||(LA163_0>=HamCircleul && LA163_0<=HamCircleuo)) ) {
alt163=1;
}
switch (alt163) {
case 1 :
// Ham4HMLGen.g:2097:11: mcb= movementcircle
this.pushFollow(Ham4HMLGen.FOLLOW_movementcircle_in_circularmovement15565);
mcb=this.movementcircle();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcm = hBuilder.newHMLElement("circularmovement");
hBuilder.checkedSetAttr(rcm, "movement", mca);
hBuilder.checkedSetAttr(rcm, "second_movement", mcb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcm;
},
// Ham4HMLGen.g:2106:1: ellipse returns [Element rell = null] : (ed= ellipsedirection (sz= size )? ) ;
// $ANTLR start "ellipse"
ellipse: function() {
var rell =  null;
var ed = null;
var sz = null;
try {
// Ham4HMLGen.g:2110:5: ( (ed= ellipsedirection (sz= size )? ) )
// Ham4HMLGen.g:2111:5: (ed= ellipsedirection (sz= size )? )
// Ham4HMLGen.g:2111:5: (ed= ellipsedirection (sz= size )? )
// Ham4HMLGen.g:2112:9: ed= ellipsedirection (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_ellipse15634);
ed=this.ellipsedirection();
this.state._fsp--;
// Ham4HMLGen.g:2113:9: (sz= size )?
var alt164=2;
var LA164_0 = this.input.LA(1);
if ( ((LA164_0>=HamSmallmod && LA164_0<=HamLargemod)) ) {
alt164=1;
}
switch (alt164) {
case 1 :
// Ham4HMLGen.g:2113:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_ellipse15653);
sz=this.size();
this.state._fsp--;
break;
}
rell = hBuilder.newHMLElement("ellipse");
hBuilder.checkedSetAttr(rell, "ellipsedirection", ed);
hBuilder.checkedSetAttr(rell, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rell;
},
// Ham4HMLGen.g:2122:1: revolutions[reve] : ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? ) ;
// $ANTLR start "revolutions"
revolutions: function(reve) {
var cs = null;
var ce = null;
var cfa = false;
var cfb = false;
try {
// Ham4HMLGen.g:2130:5: ( ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? ) )
// Ham4HMLGen.g:2131:5: ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? )
// Ham4HMLGen.g:2131:5: ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? )
// Ham4HMLGen.g:2132:9: (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )?
// Ham4HMLGen.g:2132:9: (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? )
var alt168=2;
var LA168_0 = this.input.LA(1);
if ( ((LA168_0>=HamClocku && LA168_0<=HamClockur)) ) {
alt168=1;
}
else if ( (LA168_0==HamClockfull) ) {
alt168=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 168, 0, this.input);
throw nvae;
}
switch (alt168) {
case 1 :
// Ham4HMLGen.g:2133:13: cs= clock ( HamClockfull ( HamClockfull )? )?
this.pushFollow(Ham4HMLGen.FOLLOW_clock_in_revolutions15734);
cs=this.clock();
this.state._fsp--;
// Ham4HMLGen.g:2134:13: ( HamClockfull ( HamClockfull )? )?
var alt166=2;
var LA166_0 = this.input.LA(1);
if ( (LA166_0==HamClockfull) ) {
alt166=1;
}
switch (alt166) {
case 1 :
// Ham4HMLGen.g:2135:17: HamClockfull ( HamClockfull )?
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15766); 
cfa = true; 
// Ham4HMLGen.g:2136:17: ( HamClockfull )?
var alt165=2;
var LA165_0 = this.input.LA(1);
if ( (LA165_0==HamClockfull) ) {
alt165=1;
}
switch (alt165) {
case 1 :
// Ham4HMLGen.g:2136:19: HamClockfull
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15795); 
cfb = true; 
break;
}
break;
}
break;
case 2 :
// Ham4HMLGen.g:2139:13: HamClockfull ( HamClockfull )?
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15844); 
cfa = true; 
// Ham4HMLGen.g:2140:13: ( HamClockfull )?
var alt167=2;
var LA167_0 = this.input.LA(1);
if ( (LA167_0==HamClockfull) ) {
alt167=1;
}
switch (alt167) {
case 1 :
// Ham4HMLGen.g:2140:15: HamClockfull
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15873); 
cfb = true; 
break;
}
break;
}
// Ham4HMLGen.g:2142:9: (ce= clock )?
var alt169=2;
var LA169_0 = this.input.LA(1);
if ( ((LA169_0>=HamClocku && LA169_0<=HamClockur)) ) {
alt169=1;
}
switch (alt169) {
case 1 :
// Ham4HMLGen.g:2142:13: ce= clock
this.pushFollow(Ham4HMLGen.FOLLOW_clock_in_revolutions15920);
ce=this.clock();
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(reve, "start", cs);
if (cfa) {
hBuilder.checkedSetAttr(reve, "clockfull", "true");
if (cfb) {
hBuilder.checkedSetAttr(reve, "second_clockfull", "true");
}
}
hBuilder.checkedSetAttr(reve, "end", ce);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2156:1: fullwristmovement returns [Element rfwm = null] : (wm= wristmovement (sz= size )? ) ;
// $ANTLR start "fullwristmovement"
fullwristmovement: function() {
var rfwm =  null;
var wm = null;
var sz = null;
try {
// Ham4HMLGen.g:2159:5: ( (wm= wristmovement (sz= size )? ) )
// Ham4HMLGen.g:2160:5: (wm= wristmovement (sz= size )? )
// Ham4HMLGen.g:2160:5: (wm= wristmovement (sz= size )? )
// Ham4HMLGen.g:2161:9: wm= wristmovement (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_wristmovement_in_fullwristmovement15983);
wm=this.wristmovement();
this.state._fsp--;
// Ham4HMLGen.g:2162:9: (sz= size )?
var alt170=2;
var LA170_0 = this.input.LA(1);
if ( ((LA170_0>=HamSmallmod && LA170_0<=HamLargemod)) ) {
alt170=1;
}
switch (alt170) {
case 1 :
// Ham4HMLGen.g:2162:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullwristmovement16002);
sz=this.size();
this.state._fsp--;
break;
}
rfwm = hBuilder.newHMLElement("wristmovement");
hBuilder.checkedSetAttr(rfwm, "movement", wm);
hBuilder.checkedSetAttr(rfwm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfwm;
},
// Ham4HMLGen.g:2171:1: fullmovementcross returns [Element rfmc = null] : (smc= movementcross (sz= size )? ) ;
// $ANTLR start "fullmovementcross"
fullmovementcross: function() {
var rfmc =  null;
var smc = null;
var sz = null;
try {
// Ham4HMLGen.g:2175:5: ( (smc= movementcross (sz= size )? ) )
// Ham4HMLGen.g:2176:5: (smc= movementcross (sz= size )? )
// Ham4HMLGen.g:2176:5: (smc= movementcross (sz= size )? )
// Ham4HMLGen.g:2177:9: smc= movementcross (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_movementcross_in_fullmovementcross16065);
smc=this.movementcross();
this.state._fsp--;
// Ham4HMLGen.g:2178:9: (sz= size )?
var alt171=2;
var LA171_0 = this.input.LA(1);
if ( ((LA171_0>=HamSmallmod && LA171_0<=HamLargemod)) ) {
alt171=1;
}
switch (alt171) {
case 1 :
// Ham4HMLGen.g:2178:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullmovementcross16084);
sz=this.size();
this.state._fsp--;
break;
}
rfmc = hBuilder.newHMLElement("movementcross");
hBuilder.checkedSetAttr(rfmc, "movementcross", smc);
hBuilder.checkedSetAttr(rfmc, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfmc;
},
// Ham4HMLGen.g:2188:1: replacement returns [Element rr = null] : ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? ) ;
// $ANTLR start "replacement"
replacement: function() {
var rr =  null;
var sc = null;
var hs = null;
var srt = null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:2191:5: ( ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? ) )
// Ham4HMLGen.g:2192:5: ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? )
this.match(this.input,REPLACE,Ham4HMLGen.FOLLOW_REPLACE_in_replacement16144); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:2193:9: (sc= sizechange )?
var alt172=2;
var LA172_0 = this.input.LA(1);
if ( ((LA172_0>=HamIncreasing && LA172_0<=HamDecreasing)) ) {
alt172=1;
}
switch (alt172) {
case 1 :
// Ham4HMLGen.g:2193:11: sc= sizechange
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_replacement16163);
sc=this.sizechange();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2194:9: (hs= handshape1 )?
var alt173=2;
var LA173_0 = this.input.LA(1);
if ( (LA173_0==HSHAPE1) ) {
alt173=1;
}
switch (alt173) {
case 1 :
// Ham4HMLGen.g:2194:11: hs= handshape1
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_replacement16185);
hs=this.handshape1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2195:9: (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )?
var alt175=4;
switch ( this.input.LA(1) ) {
case SPLITREPLACETL:
alt175=1;
break;
case EXTFIDIR1:
alt175=2;
break;
case PALMOR1:
alt175=3;
break;
}
switch (alt175) {
case 1 :
// Ham4HMLGen.g:2196:13: srt= splitreplacetail
this.pushFollow(Ham4HMLGen.FOLLOW_splitreplacetail_in_replacement16220);
srt=this.splitreplacetail();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:2198:13: efd= extfidir1 (po= palmor1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_replacement16252);
efd=this.extfidir1();
this.state._fsp--;
// Ham4HMLGen.g:2199:13: (po= palmor1 )?
var alt174=2;
var LA174_0 = this.input.LA(1);
if ( (LA174_0==PALMOR1) ) {
alt174=1;
}
switch (alt174) {
case 1 :
// Ham4HMLGen.g:2199:15: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacement16275);
po=this.palmor1();
this.state._fsp--;
break;
}
break;
case 3 :
// Ham4HMLGen.g:2201:13: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacement16311);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rr = hBuilder.newHMLElement("replacement");
hBuilder.checkedSetAttr(rr, "replace_incrdecr", sc);
hBuilder.checkedAppendChild(rr, hs);
if (srt == null) {
hBuilder.checkedAppendChild(rr, efd);
hBuilder.checkedAppendChild(rr, po);
}
else {
rr.appendChild(srt);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rr;
},
// Ham4HMLGen.g:2218:1: splitreplacetail returns [Element rsrt = null] : ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? ) ;
// $ANTLR start "splitreplacetail"
splitreplacetail: function() {
var rsrt =  null;
var drt = null;
var srt = null;
try {
// Ham4HMLGen.g:2221:5: ( ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? ) )
// Ham4HMLGen.g:2222:5: ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? )
this.match(this.input,SPLITREPLACETL,Ham4HMLGen.FOLLOW_SPLITREPLACETL_in_splitreplacetail16365); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_replacetail1_in_splitreplacetail16383);
drt=this.replacetail1();
this.state._fsp--;
// Ham4HMLGen.g:2224:9: (srt= replacetail1 )?
var alt176=2;
var LA176_0 = this.input.LA(1);
if ( (LA176_0==REPLACETAIL1) ) {
alt176=1;
}
switch (alt176) {
case 1 :
// Ham4HMLGen.g:2224:11: srt= replacetail1
this.pushFollow(Ham4HMLGen.FOLLOW_replacetail1_in_splitreplacetail16401);
srt=this.replacetail1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsrt = hBuilder.newHMLElement("splitreplacetail");
hBuilder.checkedAppendChild(rsrt, drt);
hBuilder.checkedAppendChild(rsrt, srt);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsrt;
},
// Ham4HMLGen.g:2233:1: replacetail1 returns [Element rrt = null] : ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) ) ;
// $ANTLR start "replacetail1"
replacetail1: function() {
var rrt =  null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:2236:5: ( ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) ) )
// Ham4HMLGen.g:2237:5: ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) )
this.match(this.input,REPLACETAIL1,Ham4HMLGen.FOLLOW_REPLACETAIL1_in_replacetail116451); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:2238:9: ( (efd= extfidir1 )? (po= palmor1 )? )
// Ham4HMLGen.g:2239:13: (efd= extfidir1 )? (po= palmor1 )?
// Ham4HMLGen.g:2239:13: (efd= extfidir1 )?
var alt177=2;
var LA177_0 = this.input.LA(1);
if ( (LA177_0==EXTFIDIR1) ) {
alt177=1;
}
switch (alt177) {
case 1 :
// Ham4HMLGen.g:2239:15: efd= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_replacetail116483);
efd=this.extfidir1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2240:13: (po= palmor1 )?
var alt178=2;
var LA178_0 = this.input.LA(1);
if ( (LA178_0==PALMOR1) ) {
alt178=1;
}
switch (alt178) {
case 1 :
// Ham4HMLGen.g:2240:15: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacetail116509);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rrt = hBuilder.newHMLElement("replacetail1");
hBuilder.checkedAppendChild(rrt, efd);
hBuilder.checkedAppendChild(rrt, po);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rrt;
},
// Ham4HMLGen.g:2253:1: repetition returns [String rr = null] : ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse ) ;
// $ANTLR start "repetition"
repetition: function() {
var rr =  null;
try {
// Ham4HMLGen.g:2255:5: ( ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse ) )
// Ham4HMLGen.g:2256:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
// Ham4HMLGen.g:2256:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
var alt179=5;
switch ( this.input.LA(1) ) {
case HamRepeatfromstart:
alt179=1;
break;
case HamRepeatfromstartseveral:
alt179=2;
break;
case HamRepeatcontinue:
alt179=3;
break;
case HamRepeatcontinueseveral:
alt179=4;
break;
case HamRepeatreverse:
alt179=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 179, 0, this.input);
throw nvae;
}
switch (alt179) {
case 1 :
// Ham4HMLGen.g:2256:9: HamRepeatfromstart
this.match(this.input,HamRepeatfromstart,Ham4HMLGen.FOLLOW_HamRepeatfromstart_in_repetition16573); 
rr = "ham_repeat_fromstart"; 
break;
case 2 :
// Ham4HMLGen.g:2257:9: HamRepeatfromstartseveral
this.match(this.input,HamRepeatfromstartseveral,Ham4HMLGen.FOLLOW_HamRepeatfromstartseveral_in_repetition16586); 
rr = "ham_repeat_fromstartseveral"; 
break;
case 3 :
// Ham4HMLGen.g:2259:9: HamRepeatcontinue
this.match(this.input,HamRepeatcontinue,Ham4HMLGen.FOLLOW_HamRepeatcontinue_in_repetition16626); 
rr = "ham_repeat_continue"; 
break;
case 4 :
// Ham4HMLGen.g:2260:9: HamRepeatcontinueseveral
this.match(this.input,HamRepeatcontinueseveral,Ham4HMLGen.FOLLOW_HamRepeatcontinueseveral_in_repetition16640); 
rr = "ham_repeat_continueseveral"; 
break;
case 5 :
// Ham4HMLGen.g:2262:9: HamRepeatreverse
this.match(this.input,HamRepeatreverse,Ham4HMLGen.FOLLOW_HamRepeatreverse_in_repetition16680); 
rr = "ham_repeat_reverse"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rr;
},
// Ham4HMLGen.g:2266:1: movementarrow returns [String rma = null] : ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo ) ;
// $ANTLR start "movementarrow"
movementarrow: function() {
var rma =  null;
try {
// Ham4HMLGen.g:2268:5: ( ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo ) )
// Ham4HMLGen.g:2269:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
// Ham4HMLGen.g:2269:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
var alt180=18;
switch ( this.input.LA(1) ) {
case HamMoveu:
alt180=1;
break;
case HamMoveur:
alt180=2;
break;
case HamMover:
alt180=3;
break;
case HamMovedr:
alt180=4;
break;
case HamMoved:
alt180=5;
break;
case HamMovedl:
alt180=6;
break;
case HamMovel:
alt180=7;
break;
case HamMoveul:
alt180=8;
break;
case HamMoveol:
alt180=9;
break;
case HamMoveo:
alt180=10;
break;
case HamMoveor:
alt180=11;
break;
case HamMoveil:
alt180=12;
break;
case HamMovei:
alt180=13;
break;
case HamMoveir:
alt180=14;
break;
case HamMoveui:
alt180=15;
break;
case HamMovedi:
alt180=16;
break;
case HamMovedo:
alt180=17;
break;
case HamMoveuo:
alt180=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 180, 0, this.input);
throw nvae;
}
switch (alt180) {
case 1 :
// Ham4HMLGen.g:2269:9: HamMoveu
this.match(this.input,HamMoveu,Ham4HMLGen.FOLLOW_HamMoveu_in_movementarrow16724); 
rma = "u"; 
break;
case 2 :
// Ham4HMLGen.g:2270:9: HamMoveur
this.match(this.input,HamMoveur,Ham4HMLGen.FOLLOW_HamMoveur_in_movementarrow16747); 
rma = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:2271:9: HamMover
this.match(this.input,HamMover,Ham4HMLGen.FOLLOW_HamMover_in_movementarrow16769); 
rma = "r"; 
break;
case 4 :
// Ham4HMLGen.g:2272:9: HamMovedr
this.match(this.input,HamMovedr,Ham4HMLGen.FOLLOW_HamMovedr_in_movementarrow16792); 
rma = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:2273:9: HamMoved
this.match(this.input,HamMoved,Ham4HMLGen.FOLLOW_HamMoved_in_movementarrow16814); 
rma = "d"; 
break;
case 6 :
// Ham4HMLGen.g:2274:9: HamMovedl
this.match(this.input,HamMovedl,Ham4HMLGen.FOLLOW_HamMovedl_in_movementarrow16837); 
rma = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:2275:9: HamMovel
this.match(this.input,HamMovel,Ham4HMLGen.FOLLOW_HamMovel_in_movementarrow16859); 
rma = "l"; 
break;
case 8 :
// Ham4HMLGen.g:2276:9: HamMoveul
this.match(this.input,HamMoveul,Ham4HMLGen.FOLLOW_HamMoveul_in_movementarrow16882); 
rma = "ul"; 
break;
case 9 :
// Ham4HMLGen.g:2277:9: HamMoveol
this.match(this.input,HamMoveol,Ham4HMLGen.FOLLOW_HamMoveol_in_movementarrow16904); 
rma = "ol"; 
break;
case 10 :
// Ham4HMLGen.g:2278:9: HamMoveo
this.match(this.input,HamMoveo,Ham4HMLGen.FOLLOW_HamMoveo_in_movementarrow16926); 
rma = "o"; 
break;
case 11 :
// Ham4HMLGen.g:2279:9: HamMoveor
this.match(this.input,HamMoveor,Ham4HMLGen.FOLLOW_HamMoveor_in_movementarrow16949); 
rma = "or"; 
break;
case 12 :
// Ham4HMLGen.g:2280:9: HamMoveil
this.match(this.input,HamMoveil,Ham4HMLGen.FOLLOW_HamMoveil_in_movementarrow16971); 
rma = "il"; 
break;
case 13 :
// Ham4HMLGen.g:2281:9: HamMovei
this.match(this.input,HamMovei,Ham4HMLGen.FOLLOW_HamMovei_in_movementarrow16993); 
rma = "i"; 
break;
case 14 :
// Ham4HMLGen.g:2282:9: HamMoveir
this.match(this.input,HamMoveir,Ham4HMLGen.FOLLOW_HamMoveir_in_movementarrow17016); 
rma = "ir"; 
break;
case 15 :
// Ham4HMLGen.g:2283:9: HamMoveui
this.match(this.input,HamMoveui,Ham4HMLGen.FOLLOW_HamMoveui_in_movementarrow17038); 
rma = "ui"; 
break;
case 16 :
// Ham4HMLGen.g:2284:9: HamMovedi
this.match(this.input,HamMovedi,Ham4HMLGen.FOLLOW_HamMovedi_in_movementarrow17060); 
rma = "di"; 
break;
case 17 :
// Ham4HMLGen.g:2285:9: HamMovedo
this.match(this.input,HamMovedo,Ham4HMLGen.FOLLOW_HamMovedo_in_movementarrow17082); 
rma = "do"; 
break;
case 18 :
// Ham4HMLGen.g:2286:9: HamMoveuo
this.match(this.input,HamMoveuo,Ham4HMLGen.FOLLOW_HamMoveuo_in_movementarrow17104); 
rma = "uo"; 
break;
}
rma = "ham_move_" + rma;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rma;
},
// Ham4HMLGen.g:2293:1: movementcross returns [String rmc = null] : ( HamMovecross | HamMovex ) ;
// $ANTLR start "movementcross"
movementcross: function() {
var rmc =  null;
try {
// Ham4HMLGen.g:2295:5: ( ( HamMovecross | HamMovex ) )
// Ham4HMLGen.g:2296:5: ( HamMovecross | HamMovex )
// Ham4HMLGen.g:2296:5: ( HamMovecross | HamMovex )
var alt181=2;
var LA181_0 = this.input.LA(1);
if ( (LA181_0==HamMovecross) ) {
alt181=1;
}
else if ( (LA181_0==HamMovex) ) {
alt181=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 181, 0, this.input);
throw nvae;
}
switch (alt181) {
case 1 :
// Ham4HMLGen.g:2296:9: HamMovecross
this.match(this.input,HamMovecross,Ham4HMLGen.FOLLOW_HamMovecross_in_movementcross17161); 
rmc = "ham_move_cross"; 
break;
case 2 :
// Ham4HMLGen.g:2297:9: HamMovex
this.match(this.input,HamMovex,Ham4HMLGen.FOLLOW_HamMovex_in_movementcross17180); 
rmc = "ham_move_x"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmc;
},
// Ham4HMLGen.g:2301:1: wristmovement returns [String rwm = null] : ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw ) ;
// $ANTLR start "wristmovement"
wristmovement: function() {
var rwm =  null;
try {
// Ham4HMLGen.g:2303:5: ( ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw ) )
// Ham4HMLGen.g:2304:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
// Ham4HMLGen.g:2304:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
var alt182=5;
switch ( this.input.LA(1) ) {
case HamNodding:
alt182=1;
break;
case HamSwinging:
alt182=2;
break;
case HamTwisting:
alt182=3;
break;
case HamStircw:
alt182=4;
break;
case HamStirccw:
alt182=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 182, 0, this.input);
throw nvae;
}
switch (alt182) {
case 1 :
// Ham4HMLGen.g:2304:9: HamNodding
this.match(this.input,HamNodding,Ham4HMLGen.FOLLOW_HamNodding_in_wristmovement17232); 
rwm = "ham_wrist_nodding"; 
break;
case 2 :
// Ham4HMLGen.g:2305:9: HamSwinging
this.match(this.input,HamSwinging,Ham4HMLGen.FOLLOW_HamSwinging_in_wristmovement17253); 
rwm = "ham_wrist_swinging"; 
break;
case 3 :
// Ham4HMLGen.g:2306:9: HamTwisting
this.match(this.input,HamTwisting,Ham4HMLGen.FOLLOW_HamTwisting_in_wristmovement17273); 
rwm = "ham_wrist_twisting"; 
break;
case 4 :
// Ham4HMLGen.g:2307:9: HamStircw
this.match(this.input,HamStircw,Ham4HMLGen.FOLLOW_HamStircw_in_wristmovement17293); 
rwm = "ham_wrist_stircw"; 
break;
case 5 :
// Ham4HMLGen.g:2308:9: HamStirccw
this.match(this.input,HamStirccw,Ham4HMLGen.FOLLOW_HamStirccw_in_wristmovement17315); 
rwm = "ham_wrist_stirccw"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rwm;
},
// Ham4HMLGen.g:2312:1: movementcircle returns [String rmc = null] : ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo ) ;
// $ANTLR start "movementcircle"
movementcircle: function() {
var rmc =  null;
try {
// Ham4HMLGen.g:2316:5: ( ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo ) )
// Ham4HMLGen.g:2317:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
// Ham4HMLGen.g:2317:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
var alt183=18;
switch ( this.input.LA(1) ) {
case HamCircleo:
alt183=1;
break;
case HamCirclei:
alt183=2;
break;
case HamCircled:
alt183=3;
break;
case HamCircleu:
alt183=4;
break;
case HamCirclel:
alt183=5;
break;
case HamCircler:
alt183=6;
break;
case HamCircleul:
alt183=7;
break;
case HamCircledr:
alt183=8;
break;
case HamCircleur:
alt183=9;
break;
case HamCircledl:
alt183=10;
break;
case HamCircleol:
alt183=11;
break;
case HamCircleir:
alt183=12;
break;
case HamCircleor:
alt183=13;
break;
case HamCircleil:
alt183=14;
break;
case HamCircleui:
alt183=15;
break;
case HamCircledo:
alt183=16;
break;
case HamCircledi:
alt183=17;
break;
case HamCircleuo:
alt183=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 183, 0, this.input);
throw nvae;
}
switch (alt183) {
case 1 :
// Ham4HMLGen.g:2317:9: HamCircleo
this.match(this.input,HamCircleo,Ham4HMLGen.FOLLOW_HamCircleo_in_movementcircle17364); 
rmc = "o"; 
break;
case 2 :
// Ham4HMLGen.g:2318:9: HamCirclei
this.match(this.input,HamCirclei,Ham4HMLGen.FOLLOW_HamCirclei_in_movementcircle17385); 
rmc = "i"; 
break;
case 3 :
// Ham4HMLGen.g:2319:9: HamCircled
this.match(this.input,HamCircled,Ham4HMLGen.FOLLOW_HamCircled_in_movementcircle17406); 
rmc = "d"; 
break;
case 4 :
// Ham4HMLGen.g:2320:9: HamCircleu
this.match(this.input,HamCircleu,Ham4HMLGen.FOLLOW_HamCircleu_in_movementcircle17427); 
rmc = "u"; 
break;
case 5 :
// Ham4HMLGen.g:2321:9: HamCirclel
this.match(this.input,HamCirclel,Ham4HMLGen.FOLLOW_HamCirclel_in_movementcircle17448); 
rmc = "l"; 
break;
case 6 :
// Ham4HMLGen.g:2322:9: HamCircler
this.match(this.input,HamCircler,Ham4HMLGen.FOLLOW_HamCircler_in_movementcircle17469); 
rmc = "r"; 
break;
case 7 :
// Ham4HMLGen.g:2323:9: HamCircleul
this.match(this.input,HamCircleul,Ham4HMLGen.FOLLOW_HamCircleul_in_movementcircle17490); 
rmc = "ul"; 
break;
case 8 :
// Ham4HMLGen.g:2324:9: HamCircledr
this.match(this.input,HamCircledr,Ham4HMLGen.FOLLOW_HamCircledr_in_movementcircle17510); 
rmc = "dr"; 
break;
case 9 :
// Ham4HMLGen.g:2325:9: HamCircleur
this.match(this.input,HamCircleur,Ham4HMLGen.FOLLOW_HamCircleur_in_movementcircle17530); 
rmc = "ur"; 
break;
case 10 :
// Ham4HMLGen.g:2326:9: HamCircledl
this.match(this.input,HamCircledl,Ham4HMLGen.FOLLOW_HamCircledl_in_movementcircle17550); 
rmc = "dl"; 
break;
case 11 :
// Ham4HMLGen.g:2327:9: HamCircleol
this.match(this.input,HamCircleol,Ham4HMLGen.FOLLOW_HamCircleol_in_movementcircle17570); 
rmc = "ol"; 
break;
case 12 :
// Ham4HMLGen.g:2328:9: HamCircleir
this.match(this.input,HamCircleir,Ham4HMLGen.FOLLOW_HamCircleir_in_movementcircle17590); 
rmc = "ir"; 
break;
case 13 :
// Ham4HMLGen.g:2329:9: HamCircleor
this.match(this.input,HamCircleor,Ham4HMLGen.FOLLOW_HamCircleor_in_movementcircle17610); 
rmc = "or"; 
break;
case 14 :
// Ham4HMLGen.g:2330:9: HamCircleil
this.match(this.input,HamCircleil,Ham4HMLGen.FOLLOW_HamCircleil_in_movementcircle17630); 
rmc = "il"; 
break;
case 15 :
// Ham4HMLGen.g:2331:9: HamCircleui
this.match(this.input,HamCircleui,Ham4HMLGen.FOLLOW_HamCircleui_in_movementcircle17650); 
rmc = "ui"; 
break;
case 16 :
// Ham4HMLGen.g:2332:9: HamCircledo
this.match(this.input,HamCircledo,Ham4HMLGen.FOLLOW_HamCircledo_in_movementcircle17670); 
rmc = "do"; 
break;
case 17 :
// Ham4HMLGen.g:2333:9: HamCircledi
this.match(this.input,HamCircledi,Ham4HMLGen.FOLLOW_HamCircledi_in_movementcircle17690); 
rmc = "di"; 
break;
case 18 :
// Ham4HMLGen.g:2334:9: HamCircleuo
this.match(this.input,HamCircleuo,Ham4HMLGen.FOLLOW_HamCircleuo_in_movementcircle17710); 
rmc = "uo"; 
break;
}
rmc = "ham_circle_" + rmc;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmc;
},
// Ham4HMLGen.g:2341:1: ellipsedirection returns [String red = null] : ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul ) ;
// $ANTLR start "ellipsedirection"
ellipsedirection: function() {
var red =  null;
try {
// Ham4HMLGen.g:2345:5: ( ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul ) )
// Ham4HMLGen.g:2346:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
// Ham4HMLGen.g:2346:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
var alt184=4;
switch ( this.input.LA(1) ) {
case HamEllipseh:
alt184=1;
break;
case HamEllipseur:
alt184=2;
break;
case HamEllipsev:
alt184=3;
break;
case HamEllipseul:
alt184=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);
throw nvae;
}
switch (alt184) {
case 1 :
// Ham4HMLGen.g:2346:9: HamEllipseh
this.match(this.input,HamEllipseh,Ham4HMLGen.FOLLOW_HamEllipseh_in_ellipsedirection17766); 
red = "h"; 
break;
case 2 :
// Ham4HMLGen.g:2347:9: HamEllipseur
this.match(this.input,HamEllipseur,Ham4HMLGen.FOLLOW_HamEllipseur_in_ellipsedirection17786); 
red = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:2348:9: HamEllipsev
this.match(this.input,HamEllipsev,Ham4HMLGen.FOLLOW_HamEllipsev_in_ellipsedirection17805); 
red = "v"; 
break;
case 4 :
// Ham4HMLGen.g:2349:9: HamEllipseul
this.match(this.input,HamEllipseul,Ham4HMLGen.FOLLOW_HamEllipseul_in_ellipsedirection17825); 
red = "ul"; 
break;
}
red = "ham_ellipse_" + red;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return red;
},
// Ham4HMLGen.g:2356:1: clock returns [String rclk = null] : ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur ) ;
// $ANTLR start "clock"
clock: function() {
var rclk =  null;
try {
// Ham4HMLGen.g:2360:5: ( ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur ) )
// Ham4HMLGen.g:2361:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
// Ham4HMLGen.g:2361:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
var alt185=8;
switch ( this.input.LA(1) ) {
case HamClocku:
alt185=1;
break;
case HamClockul:
alt185=2;
break;
case HamClockl:
alt185=3;
break;
case HamClockdl:
alt185=4;
break;
case HamClockd:
alt185=5;
break;
case HamClockdr:
alt185=6;
break;
case HamClockr:
alt185=7;
break;
case HamClockur:
alt185=8;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 185, 0, this.input);
throw nvae;
}
switch (alt185) {
case 1 :
// Ham4HMLGen.g:2361:9: HamClocku
this.match(this.input,HamClocku,Ham4HMLGen.FOLLOW_HamClocku_in_clock17887); 
rclk = "u"; 
break;
case 2 :
// Ham4HMLGen.g:2362:9: HamClockul
this.match(this.input,HamClockul,Ham4HMLGen.FOLLOW_HamClockul_in_clock17909); 
rclk = "ul"; 
break;
case 3 :
// Ham4HMLGen.g:2363:9: HamClockl
this.match(this.input,HamClockl,Ham4HMLGen.FOLLOW_HamClockl_in_clock17930); 
rclk = "l"; 
break;
case 4 :
// Ham4HMLGen.g:2364:9: HamClockdl
this.match(this.input,HamClockdl,Ham4HMLGen.FOLLOW_HamClockdl_in_clock17952); 
rclk = "dl"; 
break;
case 5 :
// Ham4HMLGen.g:2365:9: HamClockd
this.match(this.input,HamClockd,Ham4HMLGen.FOLLOW_HamClockd_in_clock17973); 
rclk = "d"; 
break;
case 6 :
// Ham4HMLGen.g:2366:9: HamClockdr
this.match(this.input,HamClockdr,Ham4HMLGen.FOLLOW_HamClockdr_in_clock17995); 
rclk = "dr"; 
break;
case 7 :
// Ham4HMLGen.g:2367:9: HamClockr
this.match(this.input,HamClockr,Ham4HMLGen.FOLLOW_HamClockr_in_clock18016); 
rclk = "r"; 
break;
case 8 :
// Ham4HMLGen.g:2368:9: HamClockur
this.match(this.input,HamClockur,Ham4HMLGen.FOLLOW_HamClockur_in_clock18038); 
rclk = "ur"; 
break;
}
rclk = "ham_clock_" + rclk;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rclk;
},
// Ham4HMLGen.g:2375:1: modifier returns [String rmod = null] : ( HamFast | HamSlow | HamTense | HamRest | HamHalt ) ;
// $ANTLR start "modifier"
modifier: function() {
var rmod =  null;
try {
// Ham4HMLGen.g:2377:5: ( ( HamFast | HamSlow | HamTense | HamRest | HamHalt ) )
// Ham4HMLGen.g:2378:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
// Ham4HMLGen.g:2378:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
var alt186=5;
switch ( this.input.LA(1) ) {
case HamFast:
alt186=1;
break;
case HamSlow:
alt186=2;
break;
case HamTense:
alt186=3;
break;
case HamRest:
alt186=4;
break;
case HamHalt:
alt186=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 186, 0, this.input);
throw nvae;
}
switch (alt186) {
case 1 :
// Ham4HMLGen.g:2378:9: HamFast
this.match(this.input,HamFast,Ham4HMLGen.FOLLOW_HamFast_in_modifier18099); 
rmod = "ham_fast"; 
break;
case 2 :
// Ham4HMLGen.g:2379:9: HamSlow
this.match(this.input,HamSlow,Ham4HMLGen.FOLLOW_HamSlow_in_modifier18123); 
rmod = "ham_slow"; 
break;
case 3 :
// Ham4HMLGen.g:2380:9: HamTense
this.match(this.input,HamTense,Ham4HMLGen.FOLLOW_HamTense_in_modifier18147); 
rmod = "ham_tense"; 
break;
case 4 :
// Ham4HMLGen.g:2381:9: HamRest
this.match(this.input,HamRest,Ham4HMLGen.FOLLOW_HamRest_in_modifier18170); 
rmod = "ham_rest"; 
break;
case 5 :
// Ham4HMLGen.g:2382:9: HamHalt
this.match(this.input,HamHalt,Ham4HMLGen.FOLLOW_HamHalt_in_modifier18194); 
rmod = "ham_halt"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmod;
},
// Ham4HMLGen.g:2386:1: arc returns [String ra = null] : ( HamArcl | HamArcu | HamArcr | HamArcd ) ;
// $ANTLR start "arc"
arc: function() {
var ra =  null;
try {
// Ham4HMLGen.g:2388:5: ( ( HamArcl | HamArcu | HamArcr | HamArcd ) )
// Ham4HMLGen.g:2389:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
// Ham4HMLGen.g:2389:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
var alt187=4;
switch ( this.input.LA(1) ) {
case HamArcl:
alt187=1;
break;
case HamArcu:
alt187=2;
break;
case HamArcr:
alt187=3;
break;
case HamArcd:
alt187=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 187, 0, this.input);
throw nvae;
}
switch (alt187) {
case 1 :
// Ham4HMLGen.g:2389:9: HamArcl
this.match(this.input,HamArcl,Ham4HMLGen.FOLLOW_HamArcl_in_arc18257); 
ra = "ham_arc_l"; 
break;
case 2 :
// Ham4HMLGen.g:2390:9: HamArcu
this.match(this.input,HamArcu,Ham4HMLGen.FOLLOW_HamArcu_in_arc18281); 
ra = "ham_arc_u"; 
break;
case 3 :
// Ham4HMLGen.g:2391:9: HamArcr
this.match(this.input,HamArcr,Ham4HMLGen.FOLLOW_HamArcr_in_arc18305); 
ra = "ham_arc_r"; 
break;
case 4 :
// Ham4HMLGen.g:2392:9: HamArcd
this.match(this.input,HamArcd,Ham4HMLGen.FOLLOW_HamArcd_in_arc18329); 
ra = "ham_arc_d"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:2396:1: size returns [String rsz = null] : ( HamSmallmod | HamLargemod ) ;
// $ANTLR start "size"
size: function() {
var rsz =  null;
try {
// Ham4HMLGen.g:2400:5: ( ( HamSmallmod | HamLargemod ) )
// Ham4HMLGen.g:2401:5: ( HamSmallmod | HamLargemod )
// Ham4HMLGen.g:2401:5: ( HamSmallmod | HamLargemod )
var alt188=2;
var LA188_0 = this.input.LA(1);
if ( (LA188_0==HamSmallmod) ) {
alt188=1;
}
else if ( (LA188_0==HamLargemod) ) {
alt188=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 188, 0, this.input);
throw nvae;
}
switch (alt188) {
case 1 :
// Ham4HMLGen.g:2401:9: HamSmallmod
this.match(this.input,HamSmallmod,Ham4HMLGen.FOLLOW_HamSmallmod_in_size18391); 
rsz = "small"; 
break;
case 2 :
// Ham4HMLGen.g:2402:9: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_size18411); 
rsz = "large"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsz;
},
// Ham4HMLGen.g:2406:1: sizechange returns [String rsc = null] : ( HamIncreasing | HamDecreasing ) ;
// $ANTLR start "sizechange"
sizechange: function() {
var rsc =  null;
try {
// Ham4HMLGen.g:2408:5: ( ( HamIncreasing | HamDecreasing ) )
// Ham4HMLGen.g:2409:5: ( HamIncreasing | HamDecreasing )
// Ham4HMLGen.g:2409:5: ( HamIncreasing | HamDecreasing )
var alt189=2;
var LA189_0 = this.input.LA(1);
if ( (LA189_0==HamIncreasing) ) {
alt189=1;
}
else if ( (LA189_0==HamDecreasing) ) {
alt189=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 189, 0, this.input);
throw nvae;
}
switch (alt189) {
case 1 :
// Ham4HMLGen.g:2409:9: HamIncreasing
this.match(this.input,HamIncreasing,Ham4HMLGen.FOLLOW_HamIncreasing_in_sizechange18463); 
rsc = "ham_increasing"; 
break;
case 2 :
// Ham4HMLGen.g:2410:9: HamDecreasing
this.match(this.input,HamDecreasing,Ham4HMLGen.FOLLOW_HamDecreasing_in_sizechange18481); 
rsc = "ham_decreasing"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsc;
}
// Delegated rules
}, true); // important to pass true to overwrite default implementations
// public class variables
org.antlr.lang.augmentObject(Ham4HMLGen, {
tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "WS", "HamTab", "HamLinefeed", "HamPagebreak", "HamReturn", "HamVersion40", "HamSpace", "HamExclaim", "HamQuery", "HamFullstop", "HamComma", "HamPlus", "HamMetaalt", "HamClocku", "HamClockul", "HamClockl", "HamClockdl", "HamClockd", "HamClockdr", "HamClockr", "HamClockur", "HamClockfull", "HamSymmpar", "HamSymmlr", "HamFist", "HamFlathand", "HamFinger2", "HamFinger23", "HamFinger23spread", "HamFinger2345", "HamThumboutmod", "HamThumbacrossmod", "HamPinch12", "HamPinchall", "HamPinch12open", "HamCee12", "HamCeeall", "HamCee12open", "HamThumbopenmod", "HamFingerstraightmod", "HamFingerbendmod", "HamFingerhookedmod", "HamNondominant", "HamDoublebent", "HamDoublehooked", "HamExtfingeru", "HamExtfingerur", "HamExtfingerr", "HamExtfingerdr", "HamExtfingerd", "HamExtfingerdl", "HamExtfingerl", "HamExtfingerul", "HamExtfingerol", "HamExtfingero", "HamExtfingeror", "HamExtfingeril", "HamExtfingeri", "HamExtfingerir", "HamExtfingerui", "HamExtfingerdi", "HamExtfingerdo", "HamExtfingeruo", "HamEarlobe", "HamNostrils", "HamShouldertop", "HamPalmu", "HamPalmur", "HamPalmr", "HamPalmdr", "HamPalmd", "HamPalmdl", "HamPalml", "HamPalmul", "HamReplace", "HamArmextended", "HamBehind", "HamEtc", "HamOrirelative", "HamTongue", "HamTeeth", "HamStomach", "HamNeutralspace", "HamHead", "HamHeadtop", "HamForehead", "HamEyebrows", "HamEyes", "HamNose", "HamEar", "HamCheek", "HamLips", "HamChin", "HamUnderchin", "HamNeck", "HamShoulders", "HamChest", "HamBelowstomach", "HamLrbeside", "HamLrat", "HamUpperarm", "HamElbow", "HamElbowinside", "HamLowerarm", "HamWristback", "HamWristpulse", "HamThumbball", "HamPalm", "HamHandback", "HamThumb", "HamIndexfinger", "HamMiddlefinger", "HamRingfinger", "HamPinky", "HamThumbside", "HamPinkyside", "HamBetween", "HamFingertip", "HamFingernail", "HamFingerpad", "HamFingermidjoint", "HamFingerbase", "HamFingerside", "HamWristtopulse", "HamWristtoback", "HamWristtothumb", "HamWristtopinky", "HamCoreftag", "HamCorefref", "HamNomotion", "HamMoveu", "HamMoveur", "HamMover", "HamMovedr", "HamMoved", "HamMovedl", "HamMovel", "HamMoveul", "HamMoveol", "HamMoveo", "HamMoveor", "HamMoveil", "HamMovei", "HamMoveir", "HamMoveui", "HamMovedi", "HamMovedo", "HamMoveuo", "HamMovecross", "HamMovex", "HamSmallmod", "HamLargemod", "HamArcl", "HamArcu", "HamArcr", "HamArcd", "HamWavy", "HamZigzag", "HamFingerplay", "HamParbegin", "HamParend", "HamCircleo", "HamCirclei", "HamCircled", "HamCircleu", "HamCirclel", "HamCircler", "HamIncreasing", "HamDecreasing", "HamClose", "HamTouch", "HamInterlock", "HamCross", "HamFast", "HamSlow", "HamTense", "HamRest", "HamHalt", "HamRepeatfromstart", "HamRepeatfromstartseveral", "HamRepeatcontinue", "HamRepeatcontinueseveral", "HamSeqbegin", "HamSeqend", "HamAlternatingmotion", "HamRepeatreverse", "HamBrushing", "HamNonipsi", "HamEllipseh", "HamEllipseur", "HamEllipsev", "HamEllipseul", "HamMime", "HamAltbegin", "HamAltend", "HamNodding", "HamSwinging", "HamTwisting", "HamStircw", "HamStirccw", "HamFusionbegin", "HamFusionend", "HamCircleul", "HamCircledr", "HamCircleur", "HamCircledl", "HamCircleol", "HamCircleir", "HamCircleor", "HamCircleil", "HamCircledo", "HamCircleui", "HamCircledi", "HamCircleuo", "HamNbs", "HAMSIGNS", "SIGN2", "SIGN1", "ICFG2", "ICFG1", "NMICLIST", "NMICUNIT", "MICFG2", "MICFG1", "HDCONFIG2", "HDCONFIG1", "SPLITHDCFG2", "HDCFGTAIL2", "HSHAPE2", "HSHAPE1", "BASICHDSHP1", "BASICHDSHP", "HSCLASS", "FIBENDING", "THUMBPOS", "FINGERLIST", "FISHPLIST", "FICRSSLIST", "FSHAPE", "FCROSSING", "THSPECIAL", "EXTFIDIR2", "EXTFIDIR1", "EXTFIDIR", "PALMOR2", "PALMOR1", "LOC2", "LOC1", "LOCTNBODYARM", "LOCTNBODY", "LOCTNHAND", "LOCTNARM", "LEVBODY", "LEVHAND", "LEVARM", "HCONSTLLN", "CNTCTBODY", "CNTCTHAND", "CNTCTOFHAND", "A2TLIST", "A1TLIST", "A1LIST", "ACTION2T", "ACTION1T", "ACTION2", "ACTION1", "PARACT2T", "SEQACT2T", "SPLITACT2LOC2", "SPLITACT2T", "PARACT1T", "SEQACT1T", "NMACT1T", "PARACT1", "REPETITIONS", "SIMPLEMVMT", "STRGHTMVMT", "CRCLRMVMT", "REPLACE", "SPLITREPLACETL", "REPLACETAIL1", "HSFINGERITEM", "LOCBODY", "MOVINGREPETITION", "SEQACT1", "SEQFUSEDACT2T", "SEQFUSEDACT1T", "SEQFUSEDACT1", "CNTCTOHHAND", "CNTCTOHARM"],
FOLLOW_HAMSIGNS_in_hamsignseq145: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_sign2or1_in_hamsignseq160: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x30000000, 0x00000000]),
FOLLOW_sign2_in_sign2or1242: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nondomsign1_in_sign2or1269: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_SIGN2_in_sign2320: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_symmoperator_in_sign2352: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
FOLLOW_initialconfig2_in_sign2371: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
FOLLOW_a2tstar_in_sign2391: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_initialconfig2_in_sign2420: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_sign2440: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamNomotion_in_sign2477: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_HamNondominant_in_sign2511: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_initialconfig1_in_sign2546: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_sign2566: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SIGN1_in_nondomsign1620: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamNondominant_in_nondomsign1640: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_initialconfig1_in_nondomsign1655: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_nondomsign1671: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamSymmpar_in_symmoperator741: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamSymmlr_in_symmoperator776: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator824: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator859: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator893: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator916: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamAlternatingmotion_in_symmoperator961: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
FOLLOW_HamNonipsi_in_symmoperator983: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ICFG2_in_initialconfig21044: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig21061: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
FOLLOW_minitialconfig2_in_initialconfig21082: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ICFG1_in_initialconfig11123: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig11140: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_minitialconfig1_in_initialconfig11161: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_NMICLIST_in_nminitialconfig1209: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nmicunit_in_nminitialconfig1238: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
FOLLOW_NMICUNIT_in_nmicunit1304: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelbody_in_nmicunit1332: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_levelarm_in_nmicunit1361: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_action1_in_nmicunit1385: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MICFG2_in_minitialconfig21425: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig2_in_minitialconfig21457: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_location2_in_minitialconfig21478: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig21513: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig21533: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_minitialconfig21560: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig21580: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MICFG1_in_minitialconfig11633: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig11651: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig11668: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCONFIG2_in_handconfig21718: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape2_in_handconfig21754: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000080]),
FOLLOW_handconfigtail2_in_handconfig21775: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_splithandconfig2_in_handconfig21814: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCONFIG1_in_handconfig11868: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape1_in_handconfig11887: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400000]),
FOLLOW_extfidir1_in_handconfig11905: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfig11927: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITHDCFG2_in_splithandconfig21982: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig1_in_splithandconfig21998: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
FOLLOW_handconfig1_in_splithandconfig22014: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCFGTAIL2_in_handconfigtail22058: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir2_in_handconfigtail22092: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_palmor2_in_handconfigtail22124: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22166: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfigtail22189: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00400000]),
FOLLOW_extfidir1_in_handconfigtail22211: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfigtail22234: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSHAPE2_in_handshape22292: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape1_in_handshape22310: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000200]),
FOLLOW_handshape1_in_handshape22328: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSHAPE1_in_handshape12376: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_basichandshape1_in_handshape12395: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00138000]),
FOLLOW_fingerlist_in_handshape12414: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00130000]),
FOLLOW_fingershapelist_in_handshape12436: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00120000]),
FOLLOW_fingercrossinglist_in_handshape12458: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00100000]),
FOLLOW_thumbspecial_in_handshape12481: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_BASICHDSHP1_in_basichandshape12524: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_basichandshape_in_basichandshape12542: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000800]),
FOLLOW_basichandshape_in_basichandshape12565: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_BASICHDSHP_in_basichandshape2614: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshapeclass_in_basichandshape2636: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_HamNondominant_in_basichandshape2665: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_HamEtc_in_basichandshape2692: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_thumbpos_in_basichandshape2776: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_fingerbending_in_basichandshape2809: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_fingerbending_in_basichandshape2850: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00004000]),
FOLLOW_thumbpos_in_basichandshape2878: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSCLASS_in_handshapeclass2937: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamFist_in_handshapeclass2951: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFlathand_in_handshapeclass2979: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger2_in_handshapeclass3003: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger23_in_handshapeclass3028: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger23spread_in_handshapeclass3052: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger2345_in_handshapeclass3070: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinch12_in_handshapeclass3092: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinchall_in_handshapeclass3117: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinch12open_in_handshapeclass3141: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCee12_in_handshapeclass3162: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCeeall_in_handshapeclass3189: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCee12open_in_handshapeclass3215: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_FIBENDING_in_fingerbending3270: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamFingerstraightmod_in_fingerbending3284: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingerbendmod_in_fingerbending3303: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingerhookedmod_in_fingerbending3326: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublebent_in_fingerbending3347: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublehooked_in_fingerbending3373: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_THUMBPOS_in_thumbpos3434: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamThumboutmod_in_thumbpos3448: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumbacrossmod_in_thumbpos3469: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumbopenmod_in_thumbpos3487: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumb_in_thumb3544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamIndexfinger_in_finger3594: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMiddlefinger_in_finger3615: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRingfinger_in_finger3635: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPinky_in_finger3657: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HSFINGERITEM_in_hsfingeritem3721: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_finger_in_hsfingeritem3735: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000]),
FOLLOW_HamLargemod_in_hsfingeritem3755: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_thumb_in_digit3823: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_digit3837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_FINGERLIST_in_fingerlist3886: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_hsfingeritem_in_fingerlist3902: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
FOLLOW_FISHPLIST_in_fingershapelist3966: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fingershape_in_fingershapelist3982: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00040000]),
FOLLOW_FICRSSLIST_in_fingercrossinglist4045: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fingercrossing_in_fingercrossinglist4061: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00080000]),
FOLLOW_FSHAPE_in_fingershape4116: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_fingershape4131: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_fingerbending_in_fingershape4145: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_FCROSSING_in_fingercrossing4186: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_fingercrossing4200: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7E000000]),
FOLLOW_fingerpart_in_fingercrossing4214: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_fingercrossing4228: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_THSPECIAL_in_thumbspecial4274: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamBetween_in_thumbspecial4289: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_finger_in_thumbspecial4315: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_thumbspecial4341: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_thumb_in_thumbspecial4406: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_fingerpart_in_thumbspecial4439: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingertip_in_fingerpart4505: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingernail_in_fingerpart4528: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerpad_in_fingerpart4550: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingermidjoint_in_fingerpart4573: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerbase_in_fingerpart4591: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerside_in_fingerpart4613: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_EXTFIDIR2_in_extfidir24674: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir1_in_extfidir24693: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00400000]),
FOLLOW_extfidir1_in_extfidir24712: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_EXTFIDIR1_in_extfidir14765: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir_in_extfidir14782: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_extfidir_in_extfidir14799: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_extfidir14822: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_EXTFIDIR_in_extfidir4885: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamExtfingeru_in_extfidir4919: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerur_in_extfidir4949: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerr_in_extfidir4978: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdr_in_extfidir5008: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerd_in_extfidir5037: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdl_in_extfidir5067: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerl_in_extfidir5096: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerul_in_extfidir5126: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerol_in_extfidir5183: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5234: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir5263: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingero_in_extfidir5317: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir5365: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5416: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir5445: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeril_in_extfidir5517: new org.antlr.runtime.BitSet([0x00000008, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir5568: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir5597: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeri_in_extfidir5651: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir5699: new org.antlr.runtime.BitSet([0x00000008, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir5750: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir5779: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5861: new org.antlr.runtime.BitSet([0x00000008, 0x0A000000]),
FOLLOW_HamExtfingerol_in_extfidir5912: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir5941: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir6013: new org.antlr.runtime.BitSet([0x00000008, 0x0A000000]),
FOLLOW_HamExtfingerol_in_extfidir6064: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir6093: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir6165: new org.antlr.runtime.BitSet([0x00000008, 0x50000000]),
FOLLOW_HamExtfingeril_in_extfidir6216: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir6245: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir6317: new org.antlr.runtime.BitSet([0x00000008, 0x50000000]),
FOLLOW_HamExtfingeril_in_extfidir6368: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir6397: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PALMOR2_in_palmor26498: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_palmor1_in_palmor26516: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_palmor26534: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PALMOR1_in_palmor16589: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_palmor_in_palmor16607: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00063FC0, 0x00000000]),
FOLLOW_palmor_in_palmor16635: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamEtc_in_palmor16665: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_palmor16707: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPalmu_in_palmor6776: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmur_in_palmor6799: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmr_in_palmor6821: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmdr_in_palmor6844: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmd_in_palmor6866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmdl_in_palmor6889: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalml_in_palmor6911: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmul_in_palmor6934: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LOC2_in_location26999: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_location1_in_location27031: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_location27052: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_handconstellation_in_location27088: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
FOLLOW_HamArmextended_in_location27126: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationbody_in_location27172: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOC1_in_location17243: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_location17271: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationhand_in_location17313: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationbodyarm_in_location17341: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNBODYARM_in_locationbodyarm7395: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_locationbody_in_locationbodyarm7423: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationarm_in_locationbodyarm7451: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamArmextended_in_locationbodyarm7477: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNBODY_in_locationbody7546: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexbody_in_locationbody7564: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00010000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamBehind_in_locationbody7584: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_contactbody_in_locationbody7640: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNHAND_in_locationhand7686: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexhand_in_locationhand7704: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_contacthand_in_locationhand7723: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNARM_in_locationarm7774: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexarm_in_locationarm7792: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00010000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamBehind_in_locationarm7812: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_contactbody_in_locationarm7868: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody7919: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000001, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody7937: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand7982: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand8000: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm8046: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000004, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm8064: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LEVBODY_in_levelbody8111: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelbody8130: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x60000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
FOLLOW_locbody_in_levelbody8163: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000000C0]),
FOLLOW_locsided_in_levelbody8192: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000000C0]),
FOLLOW_HamEtc_in_levelbody8222: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelbody8257: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LEVHAND_in_levelhand8311: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelhand8330: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7EFFF000]),
FOLLOW_handpart_in_levelhand8363: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_fingerpart_in_levelhand8402: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003F80C0]),
FOLLOW_digit_in_levelhand8433: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003F80C0]),
FOLLOW_digit_in_levelhand8476: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x7E3F80C0]),
FOLLOW_fingerpart_in_levelhand8510: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_dorsalorpalmar_in_levelhand8553: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelhand8575: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LEVARM_in_levelarm8630: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelarm8649: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000F00]),
FOLLOW_locarm_in_levelarm8672: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000180C0]),
FOLLOW_HamEtc_in_levelarm8692: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_dorsalorpalmar_in_levelarm8727: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelarm8749: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTBODY_in_contactbody8797: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contactbody8827: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamArmextended_in_contactbody8851: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactofhand_in_contactbody8903: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTHAND_in_contacthand8957: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contacthand8987: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ccontact_in_contacthand9017: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactofhand_in_contacthand9047: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOFHAND_in_contactofhand9109: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contactofhand9142: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000030]),
FOLLOW_ccontact_in_contactofhand9175: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000030]),
FOLLOW_contactohhand_in_contactofhand9217: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactoharm_in_contactofhand9249: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOHHAND_in_contactohhand9305: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexhand_in_contactohhand9319: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOHARM_in_contactoharm9364: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexarm_in_contactoharm9378: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HCONSTLLN_in_handconstellation9420: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_locationhand_in_handconstellation9448: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_locationhand_in_handconstellation9466: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_contacthand_in_handconstellation9496: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamUpperarm_in_locarm9551: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamElbow_in_locarm9575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamElbowinside_in_locarm9602: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLowerarm_in_locarm9623: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LOCBODY_in_locbody9683: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamHead_in_locbody9697: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamHeadtop_in_locbody9729: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamForehead_in_locbody9758: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamEyebrows_in_locbody9786: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamEyes_in_locbody9814: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNose_in_locbody9846: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNostrils_in_locbody9878: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamLips_in_locbody9906: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamTongue_in_locbody9938: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamTeeth_in_locbody9968: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamChin_in_locbody9999: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamUnderchin_in_locbody10031: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNeck_in_locbody10058: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamShouldertop_in_locbody10090: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamShoulders_in_locbody10115: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamChest_in_locbody10142: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamStomach_in_locbody10173: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamBelowstomach_in_locbody10202: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamDoublebent_in_locbody10246: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublehooked_in_locbody10272: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamEar_in_locsided10343: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEarlobe_in_locsided10372: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCheek_in_locsided10397: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamWristback_in_handpart10462: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamWristpulse_in_handpart10485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumbball_in_handpart10507: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalm_in_handpart10530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHandback_in_handpart10558: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumbside_in_handpart10582: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPinkyside_in_handpart10605: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLrbeside_in_side10690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLrat_in_side10714: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHandback_in_dorsalorpalmar10776: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalm_in_dorsalorpalmar10800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTouch_in_pcontact10866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClose_in_pcontact10893: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamInterlock_in_ccontact10964: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCross_in_ccontact10987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_A2TLIST_in_a2tstar11059: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_a2tstar11077: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_A1TLIST_in_a1tstar11139: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_a1tstar11157: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_ACTION2T_in_action2t11214: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_action2t11242: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_action1_in_action2t11272: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_location2_in_action2t11290: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_splitaction2loc2_in_action2t11319: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_splitaction2t_in_action2t11354: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_paraction2t_in_action2t11391: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqaction2t_in_action2t11419: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqfusedaction2t_in_action2t11447: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_repetitions_in_action2t11483: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ACTION1T_in_action1t11538: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_action1t11572: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000,0x00400008, 0x00000000]),
FOLLOW_location1_in_action1t11609: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_HamLargemod_in_action1t11633: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_handconstellation_in_action1t11677: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_paraction1t_in_action1t11724: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqaction1t_in_action1t11756: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqfusedaction1t_in_action1t11788: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_nmaction1t_in_action1t11819: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_repetitions_in_action1t11861: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ACTION1_in_action111917: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamNomotion_in_action111951: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_simplemovement_in_action112007: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_modifier_in_action112061: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x003E0000]),
FOLLOW_HamLargemod_in_action112128: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_paraction1_in_action112182: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_seqaction1_in_action112214: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_seqfusedaction1_in_action112246: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PARACT2T_in_paraction2t12307: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_paraction2t12337: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SEQACT2T_in_seqaction2t12403: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_seqaction2t12433: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SEQFUSEDACT2T_in_seqfusedaction2t12502: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_seqfusedaction2t12532: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SPLITACT2LOC2_in_splitaction2loc212597: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_splitaction2loc212617: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2loc212640: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_action1_in_splitaction2loc212660: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000,0x00002000, 0x00000000]),
FOLLOW_location2_in_splitaction2loc212691: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITACT2T_in_splitaction2t12737: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_splitaction2t12756: new org.antlr.runtime.BitSet([0x00008008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2t12778: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_action1t_in_splitaction2t12797: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_PARACT1T_in_paraction1t12857: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_paraction1t12887: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_SEQACT1T_in_seqaction1t12953: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_seqaction1t12983: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_SEQFUSEDACT1T_in_seqfusedaction1t13052: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_seqfusedaction1t13082: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_NMACT1T_in_nmaction1t13145: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelbody_in_nmaction1t13174: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_levelarm_in_nmaction1t13203: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_action1t_in_nmaction1t13234: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PARACT1_in_paraction113283: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_paraction113313: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_SEQACT1_in_seqaction113385: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_seqaction113415: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_SEQFUSEDACT1_in_seqfusedaction113490: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_seqfusedaction113520: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_REPETITIONS_in_repetitions13593: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_repetition_in_repetitions13644: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x33C01800]),
FOLLOW_HamEtc_in_repetitions13690: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_repetitions13734: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_repetition_in_repetitions13782: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_movingrepetition_in_repetitions13843: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_sizechange_in_repetitions13899: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x10000000]),
FOLLOW_size_in_repetitions13926: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions13986: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions13999: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14044: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14065: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MOVINGREPETITION_in_movingrepetition14122: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_repetition_in_movingrepetition14146: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_movingrepetition14169: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800]),
FOLLOW_size_in_movingrepetition14192: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechange_in_movingrepetition14228: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_movingrepetition14249: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SIMPLEMVMT_in_simplemovement14311: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fullstraightmovement_in_simplemovement14340: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullcircularmovement_in_simplemovement14369: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullwristmovement_in_simplemovement14398: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullmovementcross_in_simplemovement14427: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_replacement_in_simplemovement14456: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_digit_in_simplemovement14514: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x00000004]),
FOLLOW_HamFingerplay_in_simplemovement14579: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_simplemovement14639: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_simplemovement14658: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_simplemovement14687: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_straightmovement_in_fullstraightmovement14750: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000003]),
FOLLOW_size_in_fullstraightmovement14775: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xF0000000, 0x00000003]),
FOLLOW_arckind_in_fullstraightmovement14808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_zigzag_in_fullstraightmovement14839: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_STRGHTMVMT_in_straightmovement14894: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement14913: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement14932: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_arc_in_arckind14999: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000000]),
FOLLOW_arc_in_arckind15018: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_arckind15041: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamZigzag_in_zigzag15124: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_HamWavy_in_zigzag15160: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_zigzag15197: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_zigzag15219: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_zigzag15242: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sizechange_in_sizechangenonlinear15306: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_sizechangenonlinear15325: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_circularmovement_in_fullcircularmovement15388: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_fullcircularmovement15413: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_revolutions_in_fullcircularmovement15436: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipse_in_fullcircularmovement15459: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_fullcircularmovement15482: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_CRCLRMVMT_in_circularmovement15529: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement15547: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000007E0,0x03FFC000, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement15565: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ellipsedirection_in_ellipse15634: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_ellipse15653: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_clock_in_revolutions15734: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15766: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15795: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15844: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15873: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions15920: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_wristmovement_in_fullwristmovement15983: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_fullwristmovement16002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementcross_in_fullmovementcross16065: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_fullmovementcross16084: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_REPLACE_in_replacement16144: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_sizechange_in_replacement16163: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400200,0x08000000, 0x00000000]),
FOLLOW_handshape1_in_replacement16185: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400000,0x08000000, 0x00000000]),
FOLLOW_splitreplacetail_in_replacement16220: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_extfidir1_in_replacement16252: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_replacement16275: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_palmor1_in_replacement16311: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITREPLACETL_in_splitreplacetail16365: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail16383: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x10000000, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail16401: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_REPLACETAIL1_in_replacetail116451: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir1_in_replacetail116483: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_replacetail116509: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamRepeatfromstart_in_repetition16573: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatfromstartseveral_in_repetition16586: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatcontinue_in_repetition16626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatcontinueseveral_in_repetition16640: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatreverse_in_repetition16680: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveu_in_movementarrow16724: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveur_in_movementarrow16747: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMover_in_movementarrow16769: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedr_in_movementarrow16792: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoved_in_movementarrow16814: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedl_in_movementarrow16837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovel_in_movementarrow16859: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveul_in_movementarrow16882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveol_in_movementarrow16904: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveo_in_movementarrow16926: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveor_in_movementarrow16949: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveil_in_movementarrow16971: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovei_in_movementarrow16993: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveir_in_movementarrow17016: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveui_in_movementarrow17038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedi_in_movementarrow17060: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedo_in_movementarrow17082: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveuo_in_movementarrow17104: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovecross_in_movementcross17161: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovex_in_movementcross17180: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNodding_in_wristmovement17232: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSwinging_in_wristmovement17253: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTwisting_in_wristmovement17273: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStircw_in_wristmovement17293: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStirccw_in_wristmovement17315: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleo_in_movementcircle17364: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCirclei_in_movementcircle17385: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircled_in_movementcircle17406: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleu_in_movementcircle17427: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCirclel_in_movementcircle17448: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircler_in_movementcircle17469: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleul_in_movementcircle17490: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledr_in_movementcircle17510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleur_in_movementcircle17530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledl_in_movementcircle17550: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleol_in_movementcircle17570: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleir_in_movementcircle17590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleor_in_movementcircle17610: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleil_in_movementcircle17630: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleui_in_movementcircle17650: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledo_in_movementcircle17670: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledi_in_movementcircle17690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleuo_in_movementcircle17710: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseh_in_ellipsedirection17766: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseur_in_ellipsedirection17786: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipsev_in_ellipsedirection17805: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseul_in_ellipsedirection17825: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClocku_in_clock17887: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockul_in_clock17909: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockl_in_clock17930: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockdl_in_clock17952: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockd_in_clock17973: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockdr_in_clock17995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockr_in_clock18016: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockur_in_clock18038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFast_in_modifier18099: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSlow_in_modifier18123: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTense_in_modifier18147: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRest_in_modifier18170: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHalt_in_modifier18194: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcl_in_arc18257: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcu_in_arc18281: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcr_in_arc18305: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcd_in_arc18329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSmallmod_in_size18391: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLargemod_in_size18411: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamIncreasing_in_sizechange18463: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamDecreasing_in_sizechange18481: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});
})();//-------- js/Coffee-fix.js --------
// Exports
this.getCWAEnv().add(Ham4Parser, "Ham4Parser");
//-------- js/HamLexer.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CommonToken, EOF, HamLexer, Token, cwaenv, document, hamLimit, ttMap, ttUnused;
cwaenv = this.getCWAEnv();
document = this.document;
EOF = 1;
ttUnused = -1;
hamLimit = 256;
ttMap = [ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamTab, Ham4Parser.HamLinefeed, ttUnused, Ham4Parser.HamPagebreak, Ham4Parser.HamReturn, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamVersion40, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamSpace, Ham4Parser.HamExclaim, Ham4Parser.HamQuery, Ham4Parser.HamFullstop, Ham4Parser.HamComma, Ham4Parser.HamPlus, Ham4Parser.HamMetaalt, Ham4Parser.HamClocku, Ham4Parser.HamClockul, Ham4Parser.HamClockl, Ham4Parser.HamClockdl, Ham4Parser.HamClockd, Ham4Parser.HamClockdr, Ham4Parser.HamClockr, Ham4Parser.HamClockur, Ham4Parser.HamClockfull, Ham4Parser.HamSymmpar, Ham4Parser.HamSymmlr, Ham4Parser.HamFist, Ham4Parser.HamFlathand, Ham4Parser.HamFinger2, Ham4Parser.HamFinger23, Ham4Parser.HamFinger23spread, Ham4Parser.HamFinger2345, Ham4Parser.HamThumboutmod, Ham4Parser.HamThumbacrossmod, Ham4Parser.HamPinch12, Ham4Parser.HamPinchall, Ham4Parser.HamPinch12open, Ham4Parser.HamCee12, Ham4Parser.HamCeeall, Ham4Parser.HamCee12open, Ham4Parser.HamThumbopenmod, Ham4Parser.HamFingerstraightmod, Ham4Parser.HamFingerbendmod, Ham4Parser.HamFingerhookedmod, Ham4Parser.HamNondominant, Ham4Parser.HamDoublebent, Ham4Parser.HamDoublehooked, ttUnused, Ham4Parser.HamExtfingeru, Ham4Parser.HamExtfingerur, Ham4Parser.HamExtfingerr, Ham4Parser.HamExtfingerdr, Ham4Parser.HamExtfingerd, Ham4Parser.HamExtfingerdl, Ham4Parser.HamExtfingerl, Ham4Parser.HamExtfingerul, Ham4Parser.HamExtfingerol, Ham4Parser.HamExtfingero, Ham4Parser.HamExtfingeror, Ham4Parser.HamExtfingeril, Ham4Parser.HamExtfingeri, Ham4Parser.HamExtfingerir, Ham4Parser.HamExtfingerui, Ham4Parser.HamExtfingerdi, Ham4Parser.HamExtfingerdo, Ham4Parser.HamExtfingeruo, ttUnused, ttUnused, ttUnused, Ham4Parser.HamEarlobe, Ham4Parser.HamNostrils, Ham4Parser.HamShouldertop, Ham4Parser.HamPalmu, Ham4Parser.HamPalmur, Ham4Parser.HamPalmr, Ham4Parser.HamPalmdr, Ham4Parser.HamPalmd, Ham4Parser.HamPalmdl, Ham4Parser.HamPalml, Ham4Parser.HamPalmul, Ham4Parser.HamReplace, Ham4Parser.HamArmextended, Ham4Parser.HamBehind, Ham4Parser.HamEtc, Ham4Parser.HamOrirelative, Ham4Parser.HamTongue, Ham4Parser.HamTeeth, Ham4Parser.HamStomach, Ham4Parser.HamNeutralspace, Ham4Parser.HamHead, Ham4Parser.HamHeadtop, Ham4Parser.HamForehead, Ham4Parser.HamEyebrows, Ham4Parser.HamEyes, Ham4Parser.HamNose, Ham4Parser.HamEar, Ham4Parser.HamCheek, Ham4Parser.HamLips, Ham4Parser.HamChin, Ham4Parser.HamUnderchin, Ham4Parser.HamNeck, Ham4Parser.HamShoulders, Ham4Parser.HamChest, Ham4Parser.HamStomach, Ham4Parser.HamBelowstomach, Ham4Parser.HamLrbeside, Ham4Parser.HamLrat, Ham4Parser.HamUpperarm, Ham4Parser.HamElbow, Ham4Parser.HamElbowinside, Ham4Parser.HamLowerarm, Ham4Parser.HamWristback, Ham4Parser.HamWristpulse, Ham4Parser.HamThumbball, Ham4Parser.HamPalm, Ham4Parser.HamHandback, Ham4Parser.HamThumb, Ham4Parser.HamIndexfinger, Ham4Parser.HamMiddlefinger, Ham4Parser.HamRingfinger, Ham4Parser.HamPinky, Ham4Parser.HamThumbside, Ham4Parser.HamPinkyside, Ham4Parser.HamBetween, Ham4Parser.HamFingertip, Ham4Parser.HamFingernail, Ham4Parser.HamFingerpad, Ham4Parser.HamFingermidjoint, Ham4Parser.HamFingerbase, Ham4Parser.HamFingerside, Ham4Parser.HamWristtopulse, Ham4Parser.HamWristtoback, Ham4Parser.HamWristtothumb, Ham4Parser.HamWristtopinky, Ham4Parser.HamCoreftag, Ham4Parser.HamCorefref, Ham4Parser.HamNomotion, Ham4Parser.HamMoveu, Ham4Parser.HamMoveur, Ham4Parser.HamMover, Ham4Parser.HamMovedr, Ham4Parser.HamMoved, Ham4Parser.HamMovedl, Ham4Parser.HamMovel, Ham4Parser.HamMoveul, Ham4Parser.HamMoveol, Ham4Parser.HamMoveo, Ham4Parser.HamMoveor, Ham4Parser.HamMoveil, Ham4Parser.HamMovei, Ham4Parser.HamMoveir, Ham4Parser.HamMoveui, Ham4Parser.HamMovedi, Ham4Parser.HamMovedo, Ham4Parser.HamMoveuo, Ham4Parser.HamMovecross, Ham4Parser.HamMovex, Ham4Parser.HamSmallmod, Ham4Parser.HamLargemod, Ham4Parser.HamArcl, Ham4Parser.HamArcu, Ham4Parser.HamArcr, Ham4Parser.HamArcd, Ham4Parser.HamWavy, Ham4Parser.HamZigzag, Ham4Parser.HamFingerplay, Ham4Parser.HamParbegin, Ham4Parser.HamParend, Ham4Parser.HamCircleo, Ham4Parser.HamCirclei, Ham4Parser.HamCircled, Ham4Parser.HamCircleu, Ham4Parser.HamCirclel, Ham4Parser.HamCircler, Ham4Parser.HamIncreasing, Ham4Parser.HamDecreasing, Ham4Parser.HamClose, Ham4Parser.HamTouch, Ham4Parser.HamInterlock, Ham4Parser.HamCross, Ham4Parser.HamFast, Ham4Parser.HamSlow, Ham4Parser.HamTense, Ham4Parser.HamRest, Ham4Parser.HamHalt, Ham4Parser.HamRepeatfromstart, Ham4Parser.HamRepeatfromstartseveral, Ham4Parser.HamRepeatcontinue, Ham4Parser.HamRepeatcontinueseveral, Ham4Parser.HamSeqbegin, Ham4Parser.HamSeqend, Ham4Parser.HamAlternatingmotion, Ham4Parser.HamRepeatreverse, Ham4Parser.HamBrushing, Ham4Parser.HamNonipsi, ttUnused, Ham4Parser.HamEllipseh, Ham4Parser.HamEllipseur, Ham4Parser.HamEllipsev, Ham4Parser.HamEllipseul, Ham4Parser.HamMime, Ham4Parser.HamAltbegin, Ham4Parser.HamAltend, Ham4Parser.HamNodding, Ham4Parser.HamSwinging, Ham4Parser.HamTwisting, Ham4Parser.HamStircw, Ham4Parser.HamStirccw, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamFusionbegin, Ham4Parser.HamFusionend, ttUnused, ttUnused, Ham4Parser.HamCircleul, Ham4Parser.HamCircledr, Ham4Parser.HamCircleur, Ham4Parser.HamCircledl, Ham4Parser.HamCircleol, Ham4Parser.HamCircleir, Ham4Parser.HamCircleor, Ham4Parser.HamCircleil, Ham4Parser.HamCircledo, Ham4Parser.HamCircleui, Ham4Parser.HamCircledi, Ham4Parser.HamCircleuo, ttUnused, ttUnused, Ham4Parser.HamNbs, ttUnused];
Token = org.antlr.runtime.Token;
CommonToken = org.antlr.runtime.CommonToken;
HamLexer = (function() {
function HamLexer(hamSignCharCodes, tokenNames, logLev) {
this.hamSignCharCodes = hamSignCharCodes;
this.tokenNames = tokenNames;
this.logLev = logLev != null ? logLev : 0;
this.hamSignLength = this.hamSignCharCodes.length;
this.trace("HamLexer Overridden Input: " + this.hamSignCharCodes + " length=" + this.hamSignLength);
this.trace("HamLexer Tokens: " + this.tokenNames);
this.iScan = 0;
this.lMark = -1;
}
HamLexer.prototype.setLogLevel = function(lev) {
return this.logLev = lev;
};
HamLexer.prototype.trace = function(str) {
if (this.logLev >= 440) {
return console.log(str);
}
};
HamLexer.prototype.seek = function(ix) {
this.trace("Lex: seek(" + ix + ") called");
return this.iScan = ix;
};
HamLexer.prototype.rewind = function(ix) {
if (ix != null) {
this.trace("Lex: rewind(" + ix + ") called");
return this.iScan = ix;
} else {
this.trace("Lex: rewind() called");
if (this.lMark >= 0) {
return this.iScan = this.lMark;
}
}
};
HamLexer.prototype.mark = function() {
this.trace("Lex: mark() yeilds " + this.iScan);
this.lMark = this.iScan;
return this.iScan;
};
HamLexer.prototype.index = function() {
this.trace("Lex: index() yeilds " + this.iScan);
return this.iScan;
};
HamLexer.prototype.tokName = function(i) {
if (i === EOF) {
return "<EOF>";
} else if (i === ttUnused) {
return "<UNUSED>";
} else {
return this.tokenNames[i];
}
};
HamLexer.prototype.getType = function(i, tag) {
var ich, res;
res = Token.EOF;
if (i >= 0 && i < this.hamSignLength) {
ich = this.hamSignCharCodes.charCodeAt(i);
res = ich < hamLimit ? ttMap[ich] : ttUnused;
}
this.trace("Lex: at " + this.iScan + " getType(" + i + ") for " + tag + " yeilds " + res + "=" + (this.tokName(res)));
return res;
};
HamLexer.prototype.getToken = function(i) {
var ttype;
ttype = this.getType(i, "getToken");
return new CommonToken(ttype, (this.tokName(ttype)) + "{" + i + "}");
};
HamLexer.prototype.LA = function(ah) {
var typ;
typ = ah === 0 ? EOF : ah < 0 ? getType(this.iScan + ah, "LA") : this.getType(this.iScan + ah - 1, "LA");
this.trace("Lex: LA(" + ah + ") yeilds " + typ);
return typ;
};
HamLexer.prototype.LT = function(ah) {
this.trace("Lex: LT(" + ah + ") calls getToken");
if (ah === 0 || (this.iScan + ah) < 0) {
return null;
} else if (ah < 0) {
return this.getToken(this.iScan + ah);
} else {
return this.getToken(this.iScan + ah - 1);
}
};
HamLexer.prototype.consume = function() {
this.iScan++;
return this.trace("Lex: consume() now " + this.iScan);
};
return HamLexer;
})();
cwaenv.add(HamLexer, "HamLexer");
}).call(this);
//-------- js/HMLBuilder.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, Defs, HMLBuilder, cwaenv, document, logLev;
cwaenv = this.getCWAEnv();
document = this.document;
Data = cwaenv.get("Data");
Defs = cwaenv.get("HNSDefs");
logLev = 0;
HMLBuilder = (function() {
function HMLBuilder() {
this.doc = Data.toDOM("<sign/>");
HMLBuilder.trace("SiGML document created");
}
HMLBuilder.prototype.newHMLElement = function(tag) {
HMLBuilder.trace("HML: newHMLElement(" + tag + ")");
return this.doc.createElement(tag);
};
HMLBuilder.prototype.wrapperEl = function(tag, inner) {
var wel;
HMLBuilder.trace("HML: wrapperEl(" + tag + ")");
wel = this.newHMLElement(tag);
wel.appendChild(inner);
return wel;
};
HMLBuilder.prototype.wrapPair = function(tag, inner0, inner1) {
var wel;
HMLBuilder.trace("HML: wrapPair(" + tag + ")");
wel = this.wrapperEl(tag, inner0);
wel.appendChild(inner1);
return wel;
};
HMLBuilder.prototype.wrapIfNeeded = function(tag, el) {
var elIsOK;
elIsOK = el.tagName === tag && !(el.hasAttributes());
HMLBuilder.trace("HML: wrapIfNeeded(" + tag + ") Needed is " + elIsOK);
if (elIsOK) {
return el;
} else {
return this.wrapperEl(tag, el);
}
};
HMLBuilder.prototype.stripParentIfNotNeeded = function(el) {
var child, res;
HMLBuilder.trace("HML: stripParentIfNotNeeded");
res = el;
child = el.firstChild;
if (el.tagName === (child != null ? child.tagName : void 0) && !(el.hasAttributes())) {
HMLBuilder.trace("HML: stripParentIfNotNeeded removing child");
res = el.removeChild(child);
}
return res;
};
HMLBuilder.prototype.elementFromList = function(al, etag) {
var e, elmem, i, ix, len;
HMLBuilder.trace("HML: elementFromList " + etag + " length " + al.length);
if (al.length === 1) {
return al[0];
} else {
e = this.newHMLElement(etag);
for (ix = i = 0, len = al.length; i < len; ix = ++i) {
elmem = al[ix];
HMLBuilder.trace("HML: elementFromList " + etag + " append child " + ix + " " + elmem.tagName);
e.appendChild(elmem);
}
return e;
}
};
HMLBuilder.prototype.rootEl = function(inner) {
this.doc.documentElement.appendChild(inner);
return this.doc;
};
HMLBuilder.prototype.appendChildList = function(el, chl) {
var chlel, i, len, results;
results = [];
for (i = 0, len = chl.length; i < len; i++) {
chlel = chl[i];
results.push(this.checkedAppendChild(el, chlel));
}
return results;
};
HMLBuilder.prototype.checkedAppendChildList = function(el, chl) {
if (chl != null) {
return this.appendChildList(el, chl);
}
};
HMLBuilder.prototype.checkedAppendChild = function(el, ch) {
if (ch != null) {
return el.appendChild(ch);
}
};
HMLBuilder.prototype.checkedSetAttr = function(el, aname, aval) {
if (aval != null) {
HMLBuilder.trace("HML: checkedSetAttr: " + aname + " set to " + aval);
return el.setAttribute(aname, aval);
} else {
return HMLBuilder.trace("HML: checkedSetAttr: " + aname + " not set");
}
};
HMLBuilder.prototype.checkedSetFlagAttr = function(el, aname, flagIsTrue) {
if (flagIsTrue) {
return el.setAttribute(aname, "true");
}
};
HMLBuilder.prototype.checkedStringSetFlagAttr = function(el, aname, aval) {
if (aval === "true") {
HMLBuilder.trace("HML: checkedStringSetFlagAttr: " + aname + " set to true");
return el.setAttribute(aname, "true");
} else {
return HMLBuilder.trace("HML: checkedStringSetFlagAttr: " + aname + " not set for " + aval);
}
};
HMLBuilder.prototype.insertNonManual = function(signel, nmstr) {
var aid, aval, chEl, childtag, fullnmtag, i, len, nmEl, ref;
HMLBuilder.trace("HML: insertNonManual: \"" + nmstr + "\"");
if (nmstr.length > 0) {
HMLBuilder.trace("NM: <" + Defs.HNS_NONMAN_TAG + ">");
nmEl = this.newHMLElement(Defs.HNS_NONMAN_TAG);
ref = nmstr.split(/\s+/);
for (i = 0, len = ref.length; i < len; i++) {
fullnmtag = ref[i];
childtag = this._hnsNMElementTag(fullnmtag);
aid = this._hnsNMAttrName(fullnmtag);
aval = this._hnsNMAttrValueFull(fullnmtag);
HMLBuilder.trace("NM: <" + childtag + " " + aid + "=\"" + aval + "\"/>");
chEl = this.newHMLElement(childtag);
this.checkedSetAttr(chEl, aid, aval);
this.checkedAppendChild(nmEl, chEl);
}
HMLBuilder.trace("NM: </" + Defs.HNS_NONMAN_TAG + ">");
signel.insertBefore(nmEl, signel.firstChild);
return HMLBuilder.trace("NM: Inserted");
}
};
HMLBuilder.prototype._hnsNMElementTag = function(nmtag) {
var ID, ei, hnseltag, mgi, nmi, t;
t = (nmtag.charAt(0)).toLowerCase();
if (t === Defs.MOUTH_PICTURE_LETTER) {
return Defs.HNS_MOUTHPICTURE_TAG;
} else {
mgi = Defs.MOUTH_GESTURE_LETTERS.indexOf(t);
if (0 <= mgi) {
hnseltag = Defs.HNS_MOUTHGESTURE_TAG;
} else {
nmi = Defs.NON_MOUTH_RELATED_LETTERS.indexOf(t);
if (0 <= nmi) {
hnseltag = Defs.NON_MOUTH_RELATED_HML_TAGS[nmi];
if (hnseltag === null) {
ID = (nmtag.substring(1)).toUpperCase();
ei = 0;
while (ei < Defs.EYES_TAG_LISTS.length && (Defs.EYES_TAG_LISTS[ei].indexOf(ID)) < 0) {
ei++;
}
if (ei < Defs.EYES_TAG_LISTS.length) {
hnseltag = Defs.EYE_RELATED_HML_TAGS[ei];
} else {
hnseltag = Defs.HNS_EXTRA_TAG;
}
}
} else {
hnseltag = Defs.HNS_EXTRA_TAG;
}
}
return hnseltag;
}
};
HMLBuilder.prototype._hnsNMAttrName = function(nmtag) {
var tagLetter;
tagLetter = (nmtag.charAt(0)).toLowerCase();
if (tagLetter === Defs.MOUTH_PICTURE_LETTER) {
return Defs.PICTURE_ATTR;
} else {
return Defs.TAG_ATTR;
}
};
HMLBuilder.prototype._hnsNMAttrValueFull = function(nmtag) {
var htail, htailU, tlL, tlU;
tlL = (nmtag.charAt(0)).toLowerCase();
tlU = tlL.toUpperCase();
htail = nmtag.substring(1);
htailU = tlL === Defs.MOUTH_PICTURE_LETTER ? null : htail.toUpperCase();
if (tlL === Defs.MOUTH_PICTURE_LETTER) {
return htail;
} else if (0 <= Defs.MOUTH_GESTURE_LETTERS.indexOf(tlL)) {
return "" + tlU + htailU;
} else if (0 <= Defs.NON_MOUTH_RELATED_LETTERS.indexOf(tlL)) {
return htailU;
} else {
return "" + tlU + htailU;
}
};
HMLBuilder.prototype._xmlAttrValueString = function(aval) {
var abuf, ch, i, len, xs;
abuf = "";
for (i = 0, len = aval.length; i < len; i++) {
ch = aval[i];
xs = Defs.xmlSpecials.indexOf(ch);
abuf += xs < 0 ? ch : Defs.xmlEscapes[xs];
}
return abuf;
};
HMLBuilder.setLogLevel = function(lev) {
return logLev = lev;
};
HMLBuilder.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
return HMLBuilder;
})();
cwaenv.add(HMLBuilder, "HMLBuilder");
}).call(this);
//-------- js/HNSSign.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Defs, HNSSign, Node, cwaenv, logLev;
cwaenv = this.getCWAEnv();
Node = cwaenv.get("Node");
Defs = cwaenv.get("HNSDefs");
logLev = 0;
HNSSign = (function() {
function HNSSign(hnsEl, lev) {
this.hnsEl = hnsEl;
if (lev != null) {
logLev = lev;
}
this.hnsMan = "";
this.hnsNonMan = "";
this.hnsGloss = null;
this.hnsDuration = null;
this.hnsSpeed = null;
this.hnsTimeScale = null;
this.hnsSignElText = null;
this.hnsErr = null;
HNSSign.trace("HNS Sign object created");
this.scanRoot();
HNSSign.trace("Gloss:     [" + this.hnsGloss + "]");
HNSSign.trace("Manual:    [" + this.hnsMan + "]");
HNSSign.trace("Nonmanual: [" + this.hnsNonMan + "]");
}
HNSSign.prototype.scanRoot = function() {
var ref, ref1, ref2, ref3;
HNSSign.trace("Root Name " + this.hnsEl.nodeName);
if (this.hnsEl.nodeName === "hns_sign") {
this.hnsGloss = (ref = this.hnsEl.attributes.getNamedItem("gloss")) != null ? ref.value : void 0;
this.hnsDuration = (ref1 = this.hnsEl.attributes.getNamedItem("duration")) != null ? ref1.value : void 0;
this.hnsSpeed = (ref2 = this.hnsEl.attributes.getNamedItem("speed")) != null ? ref2.value : void 0;
this.hnsTimeScale = (ref3 = this.hnsEl.attributes.getNamedItem("timescale")) != null ? ref3.value : void 0;
return this._scanSign(this.hnsEl);
}
};
HNSSign.prototype._scanSign = function(el) {
var i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
HNSSign.trace("Sign Name " + nd.nodeName);
if (nd.nodeName === "hamnosys_manual") {
results.push(this._scanMan(nd));
} else if (nd.nodeName === "hamnosys_nonmanual") {
results.push(this._scanNonMan(nd));
} else {
results.push(void 0);
}
}
return results;
};
HNSSign.prototype._scanMan = function(el) {
var hamVal, i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (!(nd.nodeType === Node.ELEMENT_NODE)) {
continue;
}
hamVal = Defs.hamMap[nd.nodeName];
if (hamVal != null) {
HNSSign.trace("Man Element Name " + nd.nodeName + "=" + (hamVal.charCodeAt(0)));
this.hnsMan += hamVal;
} else {
console.warn("Manual Element not recognised: " + nd.nodeName);
}
results.push(this._scanMan(nd));
}
return results;
};
HNSSign.prototype._nonManVal = function(el) {
var currTag, i, ix, j, k, len, len1, len2, newTok, ref, ref1, tagMatch, tagVal, tags, testTag, theTag, tok;
theTag = el.tagName;
if (theTag === Defs.HNS_MOUTHPICTURE_TAG) {
tok = Defs.MOUTH_PICTURE_LETTER + el.getAttribute(Defs.PICTURE_ATTR);
} else {
tagVal = el.getAttribute(Defs.TAG_ATTR);
if (theTag === Defs.HNS_MOUTHGESTURE_TAG) {
tok = tagVal;
} else {
tok = "";
tags = (tagVal.replace(/\s/g, "")).split("|");
for (i = 0, len = tags.length; i < len; i++) {
currTag = tags[i];
tagMatch = -1;
ref = Defs.EYE_RELATED_HML_TAGS;
for (ix = j = 0, len1 = ref.length; j < len1; ix = ++j) {
testTag = ref[ix];
if (theTag === testTag) {
tagMatch = ix;
}
}
if (tagMatch >= 0) {
newTok = Defs.EYES_LETTER + currTag;
} else {
ref1 = Defs.NON_MOUTH_RELATED_HML_TAGS;
for (ix = k = 0, len2 = ref1.length; k < len2; ix = ++k) {
testTag = ref1[ix];
if (theTag === testTag) {
tagMatch = ix;
}
}
if (tagMatch >= 0) {
newTok = (Defs.NON_MOUTH_RELATED_LETTERS.charAt(tagMatch)) + currTag;
} else {
newTok = currTag;
}
}
tok = (tok === "" ? "" : tok + " ") + newTok;
}
}
}
return tok;
};
HNSSign.prototype._scanNonMan = function(el) {
var hamVal, i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (!(nd.nodeType === Node.ELEMENT_NODE)) {
continue;
}
hamVal = this._nonManVal(nd);
HNSSign.trace("NonMan Element Name " + nd.nodeName + ": " + hamVal);
if (this.hnsNonMan.length > 0) {
this.hnsNonMan += " ";
}
this.hnsNonMan += hamVal;
results.push(this._scanNonMan(nd));
}
return results;
};
HNSSign.prototype.man = function() {
return this.hnsMan;
};
HNSSign.prototype.nonman = function() {
return this.hnsNonMan;
};
HNSSign.prototype.gloss = function() {
return this.hnsGloss;
};
HNSSign.prototype.duration = function() {
return this.hnsDuration;
};
HNSSign.prototype.speed = function() {
return this.hnsSpeed;
};
HNSSign.prototype.timeScale = function() {
return this.hnsTimeScale;
};
HNSSign.setLogLevel = function(lev) {
return logLev = lev;
};
HNSSign.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
return HNSSign;
})();
cwaenv.add(HNSSign, "HNSSign");
}).call(this);
//-------- js/XSLT.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, XSLT, cwaenv, logLev;
cwaenv = this.getCWAEnv();
Data = cwaenv.get("Data");
logLev = 0;
XSLT = (function() {
function XSLT(xslURI, lev) {
this.xslURI = xslURI;
if (lev != null) {
logLev = lev;
}
this.xsltProcessor = null;
this.hasXSLTP = typeof XSLTProcessor !== "undefined" && XSLTProcessor !== null;
XSLT.trace("XSLT processor created for " + this.xslURI);
}
XSLT.prototype.applyXSLT = function(theXML) {
var docRes, docTxt, err, xmlTxt, xmldom;
XSLT.trace("XSLT stylesheet " + this.xslURI + " apply");
try {
if (this.hasXSLTP) {
docRes = this.xsltProcessor.transformToDocument(theXML, document);
} else {
xmlTxt = Data.mnDOM(theXML);
xmldom = new ActiveXObject("Msxml2.DOMDocument.6.0");
xmldom.validateOnParse = true;
xmldom.async = false;
xmldom.loadXML(xmlTxt);
docTxt = xmldom.transformNode(this.xsltProcessor);
docRes = Data.toDOM(docTxt);
}
return docRes.documentElement;
} catch (error) {
err = error;
console.err("XSLT transform failure: " + err);
return null;
}
};
XSLT.prototype.syncXSLT = function(theCB) {
var ssCB;
if (this.xsltProcessor) {
return theCB();
} else {
ssCB = (function(_this) {
return function(ssText) {
var ssDOM;
if (_this.hasXSLTP) {
ssDOM = Data.toDOM(ssText);
_this.xsltProcessor = new XSLTProcessor;
_this.xsltProcessor.importStylesheet(ssDOM);
XSLT.trace("XSLT stylesheet " + _this.xslURI + " parsed");
} else {
_this.xsltProcessor = new ActiveXObject("Msxml2.DOMDocument.6.0");
_this.xsltProcessor.validateOnParse = true;
_this.xsltProcessor.async = false;
_this.xsltProcessor.loadXML(ssText);
}
return theCB();
};
})(this);
return Data.fetchText(this.xslURI, ssCB);
}
};
XSLT.setLogLevel = function(lev) {
return logLev = lev;
};
XSLT.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
return XSLT;
})();
cwaenv.add(XSLT, "XSLT");
}).call(this);
//-------- js/HtoG.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, HMLBuilder, HNSSign, Ham4Parser, HamLexer, HtoG, Node, XSLT, cwaenv, logLev;
cwaenv = this.getCWAEnv();
Data = cwaenv.get("Data");
Node = cwaenv.get("Node");
HNSSign = cwaenv.get("HNSSign");
HamLexer = cwaenv.get("HamLexer");
Ham4Parser = cwaenv.get("Ham4Parser");
HMLBuilder = cwaenv.get("HMLBuilder");
XSLT = cwaenv.get("XSLT");
logLev = 0;
HtoG = (function() {
function HtoG(XSLTURI, hmlLog, logLev1) {
this.XSLTURI = XSLTURI;
this.hmlLog = hmlLog != null ? hmlLog : false;
this.logLev = logLev1 != null ? logLev1 : 0;
this.XSLTProc = new XSLT(this.XSLTURI);
this.trace("HtoG processor created for \"" + this.XSLTURI + "\"");
}
HtoG.prototype.treeString = function(el) {
var i, j, n, ref, res;
res = "";
if (el) {
res = "(" + el;
n = el.getChildCount();
for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
res += " " + this.treeString(el.getChild(i));
}
res += ")";
}
return res;
};
HtoG.prototype._sortAttrs = function(el) {
var attList, attr, j, k, l, len, len1, len2, nd, newList, ref, results;
if (el.hasChildNodes()) {
ref = el.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
nd = ref[j];
if (nd.nodeType === Node.ELEMENT_NODE || nd.nodeType === Node.DOCUMENT_NODE) {
this._sortAttrs(nd);
}
}
}
if (el.nodeType === Node.ELEMENT_NODE && el.hasAttributes() && el.attributes.length > 1) {
attList = (function() {
var k, len1, ref1, results;
ref1 = el.attributes;
results = [];
for (k = 0, len1 = ref1.length; k < len1; k++) {
attr = ref1[k];
results.push(attr);
}
return results;
})();
newList = attList.sort(function(a, b) {
return a.name > b.name;
});
for (k = 0, len1 = attList.length; k < len1; k++) {
attr = attList[k];
el.removeAttribute(attr.name);
}
results = [];
for (l = 0, len2 = newList.length; l < len2; l++) {
attr = newList[l];
results.push(el.setAttribute(attr.name, attr.value));
}
return results;
}
};
HtoG.prototype.sortDocAttrs = function(doc) {
this._sortAttrs(doc.documentElement);
return doc;
};
HtoG.prototype._parseHSign = function(sigDoc) {
var builder, errReport, hamString, hmlDoc, lexer, parser, root, sigtrans, sigtree, treewalker;
this.trace("SiGML: " + sigDoc + " " + (Data.ppDOM(sigDoc)));
hmlDoc = new HNSSign(sigDoc);
hamString = hmlDoc.man();
lexer = new HamLexer(hamString, Ham4Parser.tokenNames, 0);
lexer.setLogLevel(this.logLev);
parser = new Ham4Parser(lexer);
parser.setLogLevel(this.logLev);
root = (parser.hamsinglesign()).getTree();
errReport = parser.checkErrors();
if (errReport != null) {
this.trace("Parse errors: " + errReport.errCount + ": " + errReport.errText);
return errReport;
} else {
this.trace("After parsing: " + (this.treeString(root)));
treewalker = new Ham4HMLGen(new org.antlr.runtime.tree.CommonTreeNodeStream(root));
HMLBuilder.setLogLevel(this.logLev);
builder = new HMLBuilder;
try {
sigtree = treewalker.hamsignseq(builder);
builder.insertNonManual(sigtree.documentElement, hmlDoc.nonman());
builder.checkedSetAttr(sigtree.documentElement, "gloss", hmlDoc.gloss());
builder.checkedSetAttr(sigtree.documentElement, "duration", hmlDoc.duration());
builder.checkedSetAttr(sigtree.documentElement, "speed", hmlDoc.speed());
builder.checkedSetAttr(sigtree.documentElement, "timescale", hmlDoc.timeScale());
this.trace("After tree building:\n" + (Data.ppDOM(sigtree)));
if (this.hmlLog) {
console.warn("########  HML -- gloss: " + (hmlDoc.gloss()) + "  ########\n" + (Data.ppDOM(sigtree)) + "\n");
}
sigtrans = this.XSLTProc.applyXSLT(sigtree);
this.trace("After XSLT processing:\n" + (Data.ppDOM(sigtrans)));
return {
sigDoc: sigtrans
};
} catch (error) {
this.trace("Failed tree building or XSLT transformation");
return {
errCount: 1,
errText: "Failed tree building or XSLT transformation"
};
}
}
};
HtoG.prototype._cleanSiGML = function(parent) {
var cn, j, k, len, len1, nd, nds, ref;
nds = [];
ref = parent.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
cn = ref[j];
if (cn != null) {
nds.push(cn);
}
}
for (k = 0, len1 = nds.length; k < len1; k++) {
nd = nds[k];
switch (nd.nodeType) {
case Node.COMMENT_NODE:
case Node.TEXT_NODE:
parent.removeChild(nd);
break;
default:
if (nd.childNodes != null) {
this._cleanSiGML(nd);
}
}
}
return parent;
};
HtoG.prototype._parseSiGML = function(sigDoc) {
var errCount, errText, gloss, j, len, nd, nom, parseRes, ref, ref1, ref2, signIx, typ;
errCount = 0;
errText = "";
signIx = 0;
if (sigDoc.documentElement != null) {
this._cleanSiGML(sigDoc);
ref = sigDoc.documentElement.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
nd = ref[j];
nom = nd != null ? nd.nodeName : void 0;
typ = nd != null ? nd.nodeType : void 0;
this.trace("SiGML Element: " + typ + " " + nom);
if (nom === "hns_sign") {
signIx + (gloss = (ref1 = nd.attributes.getNamedItem("gloss")) != null ? ref1.value : void 0);
this.trace("Sign " + signIx + ": " + nom + " gloss: " + gloss);
parseRes = this._parseHSign(nd);
if (parseRes != null ? parseRes.errText : void 0) {
errCount++;
errText += parseRes.errText + " [Sign: " + signIx + " Gloss: \"" + gloss + "\"]";
sigDoc.documentElement.removeChild(nd);
} else if (parseRes != null ? parseRes.sigDoc : void 0) {
sigDoc.documentElement.replaceChild(parseRes.sigDoc, nd);
}
} else if (nom === "hamgestural_sign") {
signIx++;
this.trace("Sign " + signIx + ": " + nom + " gloss: " + ((ref2 = nd.attributes.getNamedItem("gloss")) != null ? ref2.value : void 0));
}
}
} else {
errCount++;
errText += "Invalid SiGML file";
sigDoc = null;
}
return {
sigDoc: sigDoc,
errCount: errCount,
errText: errText
};
};
HtoG.prototype.parseHtoGText = function(sigTxt, theCB) {
var errCount, errText, errXML, gotXSLT, res, sigDoc;
errCount = 0;
errText = "";
res = {};
errXML = (function(_this) {
return function(level, msg) {
errCount++;
return errText += "XML parse " + level + ": " + msg;
};
})(this);
sigDoc = Data.toDOM("" + sigTxt, errXML);
if (sigDoc != null) {
res.sigDoc = sigDoc;
}
if (errCount > 0) {
res.errCount = errCount;
res.errText = errText;
return theCB(res);
} else {
gotXSLT = (function(_this) {
return function() {
return theCB(_this._parseSiGML(res.sigDoc));
};
})(this);
return this.XSLTProc.syncXSLT(gotXSLT);
}
};
HtoG.prototype.parseHtoGURI = function(sigURI, theCB) {
var gotSiGML, res;
res = {};
gotSiGML = (function(_this) {
return function(sigDoc, errCount, msg) {
if (errCount > 0) {
res.errCount = errCount;
res.errText = "SiGML fetch: " + msg;
if (sigDoc != null) {
res.sigDoc = sigDoc;
}
return theCB(res);
} else if (sigDoc != null) {
return _this.parseHtoGText(sigDoc, theCB);
} else {
res.errCount = 1;
res.errText = "No SiGML data found";
return theCB(res);
}
};
})(this);
return Data.fetchText(sigURI, gotSiGML);
};
HtoG.prototype.setLogLevel = function(lev) {
return this.logLev = lev;
};
HtoG.prototype.setHMLLog = function(flag) {
return this.hmlLog = flag;
};
HtoG.prototype.trace = function(str) {
if (this.logLev >= 440) {
return console.log(str);
}
};
return HtoG;
})();
cwaenv.add(HtoG, "HtoG");
}).call(this);
//-------- js/AmbientAnim.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AmbientAnim, CASFrame, CASMorph, CASTRSet, RQ, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
RQ = cwaenv.get("RotQuat");
CASTRSet = cwaenv.get("CASTRSet");
CASMorph = cwaenv.get("CASMorph");
CASFrame = cwaenv.get("CASFrame");
AmbientAnim = (function() {
function AmbientAnim() {
this.AMBIENT_FPS = 0;
this.N_FRAMES = 0;
this.CYCLE_TIME = 0;
this.ixAmbient = 0;
this.tAmbient = 0;
this.tCurrent = 0;
}
AmbientAnim.create = function(aframes, fps) {
var aa;
aa = new AmbientAnim;
aa.set(aframes, fps);
return aa;
};
AmbientAnim.prototype.set = function(aframes, fps) {
var lastfrm;
this.AMBIENT_FPS = fps;
this.AMBIENT_FRAMES = aframes;
this.N_FRAMES = aframes.length;
lastfrm = aframes[this.N_FRAMES - 1];
return this.CYCLE_TIME = (lastfrm.getTime()) + (lastfrm.getDuration());
};
AmbientAnim.prototype.resetClock = function() {
this.ixAmbient = 0;
this.tAmbient = 0;
return this.tCurrent = 0;
};
AmbientAnim.prototype.randomResetClock = function() {
var IX;
this.ixAmbient = IX = Math.floor((Math.random()) * this.N_FRAMES);
return this.tCurrent = this.tAmbient = this.AMBIENT_FRAMES[IX].getTime();
};
AmbientAnim.prototype.synchClock = function() {
return this.tCurrent = this.tAmbient;
};
AmbientAnim.prototype.getTime = function() {
return this.tCurrent;
};
AmbientAnim.prototype.getAmbientFPS = function() {
return this.AMBIENT_FPS;
};
AmbientAnim.prototype.getAmbientFrames = function() {
return this.AMBIENT_FRAMES;
};
AmbientAnim.prototype.adjust = function(frame, scale) {
return this.adjustForTime(frame, scale, frame.getTime());
};
AmbientAnim.prototype.adjustForTimeDelta = function(frame, scale, td) {
return this.adjustForTime(frame, scale, this.tCurrent + td);
};
AmbientAnim.prototype.adjustForTime = function(frame, scale, t) {
return this.applyAmbientToFrame(frame, this.findAmbientFrame(t)(), scale);
};
AmbientAnim.prototype.findAmbientFrame = function(t) {
var EPS, N_CYCLES, T_CYCLES, T_DELTA, T_REL, T_STEP, fcurr, fnext, frame, ix, tix, tixnext;
T_DELTA = t - this.tAmbient;
N_CYCLES = Math.floor(T_DELTA / this.CYCLE_TIME);
T_CYCLES = N_CYCLES * this.CYCLE_TIME;
T_REL = T_DELTA - T_CYCLES;
ix = this.ixAmbient;
tix = 0;
tixnext = this.AMBIENT_FRAMES[ix].getDuration();
while (tixnext <= T_REL) {
ix = this.nextAmbientIndex(ix);
tix = tixnext;
tixnext += this.AMBIENT_FRAMES[ix].getDuration();
}
T_STEP = tixnext - tix;
EPS = T_STEP * 0.05;
frame = null;
if (T_DELTA < tix + EPS) {
frame = this.AMBIENT_FRAMES[ix];
} else if (tixnext < T_DELTA + EPS) {
frame = this.AMBIENT_FRAMES[this.nextAmbientIndex(ix)];
} else {
fcurr = this.AMBIENT_FRAMES[ix];
fnext = this.AMBIENT_FRAMES[this.nextAmbientIndex(ix)];
frame = this.interpolate(fcurr, fnext, (T_DELTA - tix) / T_STEP);
}
this.ixAmbient = ix;
this.tAmbient += T_CYCLES + tix;
this.tCurrent = t;
return frame;
};
AmbientAnim.prototype.nextAmbientIndex = function(ix) {
var nextix;
nextix = ix + 1;
if (nextix === this.N_FRAMES) {
nextix = 0;
}
return nextix;
};
AmbientAnim.prototype.interpolate = function(fa, fb, T) {
var DUR_A, TM_A, TM_ADJ, bones, morphs;
bones = this.interpolateBones(fa.getTRSets(), fb.getTRSets(), T);
morphs = this.interpolateMorphs(fa, fb, T);
TM_A = fa.getTime();
DUR_A = fa.getDuration();
TM_ADJ = DUR_A * T;
return CASFrame.create(TM_A + TM_ADJ, DUR_A - TM_ADJ, bones, morphs);
};
AmbientAnim.prototype.interpolateBones = function(A_BONES, B_BONES, T) {
var A_4CC, A_BONE, A_TRANS, B_4CC, B_BONE, ISSUE, NEW_ROT, N_BONES, PFX_ID, bones, fourccerrs, i, j, lenok, qa, qb, qnew, ref;
bones = null;
lenok = true;
fourccerrs = 0;
if (A_BONES.length !== B_BONES.length) {
lenok = false;
} else {
N_BONES = A_BONES.length;
bones = new Array(N_BONES);
qa = new RQ;
qb = new RQ;
qnew = new RQ;
for (i = j = 0, ref = N_BONES; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
A_BONE = A_BONES[i];
B_BONE = B_BONES[i];
qa.setVec(A_BONE.getRotation());
qb.setVec(B_BONE.getRotation());
RQ.slerp(qnew, qa, qb, T);
NEW_ROT = qnew.copyXYZW();
A_4CC = A_BONE.getFourCC();
B_4CC = B_BONE.getFourCC();
if (A_4CC !== B_4CC) {
++fourccerrs;
}
A_TRANS = A_BONE.getTranslation();
bones[i] = CASTRSet.create(A_4CC, NEW_ROT, A_TRANS);
}
}
if (!lenok || fourccerrs !== 0) {
bones = A_BONES;
PFX_ID = "AmbientAnim.interpolateBones(): ";
ISSUE = !lenok ? "nonmatching bone-set sizes." : fourccerrs + " nonmatching bone-set indices.";
throw new Error(PFX_ID + ISSUE);
}
return bones;
};
AmbientAnim.prototype.makeMorphListWithExtras = function(A_FRAME, B_MORPHS) {
var A_MORPHS, bextras, morphs;
A_MORPHS = A_FRAME.getMorphs();
bextras = B_MORPHS.filter(function(bmph) {
return (A_FRAME.getMorph(bmph.getName())) === null;
});
morphs = new Array(A_MORPHS.length);
if (bextras.length) {
morphs = morphs.concat(bextras);
}
return morphs;
};
AmbientAnim.prototype.interpolateMorphs = function(fa, fb, T) {
var AMOUNT, A_MORPH, A_MORPHS, B_MORPH, B_MORPHS, M_4CC, j, len, m, morph, morphs;
A_MORPHS = fa.getMorphs();
B_MORPHS = fb.getMorphs();
morphs = null;
if (A_MORPHS.length === 0 && B_MORPHS.length === 0) {
morphs = A_MORPHS;
} else {
morphs = this.makeMorphListWithExtras(fa, B_MORPHS);
for (m = j = 0, len = A_MORPHS.length; j < len; m = ++j) {
A_MORPH = A_MORPHS[m];
M_4CC = A_MORPH.getName();
B_MORPH = fb.getMorph(M_4CC);
morph = A_MORPH;
if (B_MORPH !== null) {
AMOUNT = (A_MORPH.getAmount()) * (1 - T) + (B_MORPH.getAmount()) * T;
morph = CASMorph.create(M_4CC, AMOUNT);
}
morphs[m] = morph;
}
}
return morphs;
};
AmbientAnim.prototype.applyAmbientToFrame = function(frame, ambientframe, scale) {
var FBONES, FMORPHS, NEW_BONES, NEW_MORPHS;
NEW_BONES = this.bonesWithAmbient(frame, ambientframe, scale);
NEW_MORPHS = this.morphsWithAmbient(frame, ambientframe, scale);
FBONES = frame.getTRSets();
FMORPHS = frame.getMorphs();
if (NEW_BONES === FBONES && NEW_MORPHS === FMORPHS) {
return frame;
} else {
return CASFrame.create(frame.getTime(), frame.getDuration(), NEW_BONES, NEW_MORPHS);
}
};
AmbientAnim.prototype.bonesWithAmbient = function(frame, ambientframe, scale) {
var AMB_BONE, AMB_BONES, BONE, BONES, NAME, NEW_BONES, N_BONES, TRANS, b, j, len, newbone, qamb, qnew;
BONES = frame.getTRSets();
AMB_BONES = ambientframe.getTRSets();
N_BONES = BONES.length;
NEW_BONES = AMB_BONES.length === 0 ? BONES : new Array(N_BONES);
if (NEW_BONES !== BONES) {
qnew = new RQ;
qamb = new RQ;
for (b = j = 0, len = BONES.length; j < len; b = ++j) {
BONE = BONES[b];
NAME = BONE.getFourCC();
newbone = BONE;
AMB_BONE = ambientframe.getTRSet(NAME);
if (AMB_BONE !== null) {
qnew.setVec(BONE.getRotation());
qamb.setVec(AMB_BONE.getRotation());
qamb.setScaleRot(scale);
qnew.setPostMultiply(qamb);
TRANS = BONE.getTranslation();
newbone = CASTRSet.create(NAME, qnew.copyXYZW(), TRANS);
}
NEW_BONES[b] = newbone;
}
}
return NEW_BONES;
};
AmbientAnim.prototype.morphsWithAmbient = function(frame, ambientframe, scale) {
var AMB_AMT, AMB_MORPH, AMB_MORPHS, MORPH, MORPHS, M_4CC, amt, j, len, m, newmorph, newmorphs;
MORPHS = frame.getMorphs();
AMB_MORPHS = ambientframe.getMorphs();
newmorphs = MORPHS;
if (AMB_MORPHS.length !== 0) {
newmorphs = this.makeMorphListWithExtras(frame, AMB_MORPHS);
for (m = j = 0, len = MORPHS.length; j < len; m = ++j) {
MORPH = MORPHS[m];
M_4CC = MORPH.getName();
newmorph = MORPH;
AMB_MORPH = ambientframe.getMorph(M_4CC)();
if (AMB_MORPH !== null) {
AMB_AMT = (AMB_MORPH.getAmount()) * scale;
amt = (MORPH.getAmount()) + AMB_AMT;
if (1 < amt) {
amt = 1;
}
newmorph = CASMorph.create(M_4CC, amt);
}
newmorphs[m] = newmorph;
}
}
return newmorphs;
};
return AmbientAnim;
})();
cwaenv.add(AmbientAnim, "AmbientAnim");
}).call(this);
//-------- js/Character.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AmbientAnim, CASFrame, CASTRSet, Character, Config, Mesh, Skeleton, V3, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Config = cwaenv.get("Config");
V3 = cwaenv.get("E3Vec");
CASTRSet = cwaenv.get("CASTRSet");
CASFrame = cwaenv.get("CASFrame");
Skeleton = cwaenv.get("Skeleton");
Mesh = cwaenv.get("Mesh");
AmbientAnim = cwaenv.get("AmbientAnim");
Character = (function() {
function Character() {
this.gl = null;
this.avBase = "";
this.readJSON = null;
this.avatarName = "";
this.volMin = null;
this.volMax = null;
this.meshes = [];
this.defaultPose = null;
this.skeleton = null;
this.textureFileName = "";
this.jsonTextureURL = "";
this.currentMorphs = [];
this.scaleFromMetres = -1;
this.ambientAnim = null;
this.USE_TRX_BONE_DATA = true;
this.TEST_CPU_TRX_TO_MAT = false;
}
Character.STD_AVATAR_HEIGHT_METRES = 1.80;
Character.STD_MAX_Y_METRES = 0.75;
Character.prototype.loadJSON = function(gl, avatarName) {
this.gl = gl;
this.avatarName = avatarName;
console.warn("Loading JSON avatar " + this.avatarName + " not supported");
return null;
};
Character.prototype.loadJSONOrig = function(gl, avatarName) {
var VER_3_DIG, jsnchrctr;
this.gl = gl;
this.avatarName = avatarName;
this.avBase = Config.getAvBase(this.avatarName);
this.readJSON = (function(_this) {
return function(jfile) {
console.warn("Synchronous reading of JSON data not possible for " + _this.avBase + jfile);
return null;
};
})(this);
jsnchrctr = this.readJSON("avdef.json");
VER_3_DIG = Math.floor(100 * Number(jsnchrctr.version));
if (VER_3_DIG < 310) {
throw new Error("Avatar version " + VER_3_DIG + " is not viable!");
}
this.loadVolumeLimits(jsnchrctr);
this.loadMeshes(jsnchrctr);
this.loadInitPose(jsnchrctr);
this.loadSkeleton(jsnchrctr);
this.loadAmbientMotionDef(jsnchrctr);
this.loadTextureData(jsnchrctr);
this.setUpTextureFromJSON();
this.setLengthScaleFactor();
this.setUpMeshesForGL();
return void 0;
};
Character.prototype.loadBinary = function(gl, avatarName, avdv) {
var VER_3_DIG, version;
this.gl = gl;
this.avatarName = avatarName;
version = avdv.nextStr();
VER_3_DIG = Math.floor(100 * Number(version));
if (VER_3_DIG < 310) {
throw new Error("(Binary) Avatar version " + VER_3_DIG + " is not viable!");
}
this.scale = avdv.nextFloat();
this.loadVolumeLimitsBin(avdv);
this.matRefl = avdv.nextVec3();
this.skelYOffset = avdv.nextFloat();
this.loadMeshesBin(avdv);
this.loadInitPoseBin(avdv);
this.loadSkeletonBin(avdv);
this.loadAmbientMotionDefBin(avdv);
this.loadTextureDataBin(avdv);
this.setUpTextureFromAvDV(avdv);
this.setLengthScaleFactor();
this.setUpMeshesForGL();
return void 0;
};
Character.prototype.getDefaultPose = function() {
return CASFrame.create(0, 40, this.defaultPose, null);
};
Character.prototype.getEmptyPose = function() {
return CASFrame.create(0, 40, [], null);
};
Character.prototype.setUpTextureFromJSON = function() {
var i, len, mesh, ref;
ref = this.meshes;
for (i = 0, len = ref.length; i < len; i++) {
mesh = ref[i];
mesh.createTextureFromJSON(this.jsonTextureURL);
}
return void 0;
};
Character.prototype.setUpTextureFromAvDV = function(avdv) {
var i, len, mesh, ref;
ref = this.meshes;
for (i = 0, len = ref.length; i < len; i++) {
mesh = ref[i];
mesh.createTextureFromAvDV(avdv, this.textureFileName, this.mustFlip);
}
return void 0;
};
Character.prototype.setUpMeshesForGL = function() {
var i, len, mesh, ref;
ref = this.meshes;
for (i = 0, len = ref.length; i < len; i++) {
mesh = ref[i];
mesh.prepareForGL(this.skeleton);
}
return void 0;
};
Character.prototype.loadVolumeLimits = function(jsnchrctr) {
this.volMin = V3.fromVec(jsnchrctr.volMin);
return this.volMax = V3.fromVec(jsnchrctr.volMax);
};
Character.prototype.loadVolumeLimitsBin = function(avdv) {
this.volMin = V3.fromVec(avdv.nextVec3());
return this.volMax = V3.fromVec(avdv.nextVec3());
};
Character.prototype.loadMeshes = function(jsnchrctr) {
this.meshes = jsnchrctr.meshes.map((function(_this) {
return function(mfname) {
var mesh;
mesh = new Mesh(_this.gl, _this.USE_TRX_BONE_DATA, _this.TEST_CPU_TRX_TO_MAT);
mesh.setFromJSON(_this.readJSON(mfname));
return mesh;
};
})(this));
return void 0;
};
Character.prototype.loadMeshesBin = function(avdv) {
var i, nMeshes, results;
nMeshes = avdv.nextUint();
this.meshes = (function() {
results = [];
for (var i = 0; 0 <= nMeshes ? i < nMeshes : i > nMeshes; 0 <= nMeshes ? i++ : i--){ results.push(i); }
return results;
}).apply(this).map((function(_this) {
return function() {
var mesh;
mesh = new Mesh(_this.gl, _this.USE_TRX_BONE_DATA, _this.TEST_CPU_TRX_TO_MAT);
mesh.setFromBin(avdv);
return mesh;
};
})(this));
return void 0;
};
Character.prototype.loadInitPose = function(jsnchrctr) {
return this.defaultPose = jsnchrctr.initPose.map(CASTRSet.fromJSON);
};
Character.prototype.loadInitPoseBin = function(avdv) {
var b, nInitPose;
nInitPose = avdv.nextUint();
return this.defaultPose = (function() {
var i, ref, results;
results = [];
for (b = i = 0, ref = nInitPose; 0 <= ref ? i < ref : i > ref; b = 0 <= ref ? ++i : --i) {
results.push(CASTRSet.fromBin(avdv));
}
return results;
})();
};
Character.prototype.loadSkeleton = function(jsnchrctr) {
return this.skeleton = Skeleton.create(jsnchrctr.skelBones, this.USE_TRX_BONE_DATA, this.TEST_CPU_TRX_TO_MAT);
};
Character.prototype.loadSkeletonBin = function(avdv) {
return this.skeleton = Skeleton.fromBin(avdv, this.USE_TRX_BONE_DATA, this.TEST_CPU_TRX_TO_MAT);
};
Character.prototype.loadAmbientMotionDef = function(jsnchrctr) {
var amfrms, jsnamb;
amfrms = null;
if (jsnchrctr.ambientFrames) {
amfrms = jsnchrctr.ambientFrames.map(CASFrame.fromJSON);
} else if (jsnchrctr.ambientFileName) {
jsnamb = this.readJSON(jsnchrctr.ambientFileName);
amfrms = jsnamb.ambientFrames.map(CASFrame.fromJSON);
}
this.ambientAnim = !amfrms ? null : AmbientAnim.create(amfrms, jsnchrctr.ambientFPS);
return void 0;
};
Character.prototype.loadAmbientMotionDefBin = function(avdv) {
var ambFPS, f, frame, frames, i, len, nAmbFrames, t, tNxt;
this.ambientAnim = null;
nAmbFrames = avdv.nextUint();
if (nAmbFrames !== 0) {
ambFPS = avdv.nextFloat();
frames = (function() {
var i, ref, results;
results = [];
for (f = i = 0, ref = nAmbFrames; 0 <= ref ? i < ref : i > ref; f = 0 <= ref ? ++i : --i) {
results.push(CASFrame.fromBin(avdv));
}
return results;
})();
t = 0;
for (f = i = 0, len = frames.length; i < len; f = ++i) {
frame = frames[f];
tNxt = (f + 1) * 1000 / ambFPS;
frame.setTime(t);
frame.setDuration(tNxt - t);
t = tNxt;
}
this.ambientAnim = AmbientAnim.create(frames, ambFPS);
}
return void 0;
};
Character.prototype.loadTextureData = function(jsnchrctr) {
this.textureFileName = jsnchrctr.textureFileName;
return this.jsonTextureURL = "" + this.avBase + this.textureFileName;
};
Character.prototype.loadTextureDataBin = function(avdv) {
var j;
this.textureFileName = avdv.nextStr();
this.textureFlags = (function() {
var i, results;
results = [];
for (j = i = 0; i < 12; j = ++i) {
results.push(avdv.nextBool());
}
return results;
})();
return this.mustFlip = !this.textureFlags[5];
};
Character.prototype.setLengthScaleFactor = function() {
return this.scaleFromMetres = ((this.volMax.y()) - (this.volMin.y())) / Character.STD_AVATAR_HEIGHT_METRES;
};
Character.prototype.getName = function() {
return this.avatarName;
};
Character.prototype.getAmbientFrames = function() {
var amb;
amb = this.ambientAnim;
if (amb) {
return amb.getAmbientFrames();
} else {
return [this.getEmptyPose()];
}
};
Character.prototype.getMetresToInternal = function() {
return this.scaleFromMetres;
};
Character.prototype.getAdjustViewY = function() {
var max_y_metres;
max_y_metres = (this.volMax.y()) / this.scaleFromMetres;
return max_y_metres - Character.STD_MAX_Y_METRES;
};
Character.prototype.setFrame = function(frame) {
this.skeleton.setBones(frame.getTRSets());
return this.currentMorphs = frame.getMorphs();
};
Character.prototype.draw = function(x, y, z, viewMatrix, projMatrix) {
var mesh;
mesh = this.meshes[0];
mesh.draw(this.skeleton, this.currentMorphs, x, y, z, viewMatrix, projMatrix);
return void 0;
};
return Character;
})();
cwaenv.add(Character, "Character");
}).call(this);
//-------- js/AvSpeedController.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AvSpeedController, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
AvSpeedController = (function() {
function AvSpeedController(domEls, seit) {
this.SPEED_EL_IS_TEXT = Boolean(seit);
this.displayEl = domEls.speedDisplay;
this.downEl = domEls.speedDown;
this.upEl = domEls.speedUp;
this.resetEl = domEls.speedReset;
this.stepsLo = -(2 * 6);
this.stepsHi = 2 * 3;
this._initGUI();
}
AvSpeedController.prototype._setElsValue = function(els, newval) {
var el, i, len, results;
results = [];
for (i = 0, len = els.length; i < len; i++) {
el = els[i];
results.push(el.value = newval);
}
return results;
};
AvSpeedController.prototype._setElsOnclick = function(els, hdlr) {
var el, i, len, results;
results = [];
for (i = 0, len = els.length; i < len; i++) {
el = els[i];
results.push(el.onclick = hdlr);
}
return results;
};
AvSpeedController.prototype._setElsDisabled = function(els, isDis) {
var el, i, len, results;
results = [];
for (i = 0, len = els.length; i < len; i++) {
el = els[i];
results.push(el.disabled = isDis);
}
return results;
};
AvSpeedController.prototype._initGUI = function() {
this._setElsOnclick(this.resetEl, ((function(_this) {
return function(evt) {
return _this.reset();
};
})(this)));
this._setElsOnclick(this.upEl, ((function(_this) {
return function(evt) {
return _this.increase();
};
})(this)));
this._setElsOnclick(this.downEl, ((function(_this) {
return function(evt) {
return _this.decrease();
};
})(this)));
return this.reset();
};
AvSpeedController.prototype._updateGUI = function() {
var sstr;
sstr = (this.nSteps / 2).toFixed(1);
if (0 <= this.nSteps) {
sstr = "+" + sstr;
}
if (this.SPEED_EL_IS_TEXT) {
this._setElsValue(this.displayEl, sstr);
} else {
this.displayEl[0].innerHTML = sstr;
}
this._setElsDisabled(this.downEl, this.nSteps === this.stepsLo);
this._setElsDisabled(this.upEl, this.nSteps === this.stepsHi);
this._setElsDisabled(this.resetEl, this.nSteps === 0);
return void 0;
};
AvSpeedController.prototype.curSpeed = function() {
return Math.pow(2, this.nSteps / 2);
};
AvSpeedController.prototype.reset = function() {
this.nSteps = 0;
return this._updateGUI();
};
AvSpeedController.prototype.increase = function() {
if (this.nSteps < this.stepsHi) {
++this.nSteps;
}
return this._updateGUI();
};
AvSpeedController.prototype.decrease = function() {
if (this.stepsLo < this.nSteps) {
--this.nSteps;
}
return this._updateGUI();
};
return AvSpeedController;
})();
cwaenv.add(AvSpeedController, "AvSpeedController");
}).call(this);
//-------- js/CASAnimation.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CASAnimation, CASFrame, Data, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Data = cwaenv.get("Data");
CASFrame = cwaenv.get("CASFrame");
CASAnimation = (function() {
function CASAnimation() {
this.signs = [];
this.isComplete = false;
this.fCount = 0;
this.tLimit = 0;
this.signCur = null;
this.framesCur = [];
this.sCur = 0;
this.fLoCur = 0;
this.fHiCur = 0;
this.fCur = 0;
}
CASAnimation.fromFrames = function(frames) {
var anim;
anim = new CASAnimation;
anim.setFromFrames(frames);
return anim;
};
CASAnimation.fromCASDOM = function(casdoc) {
var ELEMENT_TYPE, NF, NS, anim, casel, doCheckSigns, f, fel, fhi, flo, framesSegment, frmels, glossStr, i, j, k, len, len1, len2, s, sd, signdesc, signdescs, ssel, ssels;
ELEMENT_TYPE = 1;
anim = new CASAnimation;
if (casdoc) {
casel = casdoc.documentElement();
frmels = casel.getElementsByTagName("frame");
NF = frmels.length || 0;
framesSegment = function(flo, fhi) {
var f, frames, i, ref, ref1;
frames = [];
for (f = i = ref = flo, ref1 = fhi; ref <= ref1 ? i <= ref1 : i >= ref1; f = ref <= ref1 ? ++i : --i) {
frames.push(CASFrame.fromXML(frmels[f]));
}
return frames;
};
ssels = casel.getElementsByTagName("signStart");
NS = ssels.length || 0;
if (NS === 0) {
anim.setFromFrames(framesSegment(0, NF));
} else {
signdescs = [];
f = 0;
for (s = i = 0, len = ssels.length; i < len; s = ++i) {
ssel = ssels[s];
glossStr = ssel.getAttribute("gloss");
fel = ssel.nextSibling;
while (fel && fel.nodeType !== ELEMENT_TYPE) {
fel = fel.nextSibling;
}
if (fel && fel.nodeName === "frame") {
f = Number(fel.getAttribute("index"));
}
signdescs.push({
i: s,
gloss: glossStr,
fLo: f
});
}
for (s = j = 0, len1 = signdescs.length; j < len1; s = ++j) {
signdesc = signdescs[s];
flo = signdesc.fLo;
fhi = s + 1 === NS ? NF : signdescs[s + 1].fLo;
signdesc.frames = framesSegment(flo, fhi);
anim.extendSigns(signdesc);
}
doCheckSigns = false;
if (doCheckSigns) {
for (s = k = 0, len2 = signdescs.length; k < len2; s = ++k) {
sd = signdescs[s];
log(("Sign " + sd.i + ", " + sd.gloss + ": fLo=" + sd.fLo + " ") + ("#frames=" + sd.frames.length + "."));
}
}
}
log("CAS animation:  #signs=" + (anim.countSigns()) + ".");
}
return anim;
};
CASAnimation.fromCASFile = function(casfile) {
console.warn("fromCASFile: Not implemented");
return null;
};
CASAnimation.fromCASText = function(casxmltxt) {
var casanim, casdoc, report;
casdoc = Data.toDOM(casxmltxt);
casanim = CASAnimation.fromCASDOM(casdoc);
log(report = casanim.hasFrames() ? "CAS frames #=" + (casanim.countFrames()) : "CAS XML text is invalid.");
return casanim;
};
CASAnimation.prototype.extendSigns = function(signdesc) {
var NS, fhi, flo, sframes, sign;
NS = this.signs.length;
sframes = signdesc.frames;
flo = this.fCount;
fhi = flo + sframes.length;
sign = {
i: NS,
gloss: signdesc.gloss,
fLo: flo,
fHi: fhi,
frames: sframes
};
this.signs.push(sign);
this.fCount = fhi;
this.setTimeLimit();
if (NS === 0) {
this.reset();
}
return void 0;
};
CASAnimation.prototype.setCompleted = function() {
return this.isComplete = true;
};
CASAnimation.prototype.setFromFrames = function(frames) {
var signdesc;
if (frames != null ? frames.length : void 0) {
signdesc = {
i: 0,
gloss: "ALL_FRAMES",
frames: frames
};
this.extendSigns(signdesc);
this.setCompleted();
} else {
log("JASAnimData.setFromFrames(): empty frames list.");
}
return void 0;
};
CASAnimation.prototype.setTimeLimit = function() {
var frames, lastframe, s;
if (this.fCount === 0) {
return this.tLimit = 0;
} else {
s = this.lastNonEmptySignIndex();
frames = this.signs[s].frames;
lastframe = frames[frames.length - 1];
return this.tLimit = (lastframe.getTime()) + (lastframe.getDuration());
}
};
CASAnimation.prototype.setCurrentSign = function(s) {
this.sCur = s;
this.signCur = this.signs[s];
this.framesCur = this.signCur.frames;
this.fLoCur = this.signCur.fLo;
return this.fHiCur = this.signCur.fHi;
};
CASAnimation.prototype.lastNonEmptySignIndex = function() {
var s;
s = this.signs.length - 1;
while (this.signs[s].fLo === this.fCount) {
--s;
}
return s;
};
CASAnimation.prototype.firstNonEmptySignIndex = function() {
var s;
s = 0;
while (this.signs[s].fHi === 0) {
++s;
}
return s;
};
CASAnimation.prototype.reset = function() {
this.fCur = 0;
return this.setCurrentSign(this.firstNonEmptySignIndex());
};
CASAnimation.prototype.hasFrames = function() {
return this.fCount !== 0;
};
CASAnimation.prototype.countFrames = function() {
return this.fCount;
};
CASAnimation.prototype.countSigns = function() {
return this.signs.length;
};
CASAnimation.prototype.frameAt = function(f) {
var s;
if (this.fHiCur <= f) {
if (f + 1 === this.fCount) {
s = this.lastNonEmptySignIndex();
} else {
s = this.sCur + 1;
while (this.signs[s].fHi <= f) {
++s;
}
}
this.setCurrentSign(s);
} else if (f < this.fLoCur) {
if (f === 0) {
s = this.firstNonEmptySignIndex();
} else {
s = this.sCur - 1;
while (f < this.signs[s].fLo) {
--s;
}
}
this.setCurrentSign(s);
}
this.fCur = f;
return this.framesCur[f - this.fLoCur];
};
CASAnimation.prototype.getFrameIndex = function(t, NF) {
var f, ff, frm, tfrm;
f = this.fCur;
ff = NF;
while (f !== ff) {
frm = this.frameAt(f);
tfrm = frm.getTime();
if (t < tfrm + frm.getDuration()) {
ff = f;
} else {
f += 1;
}
}
return f;
};
CASAnimation.prototype.getSignAndFrameInfo = function() {
var gloss, s;
s = (this.fCur === this.fCount ? this.signs.length : this.sCur);
gloss = s === this.signs.length ? "[none]" : this.signCur.gloss;
return [gloss, s, this.fCur];
};
CASAnimation.prototype.getFrame = function(t) {
var NF, f, frame, resolved, sframes, sign, was_complete;
resolved = false;
while (!resolved) {
was_complete = this.isComplete;
NF = this.fCount;
f = this.getFrameIndex(t, NF);
resolved = f !== NF || was_complete || NF === this.fCount;
}
return frame = f !== NF ? this.frameAt(f) : this.isComplete ? null : (log("CASAnimation.getFrame(): at end of incomplete animation."), sign = this.signs[this.lastNonEmptySignIndex()], sframes = sign.frames, sframes[sframes.length - 1]);
};
CASAnimation.prototype.getPreviousFrame = function() {
var f;
f = this.fCur - 1;
if (f < 0) {
f = this.fCount - 1;
}
return this.frameAt(f);
};
CASAnimation.prototype.getNextFrame = function() {
var f;
f = this.fCur + 1;
if (this.fCount <= f) {
f = 0;
}
return this.frameAt(f);
};
return CASAnimation;
})();
cwaenv.add(CASAnimation, "CASAnimation");
}).call(this);
//-------- js/AnimScheduler.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AnimScheduler, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
AnimScheduler = (function() {
function AnimScheduler(casAnim, _playFrame, _doneAnim, _getSpeed, _reportGSF, _updateFPS, _rqstAnim) {
this.casAnim = casAnim;
this._playFrame = _playFrame;
this._doneAnim = _doneAnim;
this._getSpeed = _getSpeed;
this._reportGSF = _reportGSF;
this._updateFPS = _updateFPS;
this._rqstAnim = _rqstAnim;
this._needsResetClock = true;
}
AnimScheduler.prototype.restart = function() {
this._needsResetClock = true;
this.clkCur = 0;
this.tCur = 0;
this.isStopped = false;
this.isSuspended = false;
this.oneStepUpIsPending = false;
this.oneStepDownIsPending = false;
this.casAnim.reset();
if (this._updateFPS) {
this._resetFPS();
}
return this._rqstNextTick();
};
AnimScheduler.prototype.suspend = function() {
return this.isSuspended = true;
};
AnimScheduler.prototype.resume = function() {
return this.isSuspended = false;
};
AnimScheduler.prototype.showPreviousFrame = function() {
if (this.isSuspended) {
return this.oneStepDownIsPending = true;
}
};
AnimScheduler.prototype.showNextFrame = function() {
if (this.isSuspended) {
return this.oneStepUpIsPending = true;
}
};
AnimScheduler.prototype.stop = function() {
this.isStopped = true;
return this.isSuspended = false;
};
AnimScheduler.prototype._doResetClock = function(clknow) {
this._needsResetClock = false;
return this.clkCur = clknow;
};
AnimScheduler.prototype._rqstNextTick = function() {
return this._rqstAnim(((function(_this) {
return function(cnow) {
return _this._doNextStep(cnow);
};
})(this)));
};
AnimScheduler.prototype._doNextStep = function(clknow) {
if (this._needsResetClock) {
this._doResetClock(clknow);
}
if (this.isStopped) {
return this._doneAnim();
} else {
return this._doNormalStep(clknow);
}
};
AnimScheduler.prototype._doNormalStep = function(clknow) {
var clkprev, deltaclk, frame;
clkprev = this.clkCur;
this.clkCur = clknow;
deltaclk = this.clkCur - clkprev;
frame = null;
if (this.isSuspended) {
if (this.oneStepDownIsPending) {
frame = this.casAnim.getPreviousFrame();
} else if (this.oneStepUpIsPending) {
frame = this.casAnim.getNextFrame();
}
this.oneStepDownIsPending = this.oneStepUpIsPending = false;
if (frame) {
this.tCur = frame.getTime();
}
} else {
this.tCur += deltaclk * (this._getSpeed ? this._getSpeed() : 1);
}
if (!frame) {
frame = this.casAnim.getFrame(this.tCur);
}
return this._completeCurrentStep(frame, deltaclk);
};
AnimScheduler.prototype._completeCurrentStep = function(frame, deltaclk) {
var f, g, ref, s;
ref = this.casAnim.getSignAndFrameInfo(), g = ref[0], s = ref[1], f = ref[2];
this._reportGSF(g, s, f, !(Boolean(frame)));
if (frame) {
this._rqstNextTick();
this._playFrame(frame, deltaclk);
} else {
this._doneAnim();
}
return this._checkFPS(deltaclk);
};
AnimScheduler.prototype._resetFPS = function() {
this.clkFPSBase = this.clkCur;
this.tFPSAccum = 0;
return this.nFPSTicks = 0;
};
AnimScheduler.prototype._checkFPS = function(deltaclk) {
if (this._updateFPS) {
this.tFPSAccum += deltaclk;
this.nFPSTicks += 1;
if (1000 <= this.tFPSAccum) {
this._updateFPS(this.nFPSTicks * 1000 / this.tFPSAccum);
return this._resetFPS();
}
}
};
return AnimScheduler;
})();
cwaenv.add(AnimScheduler, "AnimScheduler");
}).call(this);
//-------- js/SigningAvatar.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AnimScheduler, AvDataAccess, AvDefView, AvatarCamera, CASAnimation, CASFrame, Character, Config, Data, HtoG, SigningAvatar, console, cwaenv, document, log, setTimeout, theConfig, theSToCA,
bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Data = cwaenv.get("Data");
Config = cwaenv.get("Config");
AvDataAccess = cwaenv.get("AvDataAccess");
AvDefView = cwaenv.get("AvDefView");
AvatarCamera = cwaenv.get("AvatarCamera");
CASFrame = cwaenv.get("CASFrame");
Character = cwaenv.get("Character");
CASAnimation = cwaenv.get("CASAnimation");
AnimScheduler = cwaenv.get("AnimScheduler");
HtoG = cwaenv.get("HtoG");
theSToCA = cwaenv.get("theSToCA");
theConfig = Config.theConfig;
SigningAvatar = (function() {
function SigningAvatar(avIndex, canvasEl, speedFun, evtHandlers) {
var xslLoc;
this.avIndex = avIndex;
this.canvasEl = canvasEl;
this.speedFun = speedFun;
this.evtHandlers = evtHandlers;
this.playSiGML = bind(this.playSiGML, this);
this.playGSiGML = bind(this.playGSiGML, this);
log("Starting SigningAvatar " + this.avIndex + " ...");
this.gl = null;
this.character = null;
this.camera = null;
this.pendingAvName = null;
this.pendingCASAnim = null;
this.curAnimScheduler = null;
this.stocMap = {};
this.nSToC = 0;
this.USING_JAR_FOR_AV_DEF = theConfig.useAvatarJARs;
this.sigmlBase = theConfig.sigmlBase;
xslLoc = Data.absoluteURI("h2s.xsl", theConfig.cwaBase);
this.H2G = new HtoG(xslLoc, false, 0);
this.animgenServer = theConfig.animgenServer;
this.USING_JSON_STOC_FORMAT = true;
this.jCAS = null;
this.DO_ANIM_STATUS_REPORTING = true;
this.canvasEl.setAttribute("ondragstart", "return false");
log("Getting WebGL context");
this.gl = (this.canvasEl.getContext("webgl")) || (this.canvasEl.getContext("experimental-webgl"));
if (this.gl == null) {
console.warn("No WebGL context. Disaster.");
}
this.gl.viewport(0, 0, this.canvasEl.width, this.canvasEl.height);
this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
this.logGLImplementationData();
}
SigningAvatar.prototype.switchAvatar = function(av) {
log("Switch Avatar to " + av);
if (!this.character || (this.character.getName()) !== av) {
this.pendingAvName = av;
if (this.curAnimScheduler) {
return this.stopPlay();
} else {
return setTimeout(((function(_this) {
return function() {
return _this.loadNewAvatar();
};
})(this)), 0);
}
} else {
return log("Character " + av + " already loaded.");
}
};
SigningAvatar.prototype.playGSiGML = function(sigmlText) {
var av, blob, cascb, casfmt, form, rqst, rqstid, servCB, servURI, txtarea;
this.evtHandlers.animLoading();
av = this.character.getName();
txtarea = document.getElementById("JSONText");
if (this.animgenServer != null) {
servURI = this.animgenServer + "?avatar=" + av;
if ((sigmlText.indexOf("hns_sign")) !== -1) {
log("Error: Still needs H-SiGML to G-SiGML processing");
servURI += "&htog=true";
}
log("playGSiGML Server URI: " + servURI);
theSToCA.stat("SToCA: Server processing SiGML text for " + av);
servCB = (function(_this) {
return function(jsonData) {
var i, len, sign;
if (jsonData == null) {
jsonData = [];
}
if (txtarea) {
txtarea.value = JSON.stringify(jsonData);
}
_this.jCAS = {
anim: new CASAnimation,
playStarted: false
};
for (i = 0, len = jsonData.length; i < len; i++) {
sign = jsonData[i];
_this.acceptJSONCASSign(sign, "AnimgenServer");
}
_this.acceptJSONCASEndSignStream("AnimgenServer");
if (jsonData.length === 0) {
_this.evtHandlers.animIdle();
return theSToCA.stat("SToCA: No signs returned for " + av);
}
};
})(this);
form = new FormData;
blob = new Blob([sigmlText]);
form.append("sigml", blob, "temp.sigml");
return Data.fetchJSON(servURI, servCB, form);
} else if ((theSToCA.getSToCA()) != null) {
casfmt = (this.USING_JSON_STOC_FORMAT ? "json" : "xml");
rqstid = "stoca" + this.nSToC + "_" + this.avIndex;
this.nSToC += 1;
rqst = {
stext: sigmlText
};
this.stocMap[rqstid] = rqst;
theSToCA.stat("SToCA: Loading SiGML text for " + av);
if (this.USING_JSON_STOC_FORMAT) {
this.jCAS = {
anim: new CASAnimation,
playStarted: false
};
}
cascb = this.USING_JSON_STOC_FORMAT ? ((function(_this) {
return function(jcassign) {
return _this.acceptJSONCAS(rqstid, jcassign);
};
})(this)) : ((function(_this) {
return function(cas) {
return _this.acceptXMLCAS(rqstid, cas);
};
})(this));
return theSToCA.doSiGMLTextToCAS(rqstid, sigmlText, av, casfmt, cascb);
} else {
this.evtHandlers.animIdle();
return theSToCA.stat("SToCA: No SiGML played as SToCA applet unavailable");
}
};
SigningAvatar.prototype.playSiGML = function(sigmlText) {
var CB, av;
this.evtHandlers.animLoading();
av = this.character.getName();
if ((sigmlText.indexOf("hns_sign")) !== -1) {
CB = (function(_this) {
return function(res) {
if (res.errCount > 0 || !res.sigDoc) {
_this.evtHandlers.animIdle();
theSToCA.stat("SToCA: No signs available for " + av);
return log("Errors:\n" + res.errText);
} else {
return _this.playGSiGML(Data.ppDOM(res.sigDoc));
}
};
})(this);
theSToCA.stat("SToCA: Converting H-SiGML to G-SiGML for " + av);
return this.H2G.parseHtoGText(sigmlText, CB);
} else {
return this.playGSiGML(sigmlText);
}
};
SigningAvatar.prototype.playSiGMLURL = function(sigmlURL) {
var surlAbs;
this.evtHandlers.animLoading();
surlAbs = Data.absoluteURI(sigmlURL, this.sigmlBase);
log("playSiGMLURL: " + surlAbs);
return Data.fetchText(surlAbs, this.playSiGML);
};
SigningAvatar.prototype.playCAS = function(casfile) {
console.warn("playCAS: Not implemented");
return null;
};
SigningAvatar.prototype.stopPlay = function() {
if (this._checkAS("Stop")) {
return this.curAnimScheduler.stop();
}
};
SigningAvatar.prototype.suspendPlay = function() {
if (this._checkAS("Suspend")) {
return this.curAnimScheduler.suspend();
}
};
SigningAvatar.prototype.resumePlay = function() {
if (this._checkAS("Resume")) {
return this.curAnimScheduler.resume();
}
};
SigningAvatar.prototype.showPreviousFrame = function() {
if (this._checkAS("Show Previous Frame")) {
return this.curAnimScheduler.showPreviousFrame();
}
};
SigningAvatar.prototype.showNextFrame = function() {
if (this._checkAS("Show Next Frame")) {
return this.curAnimScheduler.showNextFrame();
}
};
SigningAvatar.prototype._checkAS = function(optag) {
if (!this.curAnimScheduler) {
log(optag + " impossible: no current animation.");
}
return this.curAnimScheduler != null;
};
SigningAvatar.prototype.logGLImplementationData = function() {
var glver, maXVUV, maxVA, renderer, slver, vendor;
glver = this.gl.getParameter(this.gl.VERSION);
slver = this.gl.getParameter(this.gl.SHADING_LANGUAGE_VERSION);
vendor = this.gl.getParameter(this.gl.VENDOR);
renderer = this.gl.getParameter(this.gl.RENDERER);
maxVA = this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS);
maXVUV = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);
log("--------  WebGL Implementation Data  --------");
log("GL Version: " + glver + ";  GLSL Version: " + slver);
log("Vendor: " + vendor + ";  Renderer: " + renderer);
log("MAX_VERTEX_ATTRIBS: " + maxVA + ";  MAX_VERTEX_UNIFORM_VECTORS: " + maXVUV);
return log("---------------------------------------------");
};
SigningAvatar.prototype.notifyFrame = function(g, s, f, isdone) {
if (this.DO_ANIM_STATUS_REPORTING) {
if (this.curAnimScheduler !== this.ambientScheduler) {
this.evtHandlers.atFrame(g, s, f, isdone);
return this.character.meshes[0].morphsManager._f = f;
}
}
};
SigningAvatar.prototype.draw = function(frame, deltaclk) {
var avHeight, avWidth;
avWidth = this.canvasEl.clientWidth;
avHeight = this.canvasEl.clientHeight;
if (this.canvasEl.width !== avWidth || this.canvasEl.height !== avHeight) {
this.canvasEl.width = avWidth;
this.canvasEl.height = avHeight;
}
this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
this.gl.viewport(0, 0, this.canvasEl.width, this.canvasEl.height);
this.gl.enable(this.gl.DEPTH_TEST);
this.gl.enable(this.gl.CULL_FACE);
this.camera.update(deltaclk, this.canvasEl.width, this.canvasEl.height);
this.character.setFrame(frame);
return this.character.draw(this.avPos[0], this.avPos[1], this.avPos[2], this.camera.getViewMatrix(), this.camera.getProjMatrix());
};
SigningAvatar.prototype.startNewCamera = function() {
var camdata, m2internal, yadj;
m2internal = this.character.getMetresToInternal();
yadj = this.character.getAdjustViewY();
this.avPos = [0, 0, 0];
camdata = theConfig.avSettings[this.avIndex].initCamera || [0, 0, 4, 12, 19, 30, -1, -1];
log("Camera: [" + (camdata.toString()) + "]");
this.camera = new AvatarCamera(this.gl, camdata, yadj, m2internal);
this.canvasEl.onmousedown = (function(_this) {
return function(evt) {
return _this.camera.mousedown(evt);
};
})(this);
this.canvasEl.onmousemove = (function(_this) {
return function(evt) {
return _this.camera.mousemove(evt);
};
})(this);
this.canvasEl.onmouseup = (function(_this) {
return function(evt) {
return _this.camera.mouseup(evt);
};
})(this);
this.canvasEl.onmouseover = (function(_this) {
return function(evt) {
return _this.camera.mouseover(evt);
};
})(this);
this.canvasEl.onmouseout = (function(_this) {
return function(evt) {
return _this.camera.mouseout(evt);
};
})(this);
this.canvasEl.addEventListener('touchstart', this.camera.touchstart, false);
this.canvasEl.addEventListener('touchend', this.camera.touchend, false);
return this.canvasEl.addEventListener('touchmove', this.camera.touchmove, false);
};
SigningAvatar.prototype.loadNewAvatar = function() {
var av, avDefHandler, getAvURL;
av = this.pendingAvName;
this.pendingAvName = null;
this.pendingCASAnim = null;
this.evtHandlers.avLoadStarts(av);
if (this.USING_JAR_FOR_AV_DEF) {
getAvURL = function() {
return "" + (Config.getAvBase(av)) + av + ".jar";
};
avDefHandler = (function(_this) {
return function(av, adv, pngURIGen) {
var avdef;
avdef = new AvDefView(av, adv, pngURIGen);
return _this.loadBinaryAvatar(av, avdef);
};
})(this);
return this.avDataAccess = new AvDataAccess(getAvURL, av, avDefHandler);
} else {
return this.loadJSONAvatar(av);
}
};
SigningAvatar.prototype.loadJSONAvatar = function(av) {
var e;
log("Start JSON character load for " + av + " ...");
try {
this.character = new Character;
this.character.loadJSON(this.gl, av);
return this.startNewCharacter(av, "JSON");
} catch (error) {
e = error;
this.character = null;
this.evtHandlers.avLoadDone(null);
return log(e.stack || e.stacktrace || e);
}
};
SigningAvatar.prototype.loadBinaryAvatar = function(av, avdef) {
var e;
log("Start Binary character load for " + av + " ...");
try {
this.character = new Character;
this.character.loadBinary(this.gl, av, avdef);
return this.startNewCharacter(av, "Binary");
} catch (error) {
e = error;
this.character = null;
this.evtHandlers.avLoadDone(null);
return log("Error " + e + "\nStack:\n" + e.stack + "\nStackTrace:\n" + e.stacktrace);
}
};
SigningAvatar.prototype.startNewCharacter = function(avname, loadkind) {
this.evtHandlers.avLoadDone((this.character ? avname : null));
if (this.character) {
log("Character loaded (" + loadkind + "): " + avname + ".");
this.startNewCamera();
this.ambientScheduler = this.makeAnimScheduler(this.getAmbientCASAnim());
return this.startAmbientAnimation();
}
};
SigningAvatar.prototype.getAmbientCASAnim = function() {
return CASAnimation.fromFrames(this.character.getAmbientFrames());
};
SigningAvatar.prototype.donePlay = function() {
var actionfun;
if (this.curAnimScheduler !== this.ambientScheduler) {
this.evtHandlers.animIdle();
}
this.curAnimScheduler = null;
actionfun = this.pendingAvName ? ((function(_this) {
return function() {
return _this.loadNewAvatar();
};
})(this)) : this.pendingCASAnim ? ((function(_this) {
return function() {
return _this.startPendingAnimation();
};
})(this)) : ((function(_this) {
return function() {
return _this.startAmbientAnimation();
};
})(this));
return setTimeout(actionfun, 0);
};
SigningAvatar.prototype.checkFramesAndSwitchAnimation = function(casanim) {
if (casanim.hasFrames()) {
return this.switchAnimation(casanim);
}
};
SigningAvatar.prototype.switchAnimation = function(casanim) {
this.pendingCASAnim = casanim;
if (this.curAnimScheduler) {
return this.curAnimScheduler.stop();
} else {
return this.startPendingAnimation();
}
};
SigningAvatar.prototype.startPendingAnimation = function() {
this.curAnimScheduler = this.makeAnimScheduler(this.pendingCASAnim);
this.pendingCASAnim = null;
this.evtHandlers.animActive();
return this.curAnimScheduler.restart();
};
SigningAvatar.prototype.startAmbientAnimation = function() {
this.curAnimScheduler = this.ambientScheduler;
return this.curAnimScheduler.restart();
};
SigningAvatar.prototype.makeAnimScheduler = function(casanim) {
var donefun, framefun, playfun, rqstanimfun;
playfun = this.draw.bind(this);
donefun = this.donePlay.bind(this);
framefun = this.notifyFrame.bind(this);
rqstanimfun = window.requestAnimFrame.bind(window);
return new AnimScheduler(casanim, playfun, donefun, this.speedFun, framefun, this.evtHandlers.fps, rqstanimfun);
};
SigningAvatar.prototype.acceptJSONCAS = function(rqstid, jcassign) {
var jsonsign, pfx, s, txtarea;
s = this.jCAS.anim.countSigns();
pfx = "S-to-C request ID=" + rqstid + ", sign " + s + ": ";
if (this.stocMap[rqstid]) {
jsonsign = Data.parseJSON(jcassign);
if (jsonsign) {
if (jsonsign.signIndex === void 0) {
this.acceptJSONCASEndSignStream(pfx);
return this.closeSToCRequest(rqstid);
} else {
log("acceptJSONCAS " + pfx + jsonsign.gloss);
txtarea = document.getElementById("JSONText");
if (txtarea) {
log("JSON text area available");
if (s === 0) {
txtarea.value = "";
}
txtarea.value = txtarea.value + JSON.stringify(jsonsign);
}
return this.acceptJSONCASSign(jsonsign, pfx);
}
} else {
return log(pfx + "invalid JSON for sign " + s + ".");
}
} else {
return log(pfx + "unexpected request ID.");
}
};
SigningAvatar.prototype.acceptJSONCASSign = function(jsonsign, msgpfx) {
var anim, s, sframes, sgloss;
anim = this.jCAS.anim;
sframes = jsonsign.frames.map(CASFrame.fromJSON);
s = jsonsign.signIndex;
sgloss = jsonsign.gloss;
anim.extendSigns({
i: s,
gloss: sgloss,
frames: sframes
});
if (!this.jCAS.playStarted && anim.hasFrames()) {
this.switchAnimation(anim);
return this.jCAS.playStarted = true;
}
};
SigningAvatar.prototype.acceptJSONCASEndSignStream = function(msgpfx) {
var anim;
anim = this.jCAS.anim;
theSToCA.stat("SToCA: SiGML Loaded");
log(msgpfx + "CAS (JSON) complete, #frames=" + (anim.countFrames()));
return anim.setCompleted();
};
SigningAvatar.prototype.acceptXMLCAS = function(rqstid, cas) {
var pfx, rqst;
rqst = this.stocMap[rqstid];
pfx = "S-to-C request ID=" + rqstid + ": ";
if (!rqst) {
log(pfx + "unexpected ID.");
} else if (!cas) {
log(pfx + "failed.");
} else {
log(pfx + "CAS text length=" + cas.length + ".");
this.checkFramesAndSwitchAnimation(CASAnimation.fromCASText(cas));
}
return this.closeSToCRequest(rqstid);
};
SigningAvatar.prototype.closeSToCRequest = function(rqstid) {
theSToCA.setDoneSiGMLToCASRequest(rqstid);
delete this.stocMap[rqstid];
return this.jCAS = null;
};
return SigningAvatar;
})();
cwaenv.add(SigningAvatar, "SigningAvatar");
}).call(this);
//-------- js/HTMLForAvatarGUI.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var HTMLForAvatarGUI, console, cwaenv, document, log, setTimeout;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
HTMLForAvatarGUI = (function() {
function HTMLForAvatarGUI(ix, avSettings) {
this.ix = ix;
this.avw = avSettings.width;
this.avh = avSettings.height;
this.avBg = avSettings.background;
this.avs = avSettings.avList;
this.initav = avSettings.initAv;
this.doFrameSteps = avSettings.allowFrameSteps;
this.dostext = avSettings.allowSiGMLText;
this.initsurl = avSettings.initSiGMLURL;
}
HTMLForAvatarGUI.prototype.allHTML = function() {
var avatar, avgui, table;
avatar = this.htmlForAv();
avgui = this.htmlForGUI();
return table = "<table class=\"avTable av" + this.ix + "\" ><tr>\n<td align=\"center\" >\n  " + avgui + "\n</td>\n<td width=\"8\"></td>\n<td width=\"" + this.avw + "\" height=\"" + this.avh + "\" >\n  " + avatar + "\n</td>\n</tr></table>";
};
HTMLForAvatarGUI.prototype.htmlForGUI = function() {
var gui, html;
gui = [this.htmlForAvCtrl(), this.htmlForSpeed(), this.htmlForSiGML(), this.htmlForSiGMLCtrl(), this.htmlForInfo()].join("\n<br>\n");
return html = "<div class=\"divCtrlPanel\" >\n  " + gui + "\n</div>";
};
HTMLForAvatarGUI.prototype.htmlForAv = function() {
var html, sty;
sty = this.avBg != null ? "style=\"background: " + this.avBg + ";\" " : "";
return html = "<div class=\"divAv av" + this.ix + "\" " + sty + ">\n  <canvas class=\"canvasAv av" + this.ix + "\" ></canvas>\n</div>  <!--class=\"divAv av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype.htmlForAvMenu = function() {
var av, avopts, html, opt;
opt = (function(_this) {
return function(av) {
var sel;
sel = av === _this.initav ? " selected=\"selected\"" : "";
return "<option value=\"" + av + "\"" + sel + " >" + av + "</option>";
};
})(this);
avopts = ((function() {
var i, len, ref, results;
ref = this.avs;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
av = ref[i];
results.push(opt(av));
}
return results;
}).call(this)).join("\n");
return html = "<select class=\"menuAv av" + this.ix + "\" >\n" + avopts + "\n</select>";
};
HTMLForAvatarGUI.prototype.htmlForAvCtrl = function() {
var html;
return html = "<!--========================================================-->\n<span class=\"spanPlayA av" + this.ix + "\" >\nAvatar:\n" + (this.htmlForAvMenu()) + "\n</span>  <!--class=\"spanPlayA av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype._htmlForSiGMLPlayButtons = function(surl, stext) {
var bstext, bstop, bsurl, gap, html, sep;
log("PlayButtons: URL=" + surl + ", Text=" + stext);
bstop = "<input type=\"button\" value=\"Stop\" class=\"bttnStop av" + this.ix + "\" />";
bsurl = !surl ? "" : "<input type=\"button\" value=\"Play SiGML URL\" " + ("class=\"bttnPlaySiGMLURL av" + this.ix + "\" />");
bstext = !stext ? "" : "<input type=\"button\" value=\"Play SiGML Text\" " + ("class=\"bttnPlaySiGMLText av" + this.ix + "\" />");
sep = "";
gap = "";
if (bsurl.length !== 0 && bstext.length !== 0) {
sep = "\n";
gap = "&nbsp;";
}
return html = !surl && !stext ? "" : "<span class=\"spanSiGMLCtrlA av" + this.ix + "\" >\n<!--input type=\"button\" value=\"Play CAS\" class=\"bttnPlayCAS av" + this.ix + "\" /-->\n" + bsurl + sep + bstext + "\n" + gap + "\n" + bstop + "\n</span>  <!--class=\"spanSiGMLCtrlA av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype.htmlForSiGMLPlay = function() {
var hastext, hasurl, html;
hasurl = (document.getElementsByClassName("txtSiGMLURL av" + this.ix)).length > 0;
hastext = (document.getElementsByClassName("txtaSiGMLText av" + this.ix)).length > 0;
return html = this._htmlForSiGMLPlayButtons(hasurl, hastext);
};
HTMLForAvatarGUI.prototype.htmlForFrameSteps = function() {
var html;
return html = "<input type=\"button\" value=\"-1\" class=\"bttnPrevF av" + this.ix + "\" />\n<input type=\"button\" value=\"+1\" class=\"bttnNextF av" + this.ix + "\" />";
};
HTMLForAvatarGUI.prototype.htmlForSiGMLPlayExtra = function() {
var html;
return html = "<input type=\"button\" value=\"Suspend\" class=\"bttnSuspend av" + this.ix + "\" />\n<input type=\"button\" value=\"Resume\" class=\"bttnResume av" + this.ix + "\" />";
};
HTMLForAvatarGUI.prototype.htmlForSiGMLCtrl = function() {
var buttons, fstext, html;
buttons = this._htmlForSiGMLPlayButtons((this.initsurl != null) && this.initsurl !== "", this.dostext);
fstext = "";
if (this.doFrameSteps) {
fstext = "<br/>\n<span align=\"center\" class=\"spanSiGMLCtrlB av" + this.ix + "\" >\n" + (this.htmlForSiGMLPlayExtra()) + "\n&nbsp;\nFrames:\n" + (this.htmlForFrameSteps()) + "\n</span>  <!--class=\"spanSiGMLCtrlB av" + this.ix + "\"-->";
}
return html = "<!--========================================================-->\n" + buttons + "\n" + fstext;
};
HTMLForAvatarGUI.prototype.htmlForSpeedCtrl = function() {
var html;
return html = "<input type=\"text\" class=\"txtLogSpeed av" + this.ix + "\" value=\"+1.0\" />\n<input type=\"button\" value=\"-\" class=\"bttnSpeedDown av" + this.ix + "\" />\n<input type=\"button\" value=\"+\" class=\"bttnSpeedUp av" + this.ix + "\" />\n<input type=\"button\" value=\"Reset\" class=\"bttnSpeedReset av" + this.ix + "\" />";
};
HTMLForAvatarGUI.prototype.htmlForSpeed = function() {
var html;
return html = "<!--========================================================-->\n<span class=\"spanSpeed av" + this.ix + "\" >\nSpeed (log<sub>2</sub> scale):\n" + (this.htmlForSpeedCtrl()) + "\n</span>  <!--class=\"spanSpeed av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype.htmlForProgress = function() {
var html;
return html = "<!--========================================================-->\n<span class=\"spanInfo av" + this.ix + "\" >\nSign/Frame:\n<input type=\"text\" class=\"txtSF av" + this.ix + "\" value=\"0/0\" />\n&nbsp;\nGloss:\n<input type=\"text\" class=\"txtGloss av" + this.ix + "\" value=\"[none]\" />\n&nbsp;\nFPS:\n<input type=\"text\" class=\"txtFPS av" + this.ix + "\" value=\"00.00\" />\n</span>  <!--class=\"spanInfo av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype.htmlForStatus = function() {
var html;
return html = "<!--========================================================-->\n<span class=\"spanInfo av" + this.ix + "\" >\nStatus:\n<input type=\"text\" class=\"statusExtra\" />\n</span>  <!--class=\"spanInfo av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype.htmlForInfo = function() {
var html;
return html = "<!--========================================================-->\n<hr style=\"height:1px;\" >\n" + (this.htmlForProgress()) + "\n<br>\n" + (this.htmlForStatus());
};
HTMLForAvatarGUI.prototype.htmlForSiGMLURL = function() {
var html;
return html = "<input type=\"text\" class=\"txtSiGMLURL av" + this.ix + "\" value=\"" + this.initsurl + "\" />";
};
HTMLForAvatarGUI.prototype.htmlForSiGMLText = function() {
var html;
return html = "<textarea class=\"txtaSiGMLText av" + this.ix + "\" rows=\"4\">\n" + (this.sigmlText()) + "\n</textarea>";
};
HTMLForAvatarGUI.prototype.htmlForSiGML = function() {
var html, stext, surl;
surl = "";
stext = "";
if (this.initsurl) {
surl = "SiGML URL:<br>\n" + (this.htmlForSiGMLURL());
}
if (this.dostext) {
stext = "SiGML Text:<br>\n" + (this.htmlForSiGMLText());
if (surl !== "") {
surl += "<br>\n";
}
}
return html = "<hr style=\"height:1px;\" >\n<span align=\"center\" class=\"divSiGML av" + this.ix + "\" >\n" + surl + "\n" + stext + "\n</span>  <!--class=\"divSiGML av" + this.ix + "\"-->";
};
HTMLForAvatarGUI.prototype.sigmlText = function() {
var sigml;
return sigml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<sigml>\n\n<hns_sign gloss=\"mug\">\n  <hamnosys_nonmanual>\n    <hnm_mouthpicture picture=\"mVg\"/>\n  </hamnosys_nonmanual>\n  <hamnosys_manual>\n    <hamfist/> <hamthumbacrossmod/>\n        <hamextfingerol/> <hampalml/>\n    <hamshoulders/>\n    <hamparbegin/> <hammoveu/> <hamarcu/>\n        <hamreplace/> <hamextfingerul/> <hampalmdl/>\n    <hamparend/>\n  </hamnosys_manual>\n</hns_sign>\n\n<hns_sign gloss=\"take\">\n  <hamnosys_nonmanual>\n    <hnm_mouthpicture picture=\"te_Ik\"/>\n  </hamnosys_nonmanual>\n  <hamnosys_manual>\n    <hamceeall/> <hamextfingerol/> <hampalml/>\n    <hamlrbeside/> <hamshoulders/> <hamarmextended/>\n    <hamreplace/> <hamextfingerl/> <hampalml/>\n    <hamchest/> <hamclose/>\n  </hamnosys_manual>\n</hns_sign>\n\n<hns_sign gloss=\"i\">\n  <hamnosys_nonmanual>\n    <hnm_mouthpicture picture=\"a_I\"/>\n  </hamnosys_nonmanual>\n  <hamnosys_manual>\n    <hamfinger2/> <hamthumbacrossmod/>\n    <hamextfingeril/> <hampalmr/>\n    <hamchest/> <hamtouch/>\n  </hamnosys_manual>\n</hns_sign>\n\n</sigml>";
};
return HTMLForAvatarGUI;
})();
cwaenv.add(HTMLForAvatarGUI, "HTMLForAvatarGUI");
}).call(this);
//-------- js/AvatarGUI.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AvSpeedController, AvatarGUI, HTMLForAvatarGUI, SigningAvatar, console, cwaenv, document, log, setTimeout, theSToCA,
bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
AvSpeedController = cwaenv.get("AvSpeedController");
SigningAvatar = cwaenv.get("SigningAvatar");
HTMLForAvatarGUI = cwaenv.get("HTMLForAvatarGUI");
theSToCA = cwaenv.get("theSToCA");
AvatarGUI = (function() {
function AvatarGUI(avIndex, avSettings) {
var allDiv, avEvtHandlers, avaDiv, div, htmlgen, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, m, n, o, p, q, r, ref, ref1, speedFun, theDivs;
this.avIndex = avIndex;
this.avEvtLoadDone = bind(this.avEvtLoadDone, this);
this.avEvtLoadStarts = bind(this.avEvtLoadStarts, this);
this.initAv = avSettings.initAv;
log("Starting AvatarGUI " + this.avIndex + " ...");
htmlgen = new HTMLForAvatarGUI(this.avIndex, avSettings);
allDiv = document.getElementsByClassName("CWASAPanel av" + this.avIndex);
if ((ref = allDiv[0]) != null) {
ref.innerHTML = htmlgen.allHTML();
}
avaDiv = document.getElementsByClassName("CWASAAvatar av" + this.avIndex);
if ((ref1 = avaDiv[0]) != null) {
ref1.innerHTML = htmlgen.htmlForAv();
}
theDivs = document.getElementsByClassName("CWASAGUI av" + this.avIndex);
for (i = 0, len = theDivs.length; i < len; i++) {
div = theDivs[i];
div.innerHTML = htmlgen.htmlForGUI();
}
theDivs = document.getElementsByClassName("CWASAAvMenu av" + this.avIndex);
for (j = 0, len1 = theDivs.length; j < len1; j++) {
div = theDivs[j];
div.innerHTML = htmlgen.htmlForAvMenu();
}
theDivs = document.getElementsByClassName("CWASASpeed av" + this.avIndex);
for (k = 0, len2 = theDivs.length; k < len2; k++) {
div = theDivs[k];
div.innerHTML = htmlgen.htmlForSpeedCtrl();
}
theDivs = document.getElementsByClassName("CWASASiGMLURL av" + this.avIndex);
for (l = 0, len3 = theDivs.length; l < len3; l++) {
div = theDivs[l];
div.innerHTML = htmlgen.htmlForSiGMLURL();
}
theDivs = document.getElementsByClassName("CWASASiGMLText av" + this.avIndex);
for (m = 0, len4 = theDivs.length; m < len4; m++) {
div = theDivs[m];
div.innerHTML = htmlgen.htmlForSiGMLText();
}
theDivs = document.getElementsByClassName("CWASAPlay av" + this.avIndex);
for (n = 0, len5 = theDivs.length; n < len5; n++) {
div = theDivs[n];
div.innerHTML = htmlgen.htmlForSiGMLPlay();
}
theDivs = document.getElementsByClassName("CWASAPlayExtra av" + this.avIndex);
for (o = 0, len6 = theDivs.length; o < len6; o++) {
div = theDivs[o];
div.innerHTML = htmlgen.htmlForSiGMLPlayExtra();
}
theDivs = document.getElementsByClassName("CWASAFrames av" + this.avIndex);
for (p = 0, len7 = theDivs.length; p < len7; p++) {
div = theDivs[p];
div.innerHTML = htmlgen.htmlForFrameSteps();
}
theDivs = document.getElementsByClassName("CWASAProgress av" + this.avIndex);
for (q = 0, len8 = theDivs.length; q < len8; q++) {
div = theDivs[q];
div.innerHTML = htmlgen.htmlForProgress();
}
theDivs = document.getElementsByClassName("CWASAStatus av" + this.avIndex);
for (r = 0, len9 = theDivs.length; r < len9; r++) {
div = theDivs[r];
div.innerHTML = htmlgen.htmlForStatus();
}
this.domEls = this._getDOMEls();
this.guiDisablePlay();
avEvtHandlers = {
fps: this.avEvtFPS.bind(this),
atFrame: this.avEvtAtFrame.bind(this),
avLoadStarts: this.avEvtLoadStarts.bind(this),
avLoadDone: this.avEvtLoadDone.bind(this),
animLoading: this.avEvtSiGMLLoading.bind(this),
animActive: this.avEvtAnimActive.bind(this),
animIdle: this.avEvtAnimIdle.bind(this)
};
this.speedController = new AvSpeedController(this.domEls, true);
speedFun = ((function(_this) {
return function() {
return _this.speedController.curSpeed();
};
})(this));
this.avatar = new SigningAvatar(this.avIndex, this.domEls.avCanvas[0], speedFun, avEvtHandlers);
}
AvatarGUI.prototype.startAvatar = function() {
this.initGUI();
return this.avatar.switchAvatar(this.initAv);
};
AvatarGUI.prototype.playSiGMLText = function(sigml) {
this._sIndex = -1;
return this.avatar.playSiGML(sigml);
};
AvatarGUI.prototype.playSiGMLURL = function(sigmlurl) {
this._sIndex = -1;
return this.avatar.playSiGMLURL(sigmlurl);
};
AvatarGUI.prototype.playSiGMLTextFromEl = function(sigmltxtel) {
var ref, sigml;
sigml = (ref = sigmltxtel[0]) != null ? ref.value : void 0;
this._sIndex = -1;
return this.playSiGMLText(sigml);
};
AvatarGUI.prototype.playSiGMLURLFromEl = function(sigmlurlel) {
var ref, sigmlurl;
sigmlurl = (ref = sigmlurlel[0]) != null ? ref.value : void 0;
this._sIndex = -1;
return this.playSiGMLURL(sigmlurl);
};
AvatarGUI.prototype.stopPlay = function() {
return this.avatar.stopPlay();
};
AvatarGUI.prototype.suspendPlay = function() {
this.guiSuspendPlay();
return this.avatar.suspendPlay();
};
AvatarGUI.prototype.resumePlay = function() {
this.guiStartPlay();
return this.avatar.resumePlay();
};
AvatarGUI.prototype.showPreviousFrame = function() {
return this.avatar.showPreviousFrame();
};
AvatarGUI.prototype.showNextFrame = function() {
return this.avatar.showNextFrame();
};
AvatarGUI.prototype.handleURLKey = function(evt) {
var chr;
chr = evt.which || evt.keyCode;
if (chr === theSToCA.RETURN_CHAR) {
if (evt.preventDefault != null) {
evt.preventDefault();
} else {
evt.returnValue = false;
}
return this.playSiGMLURLFromEl(this.domEls.sigmlURL);
}
};
AvatarGUI.prototype._setElsValue = function(els, newval) {
var el, i, len, results;
results = [];
for (i = 0, len = els.length; i < len; i++) {
el = els[i];
results.push(el.value = newval);
}
return results;
};
AvatarGUI.prototype._setElsOnclick = function(els, hdlr) {
var el, i, len, results;
results = [];
for (i = 0, len = els.length; i < len; i++) {
el = els[i];
results.push(el.onclick = hdlr);
}
return results;
};
AvatarGUI.prototype._setElsDisabled = function(els, isDis) {
var el, i, len, results;
results = [];
for (i = 0, len = els.length; i < len; i++) {
el = els[i];
results.push(el.disabled = isDis);
}
return results;
};
AvatarGUI.prototype.avEvtFPS = function(newfps) {
return this._setElsValue(this.domEls.fps, "" + (newfps.toFixed(2)));
};
AvatarGUI.prototype.avEvtAtFrame = function(gloss, s, f, isDone) {
if (s !== this._sIndex || f !== this._fIndex || isDone) {
this._setElsValue(this.domEls.signAndFrame, s + "/" + f);
this._fIndex = f;
if (s !== this._sIndex) {
this._setElsValue(this.domEls.gloss, "" + gloss);
return this._sIndex = s;
}
}
};
AvatarGUI.prototype.avEvtLoadStarts = function(av) {
this._setElsValue(this.domEls.avMenu, av);
return this.guiDisablePlay();
};
AvatarGUI.prototype.avEvtLoadDone = function(av) {
this._setElsValue(this.domEls.avMenu, av);
return this.guiStopPlay();
};
AvatarGUI.prototype.avEvtSiGMLLoading = function() {
return this.guiDisablePlay();
};
AvatarGUI.prototype.avEvtAnimActive = function() {
return this.guiStartPlay();
};
AvatarGUI.prototype.avEvtAnimIdle = function() {
return this.guiStopPlay();
};
AvatarGUI.prototype.initGUI = function() {
var avm, avmenu, i, len, textsu;
this.nSFD = 0;
this._setElsOnclick(this.domEls.stop, this.stopPlay.bind(this));
this._setElsOnclick(this.domEls.suspend, this.suspendPlay.bind(this));
this._setElsOnclick(this.domEls.resume, this.resumePlay.bind(this));
this._setElsOnclick(this.domEls.playSU, ((function(_this) {
return function() {
return _this.playSiGMLURLFromEl(_this.domEls.sigmlURL);
};
})(this)));
this._setElsOnclick(this.domEls.playST, ((function(_this) {
return function() {
return _this.playSiGMLTextFromEl(_this.domEls.sigmlText);
};
})(this)));
this._setElsOnclick(this.domEls.prevF, this.showPreviousFrame.bind(this));
this._setElsOnclick(this.domEls.nextF, this.showNextFrame.bind(this));
avmenu = this.domEls.avMenu;
for (i = 0, len = avmenu.length; i < len; i++) {
avm = avmenu[i];
avm.onchange = ((function(_this) {
return function(mnu) {
return function() {
return _this.avatar.switchAvatar(mnu.value);
};
};
})(this))(avm);
}
textsu = this.domEls.sigmlURL[0];
return textsu != null ? textsu.onkeypress = ((function(_this) {
return function(evt) {
return _this.handleURLKey(evt);
};
})(this)) : void 0;
};
AvatarGUI.prototype.guiDisablePlay = function() {
this._setElsDisabled(this.domEls.avMenu, true);
this._setElsDisabled(this.domEls.playSU, true);
this._setElsDisabled(this.domEls.playST, true);
this._setElsDisabled(this.domEls.stop, true);
this._setElsDisabled(this.domEls.suspend, true);
this._setElsDisabled(this.domEls.resume, true);
this._setElsDisabled(this.domEls.prevF, true);
return this._setElsDisabled(this.domEls.nextF, true);
};
AvatarGUI.prototype.guiStartPlay = function() {
this._setElsDisabled(this.domEls.avMenu, true);
this._setElsDisabled(this.domEls.playSU, true);
this._setElsDisabled(this.domEls.playST, true);
this._setElsDisabled(this.domEls.stop, false);
this._setElsDisabled(this.domEls.suspend, false);
this._setElsDisabled(this.domEls.resume, true);
this._setElsDisabled(this.domEls.prevF, true);
return this._setElsDisabled(this.domEls.nextF, true);
};
AvatarGUI.prototype.guiStopPlay = function() {
this._setElsDisabled(this.domEls.avMenu, false);
this._setElsDisabled(this.domEls.playSU, false);
this._setElsDisabled(this.domEls.playST, false);
this._setElsDisabled(this.domEls.stop, true);
this._setElsDisabled(this.domEls.suspend, true);
this._setElsDisabled(this.domEls.resume, true);
this._setElsDisabled(this.domEls.prevF, true);
return this._setElsDisabled(this.domEls.nextF, true);
};
AvatarGUI.prototype.guiSuspendPlay = function() {
this._setElsDisabled(this.domEls.avMenu, true);
this._setElsDisabled(this.domEls.playSU, true);
this._setElsDisabled(this.domEls.playST, true);
this._setElsDisabled(this.domEls.stop, false);
this._setElsDisabled(this.domEls.suspend, true);
this._setElsDisabled(this.domEls.resume, false);
this._setElsDisabled(this.domEls.prevF, false);
return this._setElsDisabled(this.domEls.nextF, false);
};
AvatarGUI.prototype._getDOMEls = function() {
var avix, bttnForAv, domels, elForAv, txtForAv, txtaForAv;
avix = this.avIndex;
elForAv = function(tag) {
var elms;
elms = document.getElementsByClassName(tag + " av" + avix);
if (elms.length === 0) {
log("No element for " + tag + " av" + avix);
} else {
if (elms.length > 1) {
log("Multiple (" + elms.length + ") elements for " + tag + " av" + avix);
}
}
return elms;
};
bttnForAv = function(btag) {
return elForAv("bttn" + btag);
};
txtForAv = function(ttag) {
return elForAv("txt" + ttag);
};
txtaForAv = function(tatag) {
return elForAv("txta" + tatag);
};
return domels = {
avCanvas: elForAv("canvasAv"),
avMenu: elForAv("menuAv"),
playSU: bttnForAv("PlaySiGMLURL"),
playST: bttnForAv("PlaySiGMLText"),
stop: bttnForAv("Stop"),
suspend: bttnForAv("Suspend"),
resume: bttnForAv("Resume"),
prevF: bttnForAv("PrevF"),
nextF: bttnForAv("NextF"),
speedDisplay: txtForAv("LogSpeed"),
speedDown: bttnForAv("SpeedDown"),
speedUp: bttnForAv("SpeedUp"),
speedReset: bttnForAv("SpeedReset"),
signAndFrame: txtForAv("SF"),
gloss: txtForAv("Gloss"),
fps: txtForAv("FPS"),
sigmlURL: txtForAv("SiGMLURL"),
sigmlText: txtaForAv("SiGMLText")
};
};
return AvatarGUI;
})();
cwaenv.add(AvatarGUI, "AvatarGUI");
}).call(this);
//-------- js/CWASA.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var AvatarGUI, Config, _configureCWA, _cwasaInitialise, avPanels, cfg, console, cwaenv, cwasaHTMLForSToCA, cwasaInit, document, log, playSiGMLText, playSiGMLURL, setTimeout, stat, stopSiGML, theSToCA;
cwaenv = this.getCWAEnv();
console = this.console;
document = this.document;
setTimeout = this.setTimeout;
log = console.log.bind(console);
Config = cwaenv.get("Config");
AvatarGUI = cwaenv.get("AvatarGUI");
theSToCA = cwaenv.get("theSToCA");
stat = theSToCA.stat;
if (!this.requestAnimFrame) {
this.requestAnimFrame = (function(_this) {
return function() {
return _this.requestAnimationFrame || _this.webkitRequestAnimationFrame || _this.mozRequestAnimationFrame || _this.oRequestAnimationFrame || _this.msRequestAnimationFrame || (function(callback, element) {
return setTimeout(callback, 1000 / 60);
});
};
})(this)();
}
cfg = Config.theConfig;
avPanels = [];
_configureCWA = function(configDone, ccfgpath, initCfg) {
log("CWASA configuration starts: " + ccfgpath);
return Config.load(configDone, ccfgpath, initCfg);
};
_cwasaInitialise = function() {
var N_AVS, avadivs, guidivs, i, initAv, j, k, ref, ref1, ref2, stocadivs;
log("CWASA initialisation starts");
N_AVS = cfg.avSettings.length;
initAv = "luna";
for (i = j = 0, ref = N_AVS; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
guidivs = document.getElementsByClassName("CWASAPanel av" + i);
avadivs = document.getElementsByClassName("CWASAAvatar av" + i);
if ((guidivs.length + avadivs.length) > 0) {
initAv = cfg.avSettings[i].initAv;
avPanels[i] = new AvatarGUI(i, cfg.avSettings[i]);
} else {
avPanels[i] = null;
}
}
for (i = k = 0, ref1 = N_AVS; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
if (avPanels[i]) {
avPanels[i].startAvatar();
}
}
if (cfg.animgenServer != null) {
stat("Server given for Animgen processing");
} else if (theSToCA.hasJava) {
stocadivs = document.getElementsByClassName("SToCA");
if (stocadivs[0] != null) {
if ((ref2 = stocadivs[0]) != null) {
ref2.innerHTML = cwasaHTMLForSToCA(initAv);
}
} else {
theSToCA.hasJava = false;
stat("No SToCA requested");
}
theSToCA.initialise();
} else {
stat("No SToCA as Java unavailable");
}
log("CWASA initialisation ends");
return void 0;
};
cwasaInit = function(initCfg) {
log("CWASA loading configuration");
return _configureCWA(_cwasaInitialise, "cwaclientcfg.json", initCfg);
};
cwasaHTMLForSToCA = function(av) {
var applethtml, attributes, avlist, mkparam, objecthtml, parameters;
log("Creating element for SToCA applet with avatar " + av);
avlist = cfg.allavs.join(":");
mkparam = function(n, v) {
return "<param name=\"" + n + "\" value=\"" + v + "\" />";
};
applethtml = "<!--========================================================-->\n<applet name=\"stocapplet\" id=\"stocApplet\" class=\"stocApplet\" width=\"1\"  height=\"1\" >\n    " + (mkparam("jnlp_href", cfg.jasBase + "jnlp/SToCA.jnlp")) + "\n    " + (mkparam("avatar.id.list", avlist)) + "\n    " + (mkparam("cacheable.avatar.list", avlist)) + "\n    " + (mkparam("avatar.id", av)) + "\n    " + (mkparam("camera.settings", "0.0:0.230:3.3:9.0:18.0:30.0:-1.0:-1.0")) + "\n    " + (mkparam("avatar.fps", cfg.animgenFPS)) + "\n</applet>";
objecthtml = "<!--========================================================-->\n<object type=\"application/x-java-applet\" id=\"stocApplet\" class=\"stocApplet\" width=\"1\"  height=\"1\" >\n    " + (mkparam("jnlp_href", cfg.jasBase + "jnlp/SToCA.jnlp")) + "\n    " + (mkparam("avatar.id.list", avlist)) + "\n    " + (mkparam("cacheable.avatar.list", avlist)) + "\n    " + (mkparam("avatar.id", av)) + "\n    " + (mkparam("camera.settings", "0.0:0.230:3.3:9.0:18.0:30.0:-1.0:-1.0")) + "\n    " + (mkparam("avatar.fps", cfg.animgenFPS)) + "\n</object>";
attributes = {
name: "stocApplet",
id: "stocApplet",
"class": "stocApplet",
codebase: "" + cfg.jasBase,
code: "app.SToCApplet",
archive: "jars/use-jarp.jar, jars/jarpb.jar, jars/avatars/avatar-basic.jar, jars/sigmlinlib.jar, jars/antlr-3.5.2-complete.jar, jogl/jogl.jar, jogl/gluegen-rt.jar",
width: 1,
height: 1
};
parameters = {
codebase_lookup: "false",
scriptable: "true",
options: "SToCApplet",
"ja.version.tag": cfg.jasVersionTag,
"ja.remote.base.url": cfg.jasBase,
"ja.force.remote.ja.home": "true",
"avatar.id.list": avlist,
"cacheable.avatar.list": avlist,
"avatar.id": av,
"do.streamed.animation.build": "true",
"camera.settings": "0.0:0.230:3.3:9.0:18.0:30.0:-1.0:-1.0",
"avatar.fps": cfg.animgenFPS,
"quit.delay.ms": "400",
jnlp_href: "jnlp/SToCA.jnlp"
};
if (theSToCA.isInIE()) {
return applethtml;
} else {
return objecthtml;
}
};
cwaenv.add(cwasaInit, "cwasaInit");
playSiGMLText = (function(_this) {
return function(av, stext) {
var avP;
if (avP = avPanels[av]) {
avP.playSiGMLText(stext);
return "Played SiGML for avatar " + av;
} else {
return "Undefined avatar " + av;
}
};
})(this);
playSiGMLURL = (function(_this) {
return function(av, surl) {
var avP;
if (avP = avPanels[av]) {
avP.playSiGMLURL(surl);
return "Played SiGML from URL for avatar " + av;
} else {
return "Undefined avatar " + av;
}
};
})(this);
stopSiGML = (function(_this) {
return function(av) {
var avP;
if (avP = avPanels[av]) {
avP.stopPlay();
return "Stopped SiGML for avatar " + av;
} else {
return "Undefined avatar " + av;
}
};
})(this);
this.CWASA = {
init: cwasaInit,
playSiGMLURL: playSiGMLURL,
playSiGMLText: playSiGMLText,
stopSiGML: stopSiGML
};
}).call(this);
//--------  END  --------
